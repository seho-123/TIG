/********************************************************************
 * COPYRIGHT -- wsi
 ********************************************************************
 * Package: 
 * File: WSI_types.h
 * Author: ckaczkowski
 * Created: 17 June 2014
 *******************************************************************/

#include <bur/plctypes.h>


#ifndef _WSITYPES_H
#define _WSITYPES_H

#include <..\..\lib\Statelib.h>

#include <..\..\Universal\SuperDefinition.h>


#define PARAM_NUM_MAX  		256
#define PARAM_INT_NUM_MAX  	8
#define PARAM_ENUM_NUM_MAX  8
#define PARAM_STR_NUM_MAX   8
#define VAR_NUM_MAX    		128
#define ENUM_VAR_MAX   		32
#define INT_VAR_MAX    		32
#define STR_VAR_MAX    		64
//#define SEGM_NUM_MAX   		31
#define SEGM_NUM_MAX   		32
#define TXT_RESOURCES_MAX 	32
#define RES_TXT_LEN 		16
#define PAGES_MAX			64




typedef struct LogItem_typ{

	signed long timeStamp;
	signed short status; 
	unsigned long value; 
	plcstring  txt[32];
	
}LogItem_typ;

typedef struct WarnItem_typ{
	signed short status; 
	plcstring  txt[32];
	
}WarnItem_typ;

typedef struct ERROR_Mgr_typ{
	SINT Error;
	unsigned short lastItemIndx;	
	unsigned short history[128];
	LogItem_typ logs[128];
	UINT warnings;

}ERROR_Mgr_typ;



/*********************************************************************/

/***********   VECTOR STATE        ***************************************/

/*********************************************************************/


#define vectSt_Mode_OFF 0
#define vectSt_Mode_Idle 1
#define vectSt_Mode_Hold 2
#define vectSt_Mode_Home 3
#define vectSt_Mode_Pos 4
#define vectSt_Mode_Vel 5
#define vectSt_Mode_Torq 6
#define vectSt_Mode_Volt 7
#define vectSt_Mode_PT 	 8
#define vectSt_Move_Abs  9
#define vectSt_Move_Rel  10  


typedef struct STATE_VECTOR_typ
{ 	
	//plcbit OK;
	float x; 	// value
	float vel; 	// first derivative
	float acc; 	// second derivative
	float amp; 	// current amps
	float volt; // volts
	float softLimits[2]; // software limits
	signed short Mode;
	
}STATE_VECTOR_typ;

typedef struct StateVectorProxy_typ{
	plcstring Name[16];
   /* VAR_INPUT (analog) */	
   UINT simul;
   UINT xCMD;
   float InVal;	
   float maxVel;
   float maxAcc;
   signed short Mode;
   /* VAR_OUTPUT (analog) */
   STATE_VECTOR_typ OutVect;
   signed short Status;
   STATE_VECTOR_typ FbkVect;
   DINT actPosDINT;
   INT FbkWarning;
   
	
}StateVectorProxy_typ;

///////////////////////////////////////////////
/* Units enumeration*/

typedef enum UNIT_Enum
{	
	unitIU = 0,
	unitLength = 1,
	unitSpeed = 2,
	unitAcc = 3,
	unitRot = 4,
	unitTime = 5,
	unitAmp = 6,
	unitVolt = 7,
	unitFreq = 8,
	unitPerc = 9,
	unitAngle = 10,
	unitMaxIndx = 11,
	
} UNIT_Enum;


///////////////////////////////////////////////////////////
 
///  Types for NODE variable
 
  typedef struct Scaled_Var_obj{
	 float* pfVal;
	 plcstring name[32];
	 plcstring enumTXT[32+1];
	 plcstring VarName[32];
	 UINT Indx;
	 
	 UNIT_Enum	unitType;
	 UINT  PlcUnitIndx;
	 UINT  DefaultUnit;
	 int precision;
	 UINT segm;
	 UINT type;
	 
}Scaled_Var_obj;

 typedef struct Integer_Var_obj{
	 DINT* pVal;
	 plcstring name[32];
	 plcstring enumTXT[32+1];
	 plcstring VarName[32];
	 UINT Indx;

	 DINT Min;
	 DINT Max;
	 UINT segm;
	 
 }Integer_Var_obj; 

 typedef struct String_Var_obj{
	 plcstring* pStr;
	 plcstring name[32];
	 plcstring enumTXT[32+1];
	 plcstring VarName[32];
	 UINT Indx;

	 UINT Len;
	 UINT Type;

	 UINT segm; // can be used in future 
	 
 }String_Var_obj; 

 
 typedef struct Enum_Var_obj{
	 UDINT pVal;
	 plcstring name[32];
	 plcstring enumTXT[32+1];
	 plcstring VarName[32];
	 UINT Indx;
	 UINT TxtIndx; // Index in Cfg.

	 DINT Min;
	 DINT Max;
	 UINT segm;
	 
 } Enum_Var_obj;
  
 typedef struct SegmentsTable_obj{
 	
	UINT segm_num;
	UINT ParamIndx[PARAM_NUM_MAX]; //PARAM_NUM_MAX
 }SegmentsTable_obj;
 
  typedef struct Unit_Scale_obj{
 
	 float gain;
	 float offset;
	 
	 INT extraDigits;
 
	 float incrGain;
	 float incrOffset;
 
	 STRING txt[8];
 
  }Unit_Scale_obj;
 
  typedef struct Units_obj{
	 UNIT_Enum	unitType;
	 Unit_Scale_obj unitScale[SUB_UNIT_NUM];
  }Units_obj;



/***********************************************************************************/

/***********   Conifg & Current Config   Types        ***************************************/

/***********************************************************************************/


/* Datatypes and datatypes of function blocks */
typedef struct Cfg_Param_typ
{	
	UNIT_Enum unit;
	float min;
	float max;
	float incrMin;
	float incrMax;
	float defaultVal;
	
	
} Cfg_Param_typ;

typedef struct Cfg_Param_INT_typ{

	DINT min;
	DINT max;
	DINT defaultVal;
	
}Cfg_Param_INT_typ;

typedef struct Cfg_Param_STR_typ{
	UINT len;
	plcstring defaultStr[32];
	
}Cfg_Param_STR_typ;


typedef struct PAGE_DICT_typ{
	UINT indx;
	plcstring enumTXT[32+1];
	
}PAGE_DICT_typ;




typedef struct CurCfg_Param_typ
{	float val[SEGM_NUM_MAX+1];
	float incr;
	float min;
	float max;
	SINT  segmYes;
} CurCfg_Param_typ;

typedef struct CurCfg_Param_INT_typ
{	DINT val[SEGM_NUM_MAX+1];
	float incr;
	float min;
	float max;
	SINT  segmYes;
} CurCfg_Param_INT_typ;

typedef struct CurCfg_Param_STR_typ
{	
	plcstring str[32];
	UINT len;
	UINT type;
} CurCfg_Param_STR_typ;


/* Datatypes and datatypes of function blocks */
typedef struct Calib_Param_typ
{	
	UINT num;
	float val[10];
	
} Calib_Param_typ;


typedef struct CurCfg_typ
{	
	UDINT Signature;
	plcstring WeldProgramName[16];
	CurCfg_Param_typ Param[PARAM_NUM_MAX];
	CurCfg_Param_INT_typ Param_INT[PARAM_INT_NUM_MAX];
	CurCfg_Param_INT_typ Param_ENUM[PARAM_ENUM_NUM_MAX];
	CurCfg_Param_STR_typ Param_STR[PARAM_STR_NUM_MAX]; //  Not Segmented - could be added in the future
	
	plcstring NextProgramName[32];
	plcstring CurProgramName[32];
	plcstring FreeText[63];
	USINT PleaseUpdate;
	USINT Dirty;
} CurCfg_typ;

// This structure holds information for editable values and any values for HMI with their phisical location
// General rule is : if 	'' plcstring VarName[32]'' is empty use " UINT Indx" as index in proper(type determined)  cfg array from:
/*
	Cfg_Param_typ Param[PARAM_NUM_MAX];
	Cfg_Param_INT_typ Param_INT[PARAM_INT_NUM_MAX];
	Cfg_Param_INT_typ Param_ENUM[PARAM_ENUM_NUM_MAX];
	Cfg_Param_STR_typ Param_STR[PARAM_STR_NUM_MAX];
*/	

typedef struct Cfg_typ
{	
	// This declare - where to find instave of proper type , if can be segmented , and how to display on HMI 	
	Scaled_Var_obj ScaledVar[PARAM_NUM_MAX + VAR_NUM_MAX];
	Enum_Var_obj EnumVar[PARAM_ENUM_NUM_MAX + ENUM_VAR_MAX];
	Integer_Var_obj IntVar[PARAM_INT_NUM_MAX + INT_VAR_MAX];
	String_Var_obj StringVar[PARAM_STR_NUM_MAX + STR_VAR_MAX];

	// this declare how to edit proper type - it means : low up limit , increments etc.
		Cfg_Param_typ Param[PARAM_NUM_MAX];
	Cfg_Param_INT_typ Param_INT[PARAM_INT_NUM_MAX];
	Cfg_Param_INT_typ Param_ENUM[PARAM_ENUM_NUM_MAX];
	Cfg_Param_STR_typ Param_STR[PARAM_STR_NUM_MAX];

	// text resources for enumrated txt or any string
	plcstring TXT_Resources[TXT_RESOURCES_MAX][RES_TXT_LEN];
	// Dictionary of head nodes
	PAGE_DICT_typ PagesDict[PAGES_MAX];
	
} Cfg_typ;


typedef struct CurCalib_typ
{	
	UINT num;
	Calib_Param_typ Points[10];
	DINT GenSetup[8];
} CurCalib_typ;




///////////////////////////////////////////////////////////


/***********************************************/

/****        GENERIC PROCESS					****/

/************************************************/


/******   Generic Process Command *************/
#define prcsIDLE  		0
#define prcsSTART  		1
#define prcsSTOP   		2
#define prcsJOGpos 		3
#define prcsJOGneg 		4
#define prcsSTEPpos   	5
#define prcsSTEPneg   	6
#define prcsRESTART  	7
#define prcsForceON  	8
#define prcsHalt   		9
#define prcsRefrCalib   10
#define prcsCalib   	11
#define prcsJump2Run   	12
#define prcsRetract   	13
#define prcsDirectCntrl 14

/******   Generic Vector Command *************/
#define VECT_UpdateSignFilter		1	
#define VECT_ClearSignFilter		2
#define VECT_FullSignFilter			3
#define VECT_Set_Gain				4
#define VECT_Set_Gain_Zero			5

/******   Generic Process Status *************/

typedef enum prcsSTATUS_Enum
{	
	prcsSTATUS_StartDly = 10,
	prcsSTATUS_RampUp 	= 11,
	prcsSTATUS_Run 		= 12,
	prcsSTATUS_StopDly 	= 13,
	prcsSTATUS_RampDwn 	= 14,
	prcsSTATUS_Stopped  = 15,
	prcsSTATUS_Fault  	= 16,
	prcsSTATUS_Jog  	= 17,
	prcsSTATUS_Step  	= 18,
	prcsSTATUS_Init  	= 19,
	prcsSTATUS_ForceON  = 20,
	prcsSTATUS_Retract 	= 21,
	prcsSTATUS_AVC_OK   = 22,
	prcsSTATUS_AVC_Hold = 23,
	prcsSTATUS_DirectCntrl = 24,
	prcsSTATUS_ForceCalib  = 25,
	prcsSTATUS_ReturnDly  	= 27,
	prcsSTATUS_Return  		= 28
	
}prcsSTATUS_Enum;

/*********** Gen Process Types **********/

typedef struct GenProcess_typ
  {   
	  /* VAR_IN_OUT (analog and digital) */
	  //CurCfg_typ* pCurCfg; /* pointer to permanent memory with parameters */
	 // StateVectorProxy_typ *pVect; /* pointer to Vector State generator array */
	  plcstring Name[16]; /* Name of process */
	  USINT Disable;
	  /* VAR_INPUT (analog) */
	  //unsigned short VectStateNum; /* size of vectors array for process */	  
	  USINT xCMD; /* command from master */
	  float fParam[4]; /* command parameters */
	  DINT	Param[4]; /* command parameters */
	  /* VAR_OUTPUT (analog) */
	  prcsSTATUS_Enum Status; /* current status */
	  INT subStatus;
	  float Fbk[10]; /* current status */
	  INT FbkWarning;
	  /* VAR (digital) */
	  USINT _step; /* internal use */
	   /* VAR_INPUT (analog) */
	   INT TestMode;
	  
  } GenProcess_typ;
  
 ///////////////////////////////////////////////////////////

 
 /***********************************************/
 
 /****		   Hardware 							 ****/
 
 /************************************************/
 
 
 typedef struct X20MM4456_HARDWARE_obj
 {	 
	 
	 UDINT SerialNumber;
	 UINT ModuleID;
	 UINT HardwareVariant;
	 UINT FirmwareVersion;
 
	 
 
	 UINT PeriodDurationPWM;
	 BOOL UnderVoltageError;
	 BOOL VolatgeWarning;
	 BOOL OverVoltageError;
	 BOOL OvertempeatureError;
	 
	 INT PulseWidthPWM[4];
	 
	 BOOL StartLatch[4];
	 BOOL DitherDisable[4];
	 BOOL ClearError[4];
	 BOOL ShowMeanCurrent[4];
	 BOOL ResetCounter[4];
 
	 INT Counter[4];
	 INT CounterLatch[4];
 
	 
	 BOOL PWMError[4];
	 BOOL CurrentError[4];
	 BOOL OverCurrentError[4];
 
 
 }X20MM4456_HARDWARE_obj;		 
 
 typedef struct PENDANT_HARDWARE_intr {

		DINT TickIncr;
		DINT _ABEncoder;
		plcbit _Inp[16];
		
}PENDANT_HARDWARE_intr;

 
 typedef struct PENDANT_HARDWARE_obj
 {	 
	 plcstring RSDeviceStr[32];
	 UDINT SerialNumber;
	 UINT ModuleID;
	 UINT HardwareVariant;
	 UINT FirmwareVersion;
 
	 DINT ABEncoder;
	 plcbit NotWheelReset;
	 plcbit Outp[16];
	 plcbit Inp[16];

	 PENDANT_HARDWARE_intr _intr;  
 
	 
 }PENDANT_HARDWARE_obj;
 
 
 typedef struct HARDWARE_typ
 {
	//PENDANT_HARDWARE_obj Pend;
	X20MM4456_HARDWARE_obj PWM[HRD_PWM_MOD_NUM];
	INT Encoder[HRD_ENCODER_NUM];	
	plcbit Inp[HRD_DIG_INP_NUM];
	plcbit Outp[HRD_DIG_OUTP_NUM];
	INT Anal_Inp[HRD_AN_INP_NUM];
	INT Anal_Outp[HRD_AN_OUTP_NUM];
	
 }HARDWARE_typ; 


///////////////////////////////////////////////////////////


/***********************************************/

/****        MASTER							****/

/************************************************/ 

 #define INTERF_NUM 2

// Command to master	
 #define mstrRESTART 1 // restart Master
 
 typedef struct MASTER_MSC_typ
 {
	INT _ABEncoder;
	
 }MASTER_MSC_typ;	


   typedef struct HMI_INTRF_intr_typ
 {
	INT _Wheel;
	UDINT _GlblBtnCmd[2];
	UINT _BtnCmd;
 }HMI_INTRF_intr_typ;
   
  typedef struct HMI_INTRF_typ
 {
	USINT Mode;
	USINT ModeLED;
	//USINT TestMode;
	USINT LCD_ENTR_LED;
	
	
	UINT BtnCmd; 
	UINT BtnLED;

	// This is for Android 
	UDINT GlblBtnCmd[2];	
	UDINT GlblBtnLED[2];
	plcbit TestMode;
	//
  
	plcbit LCDEntr;
	plcbit LCDEntr_PosEdge;
	plcbit LCDEntr_NegEdge;


	plcbit TickPlus;
	plcbit TickMinus;
  
	INT Wheel;
	INT WheelDelta;
	UINT tempIndx;
	TON_typ Tmr;

	HMI_INTRF_intr_typ _intr;	
	
 }HMI_INTRF_typ;

  typedef struct ANDROID_INTRF_typ
 {
	//UINT Mode;
	UINT TestMode; //  read only
	UINT MasterMode; // read only
	UINT UserLevel; // write only
	
	// This is from Buttons and encoder wheel 
	UDINT GlblBtnCmd[2]; // write only	
	UDINT GlblBtnLED[2]; // read only
	UINT EntrBtn; // write only
	UINT TickPlus; // write only
	UINT TickMinus; // write only
	INT Wheel;	// write only	
	/////
	
	// Screen View and Control
	UDINT FiredEvent; // write only
	UINT PleaseUpdate;// write only
	UINT curHeadID; // write only
	UINT curLineID; // write only	
	
	
	UINT Node2JumpID; // read only
	UINT JumpLineID; // read only
	UINT xCMD; // read only
	

	UINT MsgTmr_Done; // read only
	plcstring Message[4][20+1];// read only

	plcstring Banner[32+1];// read only

	UINT Alive ; // Write only - heartbeat from HMI

	INT curNumSegments; // read only
	INT maxNumSegments; // read only
	

	plcstring MasterModTXT[20+1]; // read only - Master Mode as Text
	plcstring UserLevelTXT[20+1]; // read only - USER Text as Text
	
	
 }ANDROID_INTRF_typ;
   
  
  typedef struct HMI_typ
 {
 	// 
	UINT DynPageNodeIndx; // write by master
	plcstring ActiveBanner[32]; // write by master
	plcstring *pHMI_Lines[20]; // write by master
	
	//

	UINT curHeadID; //  -write by HMi device
	UINT curNodeID; //  -write by HMi device
	UDINT FiredEvent; //-write by HMi device

	
	plcstring* pBanner;  // Pointers to string - text write by HMI view control
	plcstring* pMessage[4]; // Pointers to string  - text write by HMI view control	
	USINT EditMode; // write by HMI view control
	UINT  UserLevel; // write by HMI view control

	UINT Node2JumpID; // write by HMI view control
	UINT JumpLineID; // write by HMI view control
	UINT xCMD; // write by HMI view control

	// for internal use
	USINT FastBlink;
	USINT SlowBlink;
	UINT oldDynPageNodeIndx; // 
	plcbit DynPageActive;
	Calib_Param_typ tempCalib;
	INT Indx;
	USINT selectNextWeldProgram_step;
	UINT CalibStep;
	BOOL CalibStepDone;
	prcsSTATUS_Enum _ProcStatus;
	TON_typ MsgTmr;
	plcbit ROM_USB;
	
	
 }HMI_typ;

typedef struct MASTER_typ
{
   USINT xCmd;	
   USINT Active;
   Cfg_typ* pCfg;
   CurCfg_typ* pCurCfg;
   CurCalib_typ* pCalib;
   CurCalib_typ* pDefaultCalib;
   //ERROR_Mgr_typ *pLog;
   //GenProcess_typ *pProc;
   UDINT pUnits;
   UDINT pScaledVar;
   INT *pScaledUnitIndx;
   UDINT *pSegmentTable;
   DINT curSegm[SEGM_TYPE_NUM];
   //unsigned short ProcNum;
   HMI_INTRF_typ Intrf[INTERF_NUM];
   UDINT pNode[2];
   UINT nodesNum[2];
   HMI_typ Hmi[INTERF_NUM];
   SM_obj sm; 
   UINT ToolHeadID;
   USINT Mode;
   INT TestMode;
   INT CalibType;
   ANDROID_INTRF_typ AndIntrf[INTERF_NUM];
   USINT WireDisabled;
   UINT SeqStep;
   plcbit ESTOP;
   plcbit *pESTOP_Inp;
   plcstring Password[16];

   INT numSegm;
   INT numZone;
   INT ticksPerSegm;
   INT ticksPerZone;

   UINT paramLastNum;
   UINT varLastNum ;
   UINT paramEnumLastNum;
   UINT varEnumLastNum ;
   UINT paramIntgLastNum;
   UINT varIntLastNum ;
   UINT paramStrLastNum;
   UINT varStrLastNum ;
	   
}MASTER_typ;



/***********************************************/

/********			 Generic Motor 	    **********/

/***********************************************/


typedef struct GEN_MTR_obj
{

	UDINT pState;
	plcstring Name[16];
	USINT Disable;
	USINT xCmd;
	float actPos;
	float actVel;
	float fParam[2];

	struct Hrdw
	{	
		UINT *pPeriodDurationPWM;
		INT *pPulseWidthPWM;
		BOOL *pClearError;
		INT *pEncFbk;
		INT *pAnalogFbk;
		
		
	}Hrdw;	
	
	struct Cfg{
		DINT units;
		float enc_dir;
		float mtr_dir;
		float rev_scale;
		//float loopPeriod;
				
	}Cfg;

	struct msc
	{	

		LCRRamp_typ Ramp;
		//LCRPT2o_typ Trajectory;
		//HCRFIFO_typ FIFODelay;
		//float FIFODelay[FIFO_DLY+1];
		
		LCRSlimPID_typ PID;
		lcrslimpid_par_typ PIDParameters;

		DINT Pos;
		INT _pos;
		float _vel;
		float _amp;
		float _volt;
		DINT deltaPos;

		//float kVel;
		//float kAcc;
		float kPos;

		
	} msc;	

}GEN_MTR_obj;

///////////////////////////////////////////////////////////


/***********************************************/

/****        B&R 	Screen   						****/

/************************************************/

 //*===COLORS===*/
#define TRANSP						0xFF
#define GREEN						10
#define DARK_GREEN					2
#define BLUE						1
#define BABY_BLUE					11
#define TEAL						168
#define RED							0x33
#define YELLOW						46
#define BLACK						0
#define WHITE						15
#define GRAY						7
#define DARK_NAVY					219
#define DARK_GRAY					8
#define LIGHT_GRAY					227
#define CYAN						196
#define MAGENTA						21
#define BROWN						86
#define LIGHT_BLUE					52


typedef struct SCREEN_obj
{  
   
	unsigned short SetPage;
	unsigned short ReadPage;
	unsigned short GotoScreen;
	unsigned short ReturnScreen;
	unsigned short Index;
	unsigned short NavMenu;
	unsigned short Update;
	plcbit btn_YES;
	plcbit btn_NO;
	plcbit btn[32];
	plcbit btnBar[32];
	plcbit btnMenu[10];
	plcbit btnSave;
	plcbit btnIndex;
	unsigned short vis[32];
	unsigned short visBar[32];
	unsigned short visSave;
	unsigned short colorBackground;
	unsigned short color[8];
	unsigned short colorBar[8];
	unsigned short colorSave;
	signed long Param[10];
	float fParam[10];
	unsigned short Language;
	unsigned short Units;
	unsigned short AngleUnits;
	float UnitsFactor;
	float UnitsOffset;
	unsigned long LifeSign;
	USINT AccessLevel;
	unsigned short menubtnColor[10];
  } SCREEN_obj;	
///////////////////////////////////////////////////////////


/***********************************************/

/****        Technosoft Servos					****/

/************************************************/


// Commands definition
#define TML_IDLE 0
#define TML_RESTART 1
// 2 - 14 reserved for TML_RESTART
#define TML_HOLD_MODE 15
// 15 - 19 reserved for TML_HOLD_MODE
#define TML_POS_MODE 20
// 21 - 29 reserved for TML_POS_MODE
#define TML_VEL_MODE 30
// 31 - 39 reserved for TML_VEL_MODE
#define TML_TORQ_MODE 40
// 41 - 49 reserved for TML_TORQ_MODE
#define TML_VOLT_MODE 50
// 51 - 59 reserved for TML_VOLT_MODE
#define TML_PT_MODE 60
// 61 - 69 reserved for TML_PT_MODE

#define TML_DOWNL			100	

#define TML_UpdateFilter	150	
#define TML_ClearFilter		151	
#define TML_FullFilter		152
#define TML_SetGain			160
#define TML_SetGain_Zero	165


#define TML_ERROR		255	

// Status Mask
#define ERR_CANbus_MSK 			0x0001
#define ERR_ShortCircuit_MSK 	0x0002
#define ERR_InvalidSetup_MSK 	0x0004
#define ERR_Cntrl_MSK 			0x0008
#define ERR_RS232_MSK 			0x0010

//#define SREG_Fault_MSK 				0x80000000
#define SREG_Fault_MSK 				0x80000000

#define SREG_MotionCompleted_MSK 	0x00000400



/******  TML STatus enumeration    *****/

typedef enum TML_STAT_Enum
{	
	TML_STAT_DRIVE_ERR = 	-4,
	TML_STAT_VER_ERR   =	-3,
	TML_STAT_INIT  	   =	-2,
	TML_HEARTBEAT_ERR  = 	-1,
	TML_STAT_DEAD  	   =	0,
	TML_STAT_READY 	   =	1,
	TML_STAT_IDLE 	   =	2,
	TML_STAT_HOLD_INIT 	   =	3,
	TML_STAT_HOLD_OK 	   =	4,
	TML_STAT_POS_MODE_INIT  =	5,
	TML_STAT_POS_MODE_OK    =	6,
	TML_STAT_VEL_MODE_INIT  =	7,
	TML_STAT_VEL_MODE_OK 	=	8,
	TML_STAT_TORQ_MODE_INIT =	9,
	TML_STAT_TORQ_MODE_OK 	=	10,
	TML_STAT_VOLT_MODE_INIT =	11,
	TML_STAT_VOLT_MODE_OK 	=	12,
	TML_STAT_PT_MODE_INIT 	=	13,
	TML_STAT_PT_MODE_OK 	=	14,
	
}TML_STAT_Enum;	

typedef struct TML_typ
{	
	StateVectorProxy_typ* pState; 
	plcstring Name[16];
	USINT Disable;
	unsigned long  ProgramVersion;
	unsigned long  FirmwareVersion;
	
	float PosFBK;
	USINT xCMD;
	TML_STAT_Enum Status;
	unsigned long StatusReg;
	unsigned short ErrorReg;
	plcbit Error;
	plcbit EnableInp;
	unsigned short AnInp[2];
	plcbit DigInp[4];
	// DigInp[2] = LSP
	// DigInp[3] = LSN
	// AnInp[0] = REF
	// AnInp[1] = FDBK
	struct _cfg{
		DINT units;
		DINT rev_motor;
		float rev_scale;
		float loopPeriod;
		float maxVel;
		float maxAcc;
		float signFilter;
		DINT  satp;
		plcstring programName[32];
		float sftLimitPos;
		float sftLimitNeg;
		
	}_cfg;
	
	struct _int{
		DINT _pos;
		float _floatPos;
		float _vel;
		float _amp;
		float _volt;
		float kVel;
		float kAcc;
		float kPos;
		UINT PVTPeriod;
		SINT Init;
		float startPos;
		//UINT step;
		
	}_int;
	
} TML_typ;


typedef struct TML_CHAN_HRDW_typ
{
	USINT AxisNum;
	
	USINT TXCountReadBack;
	//
	USINT RXDataSize0;
	USINT RXCount;
	USINT buff[4];
	UDINT RXIdent0;
	UINT  RXData0Word0[4];
	//	
	USINT TXCount;
	USINT TXDataSize;
	UDINT TXIdent;
	UINT  TXDataWord0[4];
	
	USINT _oldRxCount;
	USINT _indx;

}TML_CHAN_HRDW_typ;

typedef struct TML_Axis_typ
{	unsigned short AxisID;
	unsigned long  Version;  
	unsigned long  ProgramVersion;
	unsigned long  FirmwareVersion;
	USINT  Flag;
	USINT  AxisState;
	unsigned short DriveStatusRegisterL;
	unsigned short DriveStatusRegisterH;
	unsigned short DriveErrorRegister;
	unsigned short PVTstatus;
	unsigned short DataLow;
	unsigned short DataHigh;
	unsigned short VarAddress;
	signed long	   curPos;	
	signed long	   _curPos;
	unsigned short pointer;
	short deltaAPOS;
	//unsigned long  CmdWord;
	unsigned short PointCounter;
	TON_typ HeartBeat;
	TON_typ InitTmr;
	
	
	
} TML_Axis_typ;



typedef struct TML_MGR_typ
{
	TML_CHAN_HRDW_typ hrdw[2];
	UDINT Firmware[2];
	USINT BlockTrans[2];
	TML_Axis_typ *pAxis[2];
	TML_typ *pTML[2];
	UDINT pLog;


}TML_MGR_typ;


///////////////////////////////////////////////////////////


/***********************************************/

/********			 Files Operetion	    **********/

/***********************************************/


#define F_READ 				1
#define F_WRITE 			2
#define F_DELETE			3
#define F_FREE_MEM 			4

#define F_LOAD_CURCFG		5
#define F_SAVE_CURCFG		6
#define F_SAVE_AS_CURCFG	7

#define F_RENAME			8
#define F_COPY				9
#define F_GET_NEXT_FILE		10	
#define F_SET_NEXT_FILE		11	
#define F_READ_FILE_TO_TMP 	12
#define F_SAVE_AS_TMP 		13

#define F_READ_DIR 			20
#define F_READ_FILE_INF 	21


#define F_OPEN_ONLY 		30
#define F_CREATE_ONLY 		31
#define F_WRITE_ONLY 		32
#define F_CLOSE_ONLY 		33


typedef struct XML_RW_HS_INT_typ
{
	UINT step;
	USINT          byErrorLevel;
	UINT           wStatus;
	UINT           wError;
	UDINT          dwIdent;
	UDINT 		   memlng;	
	
	FileOpen_typ   FOpen;
	FileClose_typ  FClose;
	FileCreate_typ FCreate;
	FileRead_typ   FRead;
	FileWrite_typ  FWrite;
	FileDelete_typ FDelete;
	DirInfo_typ	   FDirInfo;
	DirRead_typ	   FFileInfo;

	FileRename_typ FRename;
	FileCopy_typ   FCopy;

	UDINT OffsetToWeldProgramLinkMode;
	UDINT OffsetToWeldProgramRepeat;	

	UINT  PathDoneCnt;
	
		

}XML_RW_HS_INT_typ;

typedef struct FILE_SCHEDULE_typ
{
	plcstring nextFileName[32];
	DINT WeldProgramLinkMode;
	float WeldProgramRepeat;	
	
}FILE_SCHEDULE_typ;


typedef struct FILE_RW_typ
{

	USINT CMD;
	plcbit Done;
	plcbit Error;
	plcbit FileLocked;

	//plcstring varName[32];
	plcstring fileName[32];
	plcstring fileNewName[32];
	
	plcstring deviceName[32];
	plcstring targetDeviceName[32];

	plcstring MsgText[32];
	FILE_SCHEDULE_typ FileSchedule;
	
	
	CurCfg_typ curCfgTemp;
	fiDIR_READ_DATA  FileInfo[1];
	

	UDINT pMem;
	UDINT Len;
	UDINT Offset;

	XML_RW_HS_INT_typ _int;


}FILE_RW_typ;



///////////////////////////////////////////////////////////


/***********************************************/

/******	SERIAL PORT & LCD DISPALY Lib       ********/

/***********************************************/


#define SUB_UNIT_NUM	4
#define NUM_LINE 		3

// Methods Enumeration

#define IDLE_CMD 		0
#define JUMP_CMD 		1
#define JUMP2ID_CMD 	2
#define UPDATE_CMD 		3


// Variable type 

#define T_NATIVE		0x0 // native PVI type
#define T_INTEGER		0x1
#define T_ENUM			0x2
#define T_SCALED		0x4   // This cover Float
#define T_STRING		0x8

// Extra Atrubutes for displaying can be added
#define T_ATR_ENUM_TXT		0x1000
#define T_ATR_BLINK			0x2000
#define T_ATR_FAST_BLINK    0x4000
#define T_ATR_TXT_HIDDEN    0x8000

#define VAR_READONLY    0x10
#define VAR_CURCFG		0x20


// Variable type 
/*
#define T_BLINK			1
#define T_FAST_BLINK    2
#define T_ENUM			4
#define T_SCALED		8
#define T_STRING		16
#define T_STRING_HIDDEN	32

*/

///////////////////
// Node type 

// Non Additive
#define N_STAT 		0  //display as normal, no icon, focus box skips
#define N_EDIT		1  //display as normal, edit icon, focus box, enter jumps to edit page (with type)
#define N_JUMP 		2  //display as normal, jump icon, focus box, enter jumps to new node
#define N_SCROLL_PG 4  //not for Android pendant, treat as N_SCROLL  
#define N_SCROLL 	8  //display as normal, no edit icon, focus box, ne edit, no jump


// Additive
#define N_EVENT 	0x10 //can be combined with N_STAT, N_EDIT, N_JUMP, N_SCROLL_PG, N_SCROLL (set event value into fire event) 
#define N_EDIT_IN_PLACE 0x20 // not focus scroll , send index , encoder and enter Btn state to plc, plc updates node text

// Additive but Obsolete - do NOT use it in Android
#define N_EDIT_DIS 	0x40 //not for Android pendant, ignore
#define N_NO_PREFIX	0x80 //not for Android pendant, ignore
#define N_USER_EDIT	0x100 //not for Android pendant, ignore
#define N_ONLY_LCD	0x200 //not for Android pendant, ignore





// Edit Mode
#define EDIT_VAL 	0
#define EDIT_UNIT 	1
#define EDIT_MIN 	2
#define EDIT_MAX 	3
#define EDIT_INCR 	4

#define EDIT_MODE_FULL 0
#define EDIT_MODE_VALUE 1
#define EDIT_MODE_UNIT  2
#define EDIT_MODE_MIN   3
#define EDIT_MODE_MAX   4
#define EDIT_MODE_INCR  5






typedef struct SerialPortDriver{
	 FRM_xopen_typ	 Open;							 
	 XOPENCONFIG	 OpenConfig;						 
	 FRM_gbuf_typ	 GetBuffer; 			 
	 FRM_rbuf_typ	 Release;					  
	 FRM_robuf_typ	 ReleaseOutput; 		  
	 FRM_write_typ	 Write; 			  
	 FRM_read_typ	 Read;	 
	 FRM_mode_typ	 Mode;
	 FRM_close_typ	 Close;
		 
	 UINT			 StatusOpen;
	 UINT			 StatusWrite;
	 UINT			 StatusRead;
	 UINT			 StatusGetBuffer;
	 UINT			 StatusReleaseOutputBuffer; 
	 UINT			 StatusMode; 
	 UINT			 StatusClose; 
 
	 UDINT			 Ident; 							  
	 UDINT* 		 pSendBuffer;
	 UDINT* 		 pReadBuffer; 
	 UINT			 SendLength;
	 UINT			 ReadLength;
	 UINT			 l; 
 
	 UINT			 txRequest;
	 UINT			 txBufRequest;
	 UINT			 txDataLen;
	 UINT			 rxReady;
	 UINT			 txMessageCounter;
	 UINT			 rxMessageCounter;
	 UINT			 txError;
	 UINT			 rxError;
	 UINT			 initError;
 
	 STRING 		 sDevice[32];
	 STRING 		 sMode[64]; 			 
	 STRING 		 sModeNew[64];
	 USINT			 _parity;
 
	 plcstring		 txData[256];
	 plcstring		 rxData[256];
	 STRING 		 sInput[64];
						 
 }SerialPortDriver_typ;
 /***************************************/

 
  
 
 
 
  
#define UNIT_IU  		0 
#define UNIT_mm   		1 
#define UNIT_inch   	2 
#define UNIT_cm   		3
 
   
#define UNIT_IU   			0 
#define UNIT_mm_per_sec   	1 
#define UNIT_inch_per_min   2 
#define UNIT_inch_per_sec   3 
 
  
#define UNIT_IU   			0 
#define UNIT_mm_per_sec2   	1 
#define UNIT_inch_per_sec2  2
#define UNIT_cm_per_sec2  	3
 
 
#define UNIT_IU   	0 
#define UNIT_RPS   	1 
#define UNIT_RPM  	2 
#define UNIT_RPh  	3 
 
 
#define UNIT_IU   	0 
#define UNIT_sec   	1 
#define UNIT_min  	2
#define UNIT_h  	3
 
 
#define UNIT_IU   	0 
#define UNIT_Amp	1 
#define UNIT_kAmp  	2
#define UNIT_mAmp  	3
 
 
#define UNIT_IU   	0 
#define UNIT_Volt   1 
#define UNIT_kVolt  2 
#define UNIT_mVolt  3
 
#define UNIT_IU   	0 
#define UNIT_Hz   	1 
#define UNIT_kHz  	2	 
#define UNIT_mHz  	3
 
#define UNIT_IU   		0 
#define UNIT_PERCENT   	1 
 
#define UNIT_IU   	0
#define UNIT_DEG   	1 
#define UNIT_RAD   	2 
 

  
  typedef struct VAR_obj{
  
	  UINT Type;
	  plcstring Format[64];
	  //plcstring Var1Name[32];	
	
	  UINT Var1ID;
	
  }VAR_obj;
  
  
  /* Datatypes */
  typedef struct LCD_NODE_obj
  { 
  
	  UINT	ID;
	  UINT	HeadID;
	  UINT  JumpNodeID;
	  
	  UINT  Type;
	  UDINT pHeadNode;
	  UINT	MinUserLevel;
	  //UDINT pPrevNode;
	  //UDINT pNextNode;
	  UDINT pJumpNode;
	  UINT JumpLineID;
	  UINT Event;
	  VAR_obj var;
	  //void (*lcdCall)();
  
  
  }LCD_NODE_obj;
 
  
  
  
 /*******************************/
 /****** LCD Commands **********/
  
#define LCD_SET_CURSOR 			0
#define LCD_BLINK_CURSOR_ON 	1
#define LCD_BLINK_CURSOR_OFF 	2
#define LCD_UNDERLINE_ON		3
#define LCD_UNDERLINE_OFF		4
#define LCD_SET_CONTRAST		5
#define LCD_SET_BACKLIGHT		6
  
#define LCD_TURN_ON_DISPLAY		7
#define LCD_TURN_OFF_DISPLAY	8
#define LCD_CLEAR_DISPLAY		9
  
#define LCD_SET_BAUDRATE		10
  
  
  typedef struct LCD_CMD_typ{
	  UINT len;   
	  USINT cmd[6];
  }LCD_CMD_typ;   
  
  
  static const	LCD_CMD_typ  LCD_CMD[11]=
  { 
	  {3, {0xFE,0x45,0x00}},  //LCD_SET_CURSOR
	  {2, {0xFE,0x4B}}, 	  // LCD_BLINK_CURSOR_ON
	  {2, {0xFE,0x4C}}, 	  // LCD_BLINK_CURSOR_OFF
	  {2, {0xFE,0x47}}, 	  // LCD_UNDERLINE_ON
	  {2, {0xFE,0x48}}, 	  // LCD_UNDERLINE_OFF
	  {3, {0xFE,0x52}}, 	  // LCD_SET_CONTRAST
	  {3, {0xFE,0x53}}, 	  // LCD_SET_BACKLIGHT	  
	  {2, {0xFE,0x41}}, 	  // LCD_TURN_ON_DISPLAY
	  {2, {0xFE,0x42}}, 	  // LCD_TURN_OFF_DISPLAY
	  {2, {0xFE,0x51}}, 	  // LCD_CLEAR_DISPLAY
	  {3, {0xFE,0x61}}, 	  // LCD_SET_BAUDRATE
  
  };
  
  
 
  typedef struct LCD_MGR_INTR_TYP
  {
	  UINT clk;
	  UINT keyPos;
	  USINT editStep;
	  plcbit SlowBlink;
	  plcbit FastBlink;
	  float _slowBlink;
	  float _fastBlink;
	  //SM_obj sm[NUM_LINE];
	  USINT displStep;
	  plcstring LineTXT[NUM_LINE][32];
	  LCD_NODE_obj *pNodes[NUM_LINE];
	  float tasktime;
	  USINT WhatToEdit;
	  USINT scrollDir;
	  //INT _wheel;
  
  
  }LCD_MGR_INTR_TYP;
  
 
   typedef struct LCD_MGR_INTRF_TYP
  {
	  plcbit LCDEntr;
	  plcbit LCDEntr_NegEdge;
	  plcbit LCDEntr_PosEdge;
	  plcbit TickPlus;
	  plcbit TickMinus;
	  //INT Wheel;
	  INT WheelDelta;
  
  
  }LCD_MGR_INTRF_TYP;
 
typedef struct LCD_MGR_obj
{ 
	USINT StaticMessageVisible;
	UINT  UserLevel;
	plcstring KeyPad[20+1];
	MASTER_typ *pMaster;
	LCD_NODE_obj *pMyNodes; // this is pointer to Nodes memory
	//Units_obj *pUnits;
	//UINT *pScaledUnitIndx;
	LCD_MGR_INTR_TYP Intr;
	LCD_MGR_INTRF_TYP Intrf;
	USINT EditMode;	
	LCD_NODE_obj *pNode2Jump;
	UINT Node2JumpID;
	UDINT pNode2Jump_old;
	plcstring Banner[32];
	plcstring Message[NUM_LINE+1][32];
	UINT xCMD;
	USINT IntrfCmdDisable;
	USINT EntrBtnPressReq;
	UINT LineID;
	UINT JumpLineID;
	SerialPortDriver_typ *pDevice;
	unsigned cursPos;
	UDINT FiredEvent;
	UINT curHeadID;
	//UINT curLineID[NUM_LINE];
	UINT curNodeID;
	TON_typ MsgTmr;
	//TON_typ WarnTmr;

	//UINT paramLastNum;
   	//UINT varLastNum ;
	UINT lineNum;
	//UINT segmNum;
	//UINT numZone;
	UINT nodesNum;

	UINT KK_test[NUM_LINE];
	
}LCD_MGR_obj;




 /******************************/
 /*   PENDANT    *****************/
 /** Inputs Outputs mapping **/
 
 /**  On left side*/
#define  BTN_A 	0
#define  BTN_A_MSK 	0x0001

#define  BTN_B	1
#define  BTN_A_MSK 	0x0002

#define	 BTN_C	2
#define  BTN_A_MSK 	0x0004

#define  BTN_D	3
#define  BTN_A_MSK 	0x0008

#define  BTN_E	4
#define  BTN_A_MSK 	0x0010

#define  BTN_F	5
#define  BTN_A_MSK 	0x0020

 
 /* On right side*/
#define BTN_GLB_D		6
#define BTN_GLB_D_MSK 	0x0008

#define BTN_GLB_C		7
#define BTN_GLB_C_MSK 	0x0004


#define LCD_ENTR	12

/***** Multiplex  **********/
/** Multiplex  On right side */ 

/*
#define TEACH_P 	11
#define TEACH_FIN	10
#define SPARE_1		9
#define SPARE_2		8
*/
#define BTN_GLB_A 		11
#define BTN_GLB_A_MSK 	0x0001

#define BTN_GLB_B		10
#define BTN_GLB_B_MSK 	0x0002

#define BTN_GLB_E		9
#define BTN_GLB_E_MSK 	0x0010

#define BTN_GLB_F		8
#define BTN_GLB_F_MSK 	0x0020


 
/** Mode Selector */ 
#define MODE_A_SEL 	8	
#define MODE_B_SEL 	9
#define MODE_C_SEL 	10
#define MODE_D_SEL	11
  
 /*****************/
 /* Outputs Mapping*/
 
#define ENTR_LED	0

#define BTN_A_LED	1
#define BTN_A_LED_MSK 0x0001

#define BTN_B_LED	2
#define BTN_B_LED_MSK 0x0002

#define BTN_C_LED	3
#define BTN_C_LED_MSK 0x0004

#define BTN_D_LED	4
#define BTN_D_LED_MSK 0x0008

#define BTN_E_LED	5
#define BTN_E_LED_MSK 0x0010

#define BTN_F_LED	6
#define BTN_F_LED_MSK 0x0020

 
#define BTN_GLB_D_LED 		7
#define BTN_GLB_D_LED_MSK 0x8

#define BTN_GLB_C_LED 	8
#define BTN_GLB_C_LED_MSK 0x4

 
#define MODE_LED	9
#define MODE_LED_MSK	0x0004

 
#define BTN_GLB_E_LED	10 
#define BTN_GLB_E_LED_MSK	0x10

#define BTN_GLB_B_LED	11
#define BTN_GLB_B_LED_MSK	0x2

#define BTN_GLB_A_LED 	12
#define BTN_GLB_A_LED_MSK	0x1

//old like mine
/*
#define SEL_0_OUT	13
#define SEL_1_OUT	14

#define BTN_GLB_F_LED	15
#define BTN_GLB_F_LED_MSK	0x20
*/

// new

#define BTN_GLB_F_LED	13
#define BTN_GLB_F_LED_MSK	0x0020

#define SEL_0_OUT	14
#define SEL_1_OUT	15

  
/**********************************/
/**** PROCESS SPECIFIC STRUCTURES */

typedef struct PS_Param_typ{

	GenProcess_typ *pPrc;	
	Calib_Param_typ *pCalibPoints;

	INT *pAnal_Output;
	plcbit *pOutput;
		
	float *pStartDly;
	float *pRampUp;
	float *pStopDly;
	float *pRampDwn;
	float *pAmpSP;
	float *pStartAmp;
	float *pEndAmp;
	float *pAmpBoost;

	float *pMode;
	
	float rawCmdMax;
	float AmpCMD_Max;
	
}PS_Param_typ; 


typedef struct AVC_Param_typ{

	StateVectorProxy_typ *pVect;
	unsigned short VectStateNum; /* size of vectors array for process */	  
	GenProcess_typ *pPrc;
	Calib_Param_typ *pCalibPoints;

	float *pTouchVolt;
	float *pTouchTm;
	float *pRetractTm;
	float *pTouchRepeat;
	
	float *pVoltSP;	
	float *pBkgVoltSP;
	float *pVoltSPTimeOut;	
	
	float *pTouchVel;
	float *pToSPVel;

	float *pVoltInit;
	float *pFinalVolt;
	//float *pHoldAVCTm;
	float *pRampDwn;
	float *pHoldTm;
	float *pGoBackTm;

	float *pStartDly;
	float *pStopDly;
	
	float *pRampUp;
	
	float *pMaxVolrError;	

	float *pLimitsFilterTm;

	float *pJogSpeedDirCntrl;	
	float *pLiftSpeedDirCntrl;

	float *pMode;

	
}AVC_Param_typ;

typedef struct OSC_TML_Param_typ{
	
	StateVectorProxy_typ *pVect;
	unsigned short VectStateNum; /* size of vectors array for process */	  
	GenProcess_typ *pPrc;

	TML_typ *pTML;
	float *pStartDly;
	float *pRampUp;
	float *pPrimAmpl;
	float *pInitAmpl;
	float *pFinalAmpl;
	float *pStopDly;
	float *pRampDwn;
	float *pRampUpdate;
	float *pFreq;
	float *pDwell_In;
	float *pDwell_Out;
	DINT  *pCamType;
	float *pJogSpeed;
	float *pJogSpeedDirCntrl;
	
}OSC_TML_Param_typ;


typedef struct GAS_Param_typ {
	
	GenProcess_typ *pPrc;

	plcbit *pSensInput;
	plcbit *pOutput;
	
	float *pStartDly;
	float *pStopDly;
	float *pTmo;
	
}GAS_Param_typ;

typedef struct HW_PS_Param_typ{

	GenProcess_typ *pPrc;
	Calib_Param_typ *pCalibPoints;

	INT *pAnal_Output;
	plcbit *pOutput;
		
	float *pStartDly;
	float *pRampUp;
	float *pStopDly;
	float *pRampDwn;
	float *pAmpSP;
	float *pStartAmp;
	float *pEndAmp;
	float *pAmpBoost;
	float *pRampUpdate;
	float *pVoltSP;

	float rawCmdMax;
	float AmpCMD_Max;
	
}HW_PS_Param_typ; 

typedef struct WIRE_Param_typ {

	StateVectorProxy_typ *pVect;
	unsigned short VectStateNum; /* size of vectors array for process */	  
	GenProcess_typ *pPrc;
	Calib_Param_typ *pCalibPoints;
	
	float *pStartDly;
	float *pRampUp;
	float *pSpeedSp;
	float *pSpeedInit;
	float *pSpeedFinal;
	float *pStopDly;
	float *pRampDwn;
	float *pRampUpdate;

	float *pBoost1SP;
	float *pBoost2SP;
	float *pJogSpeed;
	float *pJogSpeedDirCntrl;

	float *pRetracDly;
	float *pRetracDist;
	float *pRetracSpeed;
	
	float *pCalibTime;
		
	
}WIRE_Param_typ;

typedef struct WIREBLOCK_Param_typ{

	
	StateVectorProxy_typ *pVect;
	unsigned short VectStateNum; /* size of vectors array for process */	  
	GenProcess_typ *pPrc;
	
	float *pJogSpeed;

}WIREBLOCK_Param_typ;


 typedef struct TVLROT_Param_typ {

	StateVectorProxy_typ *pVect;
	unsigned short VectStateNum; /* size of vectors array for process */	  
	GenProcess_typ *pPrc;
	Calib_Param_typ *pCalibPoints;

	float *pInitVel;
	float *pPrimVel;
	float *pFinalVel;
	float *pJog2Stop;
	float *pStartDly;
	float *pRampUp;
	float *pStopDly;
	float *pRampDwn;
	float *pRampUpdate;
	float *pJogSpeedDirCntrl;
	float *pTrackDia;
	float *pVelTolerance;

	float *pRewrapDly;
	float *pRewrapVel;
	 
	float DistPerTick;	
	float TotalRescaleFactor;
				
}TVLROT_Param_typ;



#endif


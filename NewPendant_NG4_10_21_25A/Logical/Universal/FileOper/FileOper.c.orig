/********************************************************************
 * COPYRIGHT -- wsi
 ********************************************************************
 * Program: FileOper
 * File: FileOper.c
 * Author: ckaczkowski
 * Created: January 07, 2014
 ********************************************************************
 * Implementation of program FileOper
 ********************************************************************/

#include <bur/plctypes.h>

#ifdef _DEFAULT_INCLUDES
	#include <AsDefault.h>
#endif


#include <..\..\Universal\SuperDeclaration.h>
#include <..\..\Lib\Statelib.c>

//#include <string.h>

#define MAX_XML_FILE_SIZE 10000000
_LOCAL FILE_RW_typ  *pFileRW ;
//_LOCAL XML_Method_typ *pXMLMethod;

_LOCAL plcstring byData[100];
_LOCAL signed long status_xml;

_LOCAL plcstring _fileName[64];
_LOCAL USINT load_after_save;

_LOCAL plcbit KK_test;

/*
FileOpen_typ   FOpen;
FileClose_typ  FClose;
FileCreate_typ FCreate;
FileRead_typ   FRead;
FileWrite_typ  FWrite;
FileDelete_typ FDelete;
*/

void _Open(FILE_RW_typ *f);
void _Close(FILE_RW_typ *f);
void _Create(FILE_RW_typ *f);
void _Read(FILE_RW_typ *f);
void _Write(FILE_RW_typ *f);
void _Delete(FILE_RW_typ *f);
void _ReadDir(FILE_RW_typ *f);
void _ReadFileInfo(FILE_RW_typ *f);
void _Rename(FILE_RW_typ *f);
void _Copy(FILE_RW_typ *f);



void _INIT FileOperINIT( void )
{
  /* Initialize variables */

  
  strcpy(File_RW.fileName , "Analog Sensor #2.sw");
  strcpy(File_RW.deviceName, "Data");	 
  

  File_RW.Offset = 0;
  
}

void _CYCLIC FileOperCYCLIC( void )
{

	if(KK_test){

		KK_test = 0;
	
		
	}

	//pXMLMethod = (XML_Method_typ*) &XMLFile;
	pFileRW = (FILE_RW_typ*) &File_RW;


	


  if(pFileRW->_int.step == 0){	
  	
	  switch(pFileRW->CMD){


		case F_READ:
					
			pFileRW->Error = 0;
			pFileRW->Done  = 0;	
			pFileRW->_int.step = 1;
			
			
		break;	


		case F_WRITE:

			strcpy(pFileRW->fileName , pFileRW->fileNewName);

			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 10;

		break;	

		case F_DELETE:

			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 70;

		break;	

		case F_READ_DIR:

			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 60;

		break;	

		case F_READ_FILE_INF:

			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 61;

		break;	


		case F_FREE_MEM:

			if(!TMP_free(pFileRW->_int.memlng , (void**) pFileRW->pMem)){
				pFileRW->pMem = 0;
				pFileRW->_int.memlng = 0;
				pFileRW->Len = 0;
				pFileRW->FileLocked = 0;
			}
		
		break;

		case F_READ_FILE_TO_TMP:

			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 20;

		break;	


		
		case F_SAVE_AS_TMP:

			strcpy(pFileRW->fileName , pFileRW->fileNewName);
		
			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 30;

		break;	

		case F_LOAD_CURCFG:

			
			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 40;
			
			/*
			
			strcpy(_fileName , pFileRW->fileName );
			strcpy(pFileRW->fileName , CurCfg.CurProgramName);
			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 50;

			load_after_save = 1;
			*/
				

		break;	

		case F_SAVE_CURCFG:

			strcpy(pFileRW->fileNewName , CurCfg.CurProgramName);
			strcpy(pFileRW->fileName , pFileRW->fileNewName);
			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 50;

		break;	

		case F_SAVE_AS_CURCFG:

			strcpy(pFileRW->fileName , pFileRW->fileNewName);			
			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 50;

		break;	

		case F_COPY:

			strcpy(File_RW.targetDeviceName, File_RW.deviceName);

			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 80;

		break;	


		case F_RENAME:

			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 90;

		break;	

		case F_GET_NEXT_FILE:

			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 100;

		break;	

		case F_SET_NEXT_FILE:

			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 110;

		break;	

		case F_OPEN_ONLY:

			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 120;
			
		break;
		
		case F_CREATE_ONLY:

			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 130;

		break;	

		
		case F_WRITE_ONLY:

			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 140;
			
		break;

		
		case F_CLOSE_ONLY:

			pFileRW->Error = 0;
			pFileRW->Done  = 0;
			pFileRW->_int.step = 150;
			
		break;

		default:

			if(pFileRW->CMD)
				pFileRW->_int.step = 254;  // error

		break;	

		
	  }

  }

		
  switch (pFileRW->_int.step )
  {
  
		case 0: /**** First step ****/

			pFileRW->CMD = 0;
					
		break;


		///////////   F_READ //////////////////////

		case 1: /**** open existing file ****/
			
			_Open(pFileRW);

			/* status (20708 -> File doesn't exist) */
			if (pFileRW->_int.wStatus == 20708)
			{
				pFileRW->_int.step  = 254; // Error
			}
			else if (pFileRW->_int.wStatus == 0){

				/* Null Pointer: Allocate */
				if ( !pFileRW->pMem) {
					pFileRW->_int.wStatus = TMP_alloc(pFileRW->_int.FOpen.filelen , (void**)&pFileRW->pMem);
					pFileRW->_int.memlng = pFileRW->_int.FOpen.filelen;
				}
				/* Pointer Assigned: Clear */
				else if(pFileRW->_int.FOpen.filelen){
					if(!TMP_free(pFileRW->_int.memlng , (void**) pFileRW->pMem)){  
						pFileRW->_int.wStatus = TMP_alloc(pFileRW->_int.FOpen.filelen , (void**)&pFileRW->pMem);   
						pFileRW->_int.memlng = pFileRW->_int.FOpen.filelen;
					}
					else {
						pFileRW->_int.step  = 254;
						break;

					}
						
				}

				
				if ( !pFileRW->_int.wStatus) {
					pFileRW->Len = pFileRW->_int.FOpen.filelen;
					
					pFileRW->_int.step++;;
				}
				else
					pFileRW->_int.step  = 254;

				
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 1;
				
				pFileRW->_int.step  = 254; // Error
				
				if (pFileRW->_int.wStatus == 20799)				
				  pFileRW->_int.wError = FileIoGetSysError();
				
			}
		break;
     
		case 2: /**** Read data from file ****/

			_Read(pFileRW);
			
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
				pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 4;
				
				pFileRW->_int.step  = 254; // Error
				
				if (pFileRW->_int.wStatus == 20799)				
					pFileRW->_int.wError = FileIoGetSysError();
				
			}
		break;	

		
		case 3: /**** Close file ****/

			_Close(pFileRW);
	
		   if (pFileRW->_int.wStatus == 0)
		   {	
		   	  //pFileRW->FileLocked = 1;
		   	  pFileRW->_int.step  = 255; // Success	
			  
		   }
		   else if (pFileRW->_int.wStatus != 65535)
		   {
			  pFileRW->_int.byErrorLevel = 5;
			  pFileRW->_int.step  = 254; // Error	
			  
			  if (pFileRW->_int.wStatus == 20799)			  
				 pFileRW->_int.wError = FileIoGetSysError();
			  
			}				  
		break;

		
		////////   F_WRITE  //////////////////////

		case 10: /**** open existing file ****/
			
			_Open(pFileRW);

			/* status (20708 -> File doesn't exist) */
			if (pFileRW->_int.wStatus == 20708)
			{
				pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus == 0)
			{
				
				pFileRW->_int.step++;
				pFileRW->_int.step++;
				
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 1;
				pFileRW->_int.step  = 254; // Error
			if (pFileRW->_int.wStatus == 20799)
			{
			  pFileRW->_int.wError = FileIoGetSysError();
			}
			}
		break;

		case 11: /**** Create file ****/
			
			_Create(pFileRW);

			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
			 	pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 2;
				pFileRW->_int.step  = 254; // Error
				                    
				if (pFileRW->_int.wStatus == 20799)
				{
					pFileRW->_int.wError = FileIoGetSysError();
				}
			}
			
		break;

		case 12: /**** Write data ****/

			_Write(pFileRW);
			
			if (pFileRW->_int.wStatus == 0)
			{          
			  	pFileRW->_int.step++;  
			  
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 3;
				pFileRW->_int.step  = 254; // Error
				if (pFileRW->_int.wStatus == 20799)
				{
				 	pFileRW->_int.wError = FileIoGetSysError();
				}
			}
		break;

     	
		case 13: /**** Close file ****/

			_Close(pFileRW);
	
		   if (pFileRW->_int.wStatus == 0)
		   {
			  pFileRW->_int.step  = 255; // Success	
		   }
		   else if (pFileRW->_int.wStatus != 65535)
		   {
			  pFileRW->_int.byErrorLevel = 5;
			  pFileRW->_int.step  = 254; // Error
			  if (pFileRW->_int.wStatus == 20799)
			  {
				 pFileRW->_int.wError = FileIoGetSysError();
			  }
			}				  
		break;

	////////////////  F_READ_FILE_TO_TMP //////////////////////// 


		case 20: /**** open existing file ****/
			
			_Open(pFileRW);

			/* status (20708 -> File doesn't exist) */
			if (pFileRW->_int.wStatus == 20708)
			{
				pFileRW->_int.step	= 254; // Error
			}
			else if (pFileRW->_int.wStatus == 0){

				
				if(pFileRW->_int.FOpen.filelen == sizeof(pFileRW->curCfgTemp)){
					
					pFileRW->pMem = (UDINT)&pFileRW->curCfgTemp;
					pFileRW->Offset = 0;
					pFileRW->Len = pFileRW->_int.FOpen.filelen; 				
					pFileRW->_int.step++;

					
				}
				else{
					pFileRW->_int.byErrorLevel = 7;
					pFileRW->_int.step	= 254;
				}	

				
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 1;
				
				pFileRW->_int.step	= 254; // Error
				
				if (pFileRW->_int.wStatus == 20799) 			
				  pFileRW->_int.wError = FileIoGetSysError();
				
			}
		break;
	 
		case 21: /**** Read data from file ****/
			
			_Read(pFileRW);
			
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
				pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 4;
				
				pFileRW->_int.step	= 254; // Error
				
				if (pFileRW->_int.wStatus == 20799) 			
					pFileRW->_int.wError = FileIoGetSysError();
				
			}
		break;	

		
		case 22: /**** Close file ****/

			_Close(pFileRW);
	
		   if (pFileRW->_int.wStatus == 0)
		   {	
			  //pFileRW->FileLocked = 1;
			  pFileRW->_int.step  = 255; // Success 
			  
		   }
		   else if (pFileRW->_int.wStatus != 65535)
		   {
			  pFileRW->_int.byErrorLevel = 5;
			  pFileRW->_int.step  = 254; // Error	
			  
			  if (pFileRW->_int.wStatus == 20799)			  
				 pFileRW->_int.wError = FileIoGetSysError();
			  
			}				  
		break;

		
		////////   F_SAVE_AS_TMP  //////////////////////

		case 30: /**** open existing file ****/
			
			_Open(pFileRW);

			/* status (20708 -> File doesn't exist) */
			if (pFileRW->_int.wStatus == 20708)
			{
				pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus == 0)
			{				
				pFileRW->_int.step += 2; // file exists
							
			}
			else if (pFileRW->_int.wStatus == fiERR_FILE_NOT_FOUND)
			{
				pFileRW->_int.step += 1; // create file 
			}
			 
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 1;
				pFileRW->_int.step	= 254; // Error 
				
			if (pFileRW->_int.wStatus == 20799)
			{
			  pFileRW->_int.wError = FileIoGetSysError();
			}
			}
		break;

		case 31: /**** Create file ****/
			
			_Create(pFileRW);

			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
				pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 2;
				pFileRW->_int.step	= 254; // Error 
									
				if (pFileRW->_int.wStatus == 20799)
				{
					pFileRW->_int.wError = FileIoGetSysError();
				}
			}
			
		break;

		case 32: /**** Write data ****/

			pFileRW->pMem = (UDINT)&pFileRW->curCfgTemp;
			pFileRW->Offset = 0; 
			pFileRW->Len = sizeof(pFileRW->curCfgTemp);

			_Write(pFileRW);
			
			if (pFileRW->_int.wStatus == 0)
			{		   
				pFileRW->_int.step++;  
			  
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 3;
				pFileRW->_int.step	= 254; // Error 
				
				if (pFileRW->_int.wStatus == 20799)
				{
					pFileRW->_int.wError = FileIoGetSysError();
				}
			}
		break;

		
		case 33: /**** Close file ****/

			_Close(pFileRW);

			pFileRW->_int.PathDoneCnt = 0;
	
		   if (pFileRW->_int.wStatus == 0)
		   {	
		   		pFileRW->_int.step	= 255; // Success	

		   }
		   else if (pFileRW->_int.wStatus != 65535)
		   {
			  pFileRW->_int.byErrorLevel = 5;
			  pFileRW->_int.step  = 254; // Error	
			  
			  if (pFileRW->_int.wStatus == 20799)
			  {
				 pFileRW->_int.wError = FileIoGetSysError();
			  }
			}				  
		break;


	/////////////////////////////////

		
			
		///////////   F_READ_CURCFG //////////////////////

		case 40: /**** open existing file ****/
			
			_Open(pFileRW);

			/* status (20708 -> File doesn't exist) */
			if (pFileRW->_int.wStatus == 20708)
			{
				pFileRW->_int.step  = 254; // Error
			}
			else if (pFileRW->_int.wStatus == 0){

				
				if(pFileRW->_int.FOpen.filelen == sizeof(CurCfg)){
					
					pFileRW->pMem = (UDINT)&CurCfg;
					pFileRW->Offset = 0;
					pFileRW->Len = pFileRW->_int.FOpen.filelen;					
					pFileRW->_int.step++;

					
				}
				else{
					pFileRW->_int.byErrorLevel = 7;
					pFileRW->_int.step  = 254;
				}	

				
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 1;
				
				pFileRW->_int.step  = 254; // Error
				
				if (pFileRW->_int.wStatus == 20799)				
				  pFileRW->_int.wError = FileIoGetSysError();
				
			}
		break;
     
		case 41: /**** Read data from file ****/
			
			_Read(pFileRW);
			
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
				strcpy(CurCfg.WeldProgramName , pFileRW->fileName);
				strcpy(CurCfg.CurProgramName , pFileRW->fileName);

				CurCfg.Dirty = 0;

				pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 4;
				
				pFileRW->_int.step  = 254; // Error
				
				if (pFileRW->_int.wStatus == 20799)				
					pFileRW->_int.wError = FileIoGetSysError();
				
			}
		break;	

		
		case 42: /**** Close file ****/

			_Close(pFileRW);
	
		   if (pFileRW->_int.wStatus == 0)
		   {	
		   	  //pFileRW->FileLocked = 1;
		   	  pFileRW->_int.step  = 255; // Success	
			  
		   }
		   else if (pFileRW->_int.wStatus != 65535)
		   {
			  pFileRW->_int.byErrorLevel = 5;
			  pFileRW->_int.step  = 254; // Error	
			  
			  if (pFileRW->_int.wStatus == 20799)			  
				 pFileRW->_int.wError = FileIoGetSysError();
			  
			}				  
		break;

		
		////////   F_SAVE_CURCFG  //////////////////////

		case 50: /**** open existing file ****/
			
			_Open(pFileRW);

			/* status (20708 -> File doesn't exist) */
			if (pFileRW->_int.wStatus == 20708)
			{
				pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus == 0)
			{
				if(pFileRW->CMD == F_SAVE_AS_CURCFG){

					pFileRW->_int.byErrorLevel = 1;
					pFileRW->_int.wError = 0x0001;
					pFileRW->_int.step  = 254; // Error	
				}					
				else					
					pFileRW->_int.step += 2;
							
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 1;
				pFileRW->_int.step  = 254; // Error	
				
			if (pFileRW->_int.wStatus == 20799)
			{
			  pFileRW->_int.wError = FileIoGetSysError();
			}
			}
		break;

		case 51: /**** Create file ****/
			
			_Create(pFileRW);

			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
			 	pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 2;
				pFileRW->_int.step  = 254; // Error	
				                    
				if (pFileRW->_int.wStatus == 20799)
				{
					pFileRW->_int.wError = FileIoGetSysError();
				}
			}
			
		break;

		case 52: /**** Write data ****/

			pFileRW->pMem = (UDINT)&CurCfg;
			pFileRW->Offset = 0; 
			pFileRW->Len = sizeof(CurCfg);

			_Write(pFileRW);
			
			if (pFileRW->_int.wStatus == 0)
			{          
			  	pFileRW->_int.step++;  
			  
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 3;
				pFileRW->_int.step  = 254; // Error	
				
				if (pFileRW->_int.wStatus == 20799)
				{
				 	pFileRW->_int.wError = FileIoGetSysError();
				}
			}
		break;

     	
		case 53: /**** Close file ****/

			_Close(pFileRW);

			pFileRW->_int.PathDoneCnt = 0;
	
		   if (pFileRW->_int.wStatus == 0)
		   {

			   
				CurCfg.Dirty = 0;

				if(load_after_save){

					strcpy(pFileRW->fileName , _fileName  );	
					pFileRW->Error = 0;
					pFileRW->Done  = 0;
					pFileRW->_int.step = 40;

					load_after_save = 0;

				}
				else {
				
					strcpy(CurCfg.CurProgramName , pFileRW->fileName);
				  	pFileRW->_int.step  = 255; // Success	

				}
				
		   }
		   else if (pFileRW->_int.wStatus != 65535)
		   {
			  pFileRW->_int.byErrorLevel = 5;
			  pFileRW->_int.step  = 254; // Error	
			  
			  if (pFileRW->_int.wStatus == 20799)
			  {
				 pFileRW->_int.wError = FileIoGetSysError();
			  }
			}				  
		break;

		//////////////////////////////////////////////////////

		case 60: /**** Get directory info ****/

			_ReadDir(pFileRW);
			
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
		   {

			  if( pFileRW->_int.FDirInfo.filenum > 0){
			  	pFileRW->_int.FFileInfo.entry = 0;			  
			  	pFileRW->_int.step  = 61; // Success	
			  }
			  else
			  	pFileRW->_int.step  = 255; // Success	
		   }
			
			else if (pFileRW->_int.wStatus != 65535)
		   {
			  pFileRW->_int.byErrorLevel = 6;
			  pFileRW->_int.step  = 254; // Error	
			  
			  if (pFileRW->_int.wStatus == 20799)
			  {
				 pFileRW->_int.wError = FileIoGetSysError();
			  }
			}			

		break;


		case 61: /**** Get file info ****/

			_ReadFileInfo(pFileRW);
			
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
		   {
		   	  pFileRW->_int.step  = 255; // Success	
		   }
			
			else if (pFileRW->_int.wStatus != 65535)
		   {
			  pFileRW->_int.byErrorLevel = 6;
			  pFileRW->_int.step  = 254; // Error	
			  
			  if (pFileRW->_int.wStatus == 20799)
			  {
				 pFileRW->_int.wError = FileIoGetSysError();
			  }
			}			

		break;
		


		
		

		
		////////////////////////////////////////////////////////
		// F_DELETE
		
		case 70: /**** Delete file ****/

			_Delete(pFileRW);
			
			/* Verify status */
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
		   {

		   	  pFileRW->_int.step = 60; // get new directory info
		   	 
		   }
			
		   else if (pFileRW->_int.wStatus != 65535)
		   {
			  pFileRW->_int.byErrorLevel = 7;
			  pFileRW->_int.step  = 254; // Error	
			  
			  if (pFileRW->_int.wStatus == 20799)
			  {
				 pFileRW->_int.wError = FileIoGetSysError();
			  }
			}		
		break;

		

		////////////////////////////////////////////////////////
		// F_COPY
		
		case 80: /**** Copy file ****/

			_Copy(pFileRW);
			
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
		   {
		   	  pFileRW->_int.step  = 255; // Success	
		   }
			
			else if (pFileRW->_int.wStatus != 65535)
		   {
			  pFileRW->_int.byErrorLevel = 6;
			  pFileRW->_int.step  = 254; // Error	
			  
			  if (pFileRW->_int.wStatus == 20799)
			  {
				 pFileRW->_int.wError = FileIoGetSysError();
			  }
			}			
		break;

		////////////////////////////////////////////////////////
		// F_RENAME
		
		case 90: /**** Rename  file ****/

			_Rename(pFileRW);
			
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
		   {
		   	  pFileRW->_int.step  = 255; // Success	
		   }
			
			else if (pFileRW->_int.wStatus != 65535)
		   {
			  pFileRW->_int.byErrorLevel = 6;
			  pFileRW->_int.step  = 254; // Error	
			  
			  if (pFileRW->_int.wStatus == 20799)
			  {
				 pFileRW->_int.wError = FileIoGetSysError();
			  }
			}			
		break;


		

		////////////////////////////////////////////////////////
		// F_GET_NEXT_FILE
		
		case 100: /**** open existing file ****/
			
			_Open(pFileRW);

			/* status (20708 -> File doesn't exist) */
			if (pFileRW->_int.wStatus == 20708)
			{
				pFileRW->_int.step	= 254; // Error
			}
			else if (pFileRW->_int.wStatus == 0){

				
				if(pFileRW->_int.FOpen.filelen == sizeof(pFileRW->curCfgTemp)){
					
					pFileRW->pMem = (UDINT)&pFileRW->curCfgTemp;
					pFileRW->Offset = 0;
					pFileRW->Len = pFileRW->_int.FOpen.filelen; 				
					pFileRW->_int.step++;

					
				}
				else{
					pFileRW->_int.byErrorLevel = 7;
					pFileRW->_int.step	= 254;
				}	

				
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 1;
				
				pFileRW->_int.step	= 254; // Error
				
				if (pFileRW->_int.wStatus == 20799) 			
				  pFileRW->_int.wError = FileIoGetSysError();
				
			}
		break;
	 
		case 101: /**** Read data from file ****/

			pFileRW->pMem = pFileRW->FileSchedule.nextFileName;
			pFileRW->Len =  sizeof(pFileRW->curCfgTemp.NextProgramName);
			pFileRW->Offset = (UDINT)pFileRW->curCfgTemp.NextProgramName - (UDINT)&pFileRW->curCfgTemp;			
			
			_Read(pFileRW);
			
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
				pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 4;
				
				pFileRW->_int.step	= 254; // Error
				
				if (pFileRW->_int.wStatus == 20799) 			
					pFileRW->_int.wError = FileIoGetSysError();
				
			}
		break;	


		
		case 102: /**** Read data from file ****/
		
			pFileRW->pMem = &pFileRW->FileSchedule.WeldProgramLinkMode;
			pFileRW->Len =	sizeof(DINT);
			pFileRW->Offset = pFileRW->_int.OffsetToWeldProgramLinkMode;
			
			_Read(pFileRW);
			
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
				pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 4;
				
				pFileRW->_int.step	= 254; // Error
				
				if (pFileRW->_int.wStatus == 20799) 			
					pFileRW->_int.wError = FileIoGetSysError();
				
			}
		break;	


		case 103: /**** Read data from file ****/
		
			pFileRW->pMem = &pFileRW->FileSchedule.WeldProgramRepeat;
			pFileRW->Len =	sizeof(float);
			pFileRW->Offset = pFileRW->_int.OffsetToWeldProgramRepeat;
			
			_Read(pFileRW);
			
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
				pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 4;
				
				pFileRW->_int.step	= 254; // Error
				
				if (pFileRW->_int.wStatus == 20799) 			
					pFileRW->_int.wError = FileIoGetSysError();
				
			}
		break;	

		
		case 104: /**** Close file ****/

			_Close(pFileRW);
	
		   if (pFileRW->_int.wStatus == 0)
		   {	
			  //pFileRW->FileLocked = 1;
			  pFileRW->_int.step  = 255; // Success 
			  
		   }
		   else if (pFileRW->_int.wStatus != 65535)
		   {
			  pFileRW->_int.byErrorLevel = 5;
			  pFileRW->_int.step  = 254; // Error	
			  
			  if (pFileRW->_int.wStatus == 20799)			  
				 pFileRW->_int.wError = FileIoGetSysError();
			  
			}				  
		break;

		////////////////////////////////////////////////////////
		// F_SET_NEXT_FILE
		
		case 110: /**** open existing file ****/
			
			_Open(pFileRW);

			/* status (20708 -> File doesn't exist) */
			if (pFileRW->_int.wStatus == 20708)
			{
				pFileRW->_int.step	= 254; // Error
			}
			else if (pFileRW->_int.wStatus == 0){

				
				if(pFileRW->_int.FOpen.filelen == sizeof(pFileRW->curCfgTemp)){
					
					pFileRW->pMem = (UDINT)&pFileRW->curCfgTemp;
					pFileRW->Offset = 0;
					pFileRW->Len = pFileRW->_int.FOpen.filelen; 				
					pFileRW->_int.step++;

					
				}
				else{
					pFileRW->_int.byErrorLevel = 7;
					pFileRW->_int.step	= 254;
				}	

				
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 1;
				
				pFileRW->_int.step	= 254; // Error
				
				if (pFileRW->_int.wStatus == 20799) 			
				  pFileRW->_int.wError = FileIoGetSysError();
				
			}
		break;
	 
		case 111: /**** Write data to file ****/

			pFileRW->pMem = pFileRW->FileSchedule.nextFileName;
			pFileRW->Len =  sizeof(pFileRW->curCfgTemp.NextProgramName);
			pFileRW->Offset = (UDINT)pFileRW->curCfgTemp.NextProgramName - (UDINT)&pFileRW->curCfgTemp;
			
			_Write(pFileRW);
			
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
				pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 4;
				
				pFileRW->_int.step	= 254; // Error
				
				if (pFileRW->_int.wStatus == 20799) 			
					pFileRW->_int.wError = FileIoGetSysError();
				
			}
		break;	


		case 112: /**** Write data to file ****/
		
			pFileRW->pMem = &pFileRW->FileSchedule.WeldProgramLinkMode;
			pFileRW->Len =	sizeof(DINT);
			pFileRW->Offset = pFileRW->_int.OffsetToWeldProgramLinkMode;
			
			
			_Write(pFileRW);
			
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
				pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 4;
				
				pFileRW->_int.step	= 254; // Error
				
				if (pFileRW->_int.wStatus == 20799) 			
					pFileRW->_int.wError = FileIoGetSysError();
				
			}
		break;	


		case 113: /**** Write data to file ****/
		
			pFileRW->pMem = &pFileRW->FileSchedule.WeldProgramRepeat;
			pFileRW->Len =	sizeof(float);
			pFileRW->Offset = pFileRW->_int.OffsetToWeldProgramRepeat;
						
			_Write(pFileRW);
			
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
				pFileRW->_int.step++;
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 4;
				
				pFileRW->_int.step	= 254; // Error
				
				if (pFileRW->_int.wStatus == 20799) 			
					pFileRW->_int.wError = FileIoGetSysError();
				
			}
		break;	

		
		case 114: /**** Close file ****/

			_Close(pFileRW);
	
		   if (pFileRW->_int.wStatus == 0)
		   {	
			  //pFileRW->FileLocked = 1;
			  pFileRW->_int.step  = 255; // Success 
			  
		   }
		   else if (pFileRW->_int.wStatus != 65535)
		   {
			  pFileRW->_int.byErrorLevel = 5;
			  pFileRW->_int.step  = 254; // Error	
			  
			  if (pFileRW->_int.wStatus == 20799)			  
				 pFileRW->_int.wError = FileIoGetSysError();
			  
			}				  
		break;

		//////////////////////////////////////////////////////

		case 120: /** OPEN ONLY **/
			
			_Open(pFileRW);
				
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
				 pFileRW->_int.step  = 255; // Success 
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 4;
				
				pFileRW->_int.step  = 254; // Error
				
				if (pFileRW->_int.wStatus == 20799)				
					pFileRW->_int.wError = FileIoGetSysError();
				
			}

		break;	

		//////////////////////////////////////////////////////

		case 130: /** Create ONLY **/
			
			_Create(pFileRW);
				
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
				 pFileRW->_int.step  = 255; // Success 
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 4;
				
				pFileRW->_int.step  = 254; // Error
				
				if (pFileRW->_int.wStatus == 20799)				
					pFileRW->_int.wError = FileIoGetSysError();
				
			}

		break;	

		//////////////////////////////////////////////////////

		case 140: /** Write ONLY **/
			
			_Write(pFileRW);
				
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
				 pFileRW->_int.step  = 255; // Success 
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 4;
				
				pFileRW->_int.step  = 254; // Error
				
				if (pFileRW->_int.wStatus == 20799)				
					pFileRW->_int.wError = FileIoGetSysError();
				
			}

		break;	

		
		//////////////////////////////////////////////////////
		
		case 150: /** Close ONLY **/
			
			_Close(pFileRW);
				
			/* Verify status */
			if (pFileRW->_int.wStatus == 0)
			{
				 pFileRW->_int.step  = 255; // Success 
			}
			else if (pFileRW->_int.wStatus != 65535)
			{
				pFileRW->_int.byErrorLevel = 4;
				
				pFileRW->_int.step	= 254; // Error
				
				if (pFileRW->_int.wStatus == 20799) 			
					pFileRW->_int.wError = FileIoGetSysError();
				
			}

		break;	


		

		////////////////////////////////////////////////////////
		// Error
		
		case 254: /**** Error ****/

			
			//Errors(&ErrorMgr, ERROR_FATAL ,ERROR_FILE_RW,0);		


			switch(pFileRW->_int.wStatus){


				case 9999: //ERR_NOTIMPLEMENTED
					strcpy(pFileRW->MsgText , "Err: not Implemented"); break;				

				case 20700: //fiERR_INVALID_PATH 
					strcpy(pFileRW->MsgText , "Err: Invalid Path"); break;

				case 20705: //fiERR_EXIST
					strcpy(pFileRW->MsgText , "Err: File Already Exist"); break;				

				case 20799: //fiERR_SYSTEM
					strcpy(pFileRW->MsgText , "Err: System "); break;

				case 20798://fiERR_DEVICE_MANAGER
					strcpy(pFileRW->MsgText , "Err: Device Manager"); break;

				case 20797: //fiERR_DEVICE_DRIVER
					strcpy(pFileRW->MsgText , "Err: Device Driver"); break;

				case 20725: //fiERR_DIR_ALREADY_EXIST
					strcpy(pFileRW->MsgText , "Err: Directory Already Exist"); break;

				case 20724: //fiERR_DIR_NOT_EMPTY
					strcpy(pFileRW->MsgText , "Err: Directory Not Empty"); break;

				case 20723: //fiERR_DIR_NOT_EXIST
					strcpy(pFileRW->MsgText , "Err: Directory Not Exist"); break;

				case 20722: //fiERR_INVALID_DIRECTORY
					strcpy(pFileRW->MsgText , "Err: Invalid Directory"); break;

				case 20721:	//fiERR_FILE_NOT_OPENED
					strcpy(pFileRW->MsgText , "Err: File Not Opened"); break;

				case 20718:	//fiERR_COM_FILE_IOCTL
					strcpy(pFileRW->MsgText , "Err: File IO Control"); break;

				case 20717: //fiERR_COM_FILE_WRITE
					strcpy(pFileRW->MsgText , "Err: File Write"); break;

				case 20716:	//fiERR_COM_FILE_READ
					strcpy(pFileRW->MsgText , "Err: File Read"); break;

				case 20715:	//fiERR_COM_FILE_CLOSE
					strcpy(pFileRW->MsgText , "Err: File Close"); break;

				case 20714:	//fiERR_COM_FILE_OPEN
					strcpy(pFileRW->MsgText , "Err: File Open"); break;

				case 20708:	//fiERR_FILE_NOT_FOUND
					strcpy( pFileRW->MsgText , "Err: File Not Found"); break;

		
				default: xsprintf(pFileRW->MsgText , "Err.Cmd: %d Code %d" , pFileRW->CMD , pFileRW->_int.wStatus); break;

				

			}

			pFileRW->Error = 1;
			pFileRW->Done  = 1;				
			pFileRW->_int.step  = 0;
			pFileRW->CMD = 0;
		

		break;	

		case 255: /**** Success****/

			pFileRW->Error = 0;
			pFileRW->Done  = 1;				
			pFileRW->_int.step  = 0;

			switch(	pFileRW->CMD){


				
				case F_READ: 				strcpy(pFileRW->MsgText , "Done: F_READ"); break;  
				case F_WRITE: 				strcpy(pFileRW->MsgText , "Done: F_WRITE"); break;  
				case F_DELETE: 				strcpy(pFileRW->MsgText , "Done: F_DELETE"); break;  
				case F_FREE_MEM: 			strcpy(pFileRW->MsgText , "Done: F_FREE_MEM"); break;  
								
				case F_LOAD_CURCFG: 		strcpy(pFileRW->MsgText , "Done: F_LOAD_CURCFG"); break;  
				case F_SAVE_CURCFG: 		strcpy(pFileRW->MsgText , "Done: F_SAVE_CURCFG"); break;  
				case F_SAVE_AS_CURCFG: 		strcpy(pFileRW->MsgText , "Done: F_SAVE_AS_CURCFG"); break;  
								
				case F_RENAME: 				strcpy(pFileRW->MsgText , "Done: F_RENAME"); break;  
				case F_COPY: 				strcpy(pFileRW->MsgText , "Done: F_COPY"); break;  
				case F_GET_NEXT_FILE: 		strcpy(pFileRW->MsgText , "Done: F_GET_NEXT_FILE"); break;  	
				case F_SET_NEXT_FILE: 		strcpy(pFileRW->MsgText , "Done: F_SET_NEXT_FILE"); break;  
				case F_READ_FILE_TO_TMP: 	strcpy(pFileRW->MsgText , "Done: F_READ_FILE_TO_TMP"); break;  
				case F_SAVE_AS_TMP: 		strcpy(pFileRW->MsgText , "Done: F_SAVE_AS_TMP"); break;  
								
				case F_READ_DIR: 			strcpy(pFileRW->MsgText , "Done: F_READ_DIR"); break;  
				case F_READ_FILE_INF: 		strcpy(pFileRW->MsgText , "Done: F_READ_FILE_INF"); break;  


			}
			
			pFileRW->CMD = 0;

		break;

			
  }


}


void _Open(FILE_RW_typ *f)
{
	
	f->_int.FOpen.enable		= 1;
	f->_int.FOpen.pDevice   = (UDINT)f->deviceName;
	f->_int.FOpen.pFile = (UDINT)f->fileName;
	f->_int.FOpen.mode	  = FILE_RW;
	FileOpen(&f->_int.FOpen);

	f->_int.dwIdent = f->_int.FOpen.ident;
	f->_int.wStatus = f->_int.FOpen.status;

	return;
}
void _Close(FILE_RW_typ *f){

	f->_int.FClose.enable	 = 1;
	f->_int.FClose.ident 	 = f->_int.dwIdent;
	FileClose(&f->_int.FClose);

	f->_int.wStatus = f->_int.FClose.status;

	
	return;

		   
}
void _Create(FILE_RW_typ *f){

	
	f->_int.FCreate.enable	= 1;
	f->_int.FCreate.pDevice = (UDINT) f->deviceName;
	f->_int.FCreate.pFile   = (UDINT)f->fileNewName;
	FileCreate(&f->_int.FCreate);

	f->_int.dwIdent = f->_int.FCreate.ident;
	f->_int.wStatus = f->_int.FCreate.status;

	
	return;
	
}
void _Read(FILE_RW_typ *f){

	f->_int.FRead.enable	  = 1;
	f->_int.FRead.ident 	= f->_int.dwIdent;
	f->_int.FRead.offset	= f->Offset;
	f->_int.FRead.pDest 	= f->pMem;
	f->_int.FRead.len		= f->Len;
	/* Call FBK */
	FileRead(&f->_int.FRead);
	/* Get status */
	f->_int.wStatus = f->_int.FRead.status;

	
	return;
			
}
void _Write(FILE_RW_typ *f){

	f->_int.FWrite.enable   = 1;
	f->_int.FWrite.ident    = f->_int.dwIdent;
	f->_int.FWrite.offset   = f->Offset;
	f->_int.FWrite.pSrc	   = f->pMem;
	f->_int.FWrite.len	   = f->Len;

	FileWrite(&f->_int.FWrite);

	f->_int.wStatus = f->_int.FWrite.status;

	
	return;
	

}


void _Rename(FILE_RW_typ *f){

	
	f->_int.FRename.enable 	= 1;
	f->_int.FRename.pDevice 	= (UDINT) f->deviceName;
	f->_int.FRename.pName		=  (UDINT)f->fileName;
	f->_int.FRename.pNewName 	=  (UDINT)f->fileNewName;

	FileRename(&f->_int.FRename);
	
	f->_int.wStatus = f->_int.FRename.status;
	
}
void _Copy(FILE_RW_typ *f){

	f->_int.FCopy.enable 	= 1;
	f->_int.FCopy.pSrcDev	= (UDINT) f->deviceName;
	f->_int.FCopy.pSrc		=  (UDINT)f->fileName;
	
	if(f->targetDeviceName)
		f->_int.FCopy.pDestDev	= (UDINT) f->targetDeviceName;
	else
		f->_int.FCopy.pDestDev = (UDINT) f->deviceName;
	
	f->_int.FCopy.pDest		=  (UDINT)f->fileNewName;
	f->_int.FCopy.option    = FILE_OW_ONCE;
	

	FileCopy(&f->_int.FCopy);
	
	f->_int.wStatus = f->_int.FCopy.status;
}

void _Delete(FILE_RW_typ *f){

	f->_int.FDelete.enable	 = 1;
	f->_int.FDelete.pDevice = (UDINT) f->deviceName;
	f->_int.FDelete.pName	=  (UDINT)f->fileName;
	/* Call FBK */
	FileDelete(&f->_int.FDelete);
	/* Get status */
	f->_int.wStatus = f->_int.FDelete.status;

	
	return;
}

void _ReadDir(FILE_RW_typ *f){

	
	/* Initialize info structure */
	f->_int.FDirInfo.enable	  = 1;
	f->_int.FDirInfo.pDevice = (UDINT) f->deviceName;
	f->_int.FDirInfo.pPath 	= 0;

	/* Call FBK */
	DirInfo(&f->_int.FDirInfo);

	/* Get status */
	f->_int.wStatus = f->_int.FDirInfo.status;

	
	return;
			
}
void _ReadFileInfo(FILE_RW_typ *f){

	/* Initialize read directory structure */
	f->_int.FFileInfo.enable	= 1;
	f->_int.FFileInfo.pDevice = (UDINT) f->deviceName;;
	f->_int.FFileInfo.pPath 	= 0;

	if(f->_int.FFileInfo.entry >= f->_int.FDirInfo.filenum)
		f->_int.FFileInfo.entry = 0;
	
	f->_int.FFileInfo.option	= FILE_FILE;
	f->_int.FFileInfo.pData 	= (UDINT) &f->FileInfo[0];
	f->_int.FFileInfo.data_len	= sizeof (f->FileInfo[0]);

	/* Call FBK */
	DirRead(&f->_int.FFileInfo);

	/* Get status */
	f->_int.wStatus = f->_int.FFileInfo.status;
	return;
			
}





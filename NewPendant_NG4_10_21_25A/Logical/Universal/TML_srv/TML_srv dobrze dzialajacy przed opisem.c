/********************************************************************
 * COPYRIGHT -- wsi
 ********************************************************************
 * Program: TML_rsv
 * File: TML_rsv.c
 * Author: wsi
 * Created: October 19, 2012
 * Updated May 30, 2019 - double message problem fixed
 ********************************************************************
 * Implementation of program TML_rsv
 ********************************************************************/

#include <bur/plctypes.h>

#ifdef _DEFAULT_INCLUDES
	#include <AsDefault.h>
#endif


#include <..\..\Universal\SuperDeclaration.h>
#include <..\..\Lib\Statelib.c>
#include <..\..\Lib\LoggerLib.c>
#include <..\..\Lib\WSI_lib.c>

#include <..\..\Lib\utilityLib\bgdebug.h>

//#define KK_SUPER_TRACE 1

// TML memory mapping

#define TML_Version_adr 0x03B0
#define TML_myInputs_adr 0x03B2
#define TML_var_deltaAPOS_int 0x03B4

// This can be as TML_var_deltaAPOS_int in old TML program
#define TML_set_CmdWord_int 0x21B5
#define TML_set_signFilter_int 0x21B6
// New param
#define TML_set_Param_0_int 0x21B7
#define TML_set_Param_1_int 0x21B8
#define TML_set_Param_2_int 0x21B9
#define TML_set_Param_3_int 0x21BA
#define TML_set_Param_4_int 0x21BB
#define TML_set_Param_5_int 0x21BC
#define TML_set_Param_6_int 0x21BD
#define TML_set_Param_7_int 0x21BE
#define TML_set_MaxError_long 0x25BF

#define TML_set_FFL 0x2023


// For Oscilation BEMF function
#define TML_set_CmdWord_long 		0x25B5
#define TML_set_DwellIn_long 		0x25CB
#define TML_set_DwellOut_long 		0x25CD
#define TML_set_MinPos_long 		0x25D3
#define TML_set_MaxPos_long 		0x25D1
#define TML_set_OSC_Speed_fixed 	0x25CF
#define TML_curStep_adr 			0x0228
/////////////////////////////////////////

// For Oscilation  - path generated by TML drive - new May 2020
#define TML_set_P_Max_long 			0x25B6 
#define TML_set_P_Min_long 			0x25B8
#define TML_set_P_Amplit_long 		0x25BA
#define TML_set_P_Time_long 		0x25BC

#define TML_set_Cmd_Param_long 		0x25C8
#define TML_set_P_DwellIn_long 		0x25CA
#define TML_set_P_DwellOut_long 	0x25CC
#define TML_set_P_Steer_long 		0x25CE 
#define TML_set_P_Jog_long 		0x25D0


#define TML_OSC_Center_adr 			0x03C5
#define TML_OSC_Status_adr 			0x03C7



// For AVC Arc Start Process
#define TML_set_TouchTM_long 		0x25C2
#define TML_set_TouchVel_fixed 		0x25C4
#define TML_set_RetVel_fixed 		0x25C6
#define TML_set_RetTM_long			0x25C8
#define TML_set_ArcTrshld_long		0x25CA

#define TML_AVC_Status_adr 			0x03C1
////////////////////////////////////////////
#define TML_set_SATS 	0x206B 
///////////////////////////////////////////
#define TML_APOS_adr 0x0228

#define TML_myAPOS_adr 0x03C4
#define TML_myAPOS_adr2 0x03D9
#define TML_deltaAPOS_adr 0x03C6
#define TML_deltaAPOS2_adr 0x03C8



#define TML_TPOS_adr 0x02B2
#define TML_EREFV_adr 0x02A9
#define TML_var_I1_adr 0x0366
#define TML_var_I2_adr 0x0367

#define TML_MCR_adr 	0x0309
#define TML_MCR_1_adr 	0x02B0
#define TML_SATS_adr 	0x026B
//#define TML_DIGOUT_STATUS_adr  0x09B8

#define TML_set_SATS 	0x206B 
///////////////////////////////////

#define HEARTBEAT_tm 1.0
#define INIT_tm 	 6.0



_LOCAL float HeartBeatTrig_Level;
_LOCAL DINT Value;
_LOCAL DINT Ret; 
_LOCAL UDINT pointer , memPointer;
_LOCAL char  OneDrivePerTime;

_LOCAL plcbit KK_STOP_TML_Server;
_LOCAL UINT KK_Disable_All_TML ,  KK_Enable_All_TML;


_GLOBAL DINT _deltaAPOS[TML_SERVO_NUM] , _deltaAPOS2[TML_SERVO_NUM];
_GLOBAL UINT TVL_MAP_Indx[TML_SERVO_NUM], TVL_MAP_Indx_New[TML_SERVO_NUM];
_LOCAL float SlipFactor[TML_SERVO_NUM];
_LOCAL UINT Kick_Repeats;

//_LOCAL plcbit MsgInProgress[2];
_LOCAL UINT Max_TML_Process;


_LOCAL UINT TML_Thread , MSG_Thread;

_LOCAL TIME KK_TML_Error_TimeStamp;

_LOCAL plcbit KK_BypassHeartBeat;

#ifdef KK_SUPER_TRACE
_LOCAL UINT KK_Proc_XCMD , KK_Proc_Vect_State , KK_Proc_Vect_XCMD;

_LOCAL UINT KK_VarAddress[2][TML_SERVO_NUM] ,KK_Address_Cnt[2] ;
_LOCAL UINT	KK_BuiltMsg_Cntr , KK_RsvMsg_Cntr , KK_StrangeCode_Cntr;

_LOCAL TON_typ KK_Tmr[2][TML_SERVO_NUM];
_LOCAL UDINT  KK_Max_ET[2][TML_SERVO_NUM];
_LOCAL UDINT  KK_Min_ET_Trig_level;
_LOCAL UINT KK_Ind_BuiltMsg_Cntr[2][32];
_LOCAL UINT KK_Ind_RcvMsg_Cntr[2][32];
_LOCAL UINT KK_Ind_StatusReg_Cntr[2][32];
_LOCAL UINT KK_Ind_UnknwonAdr_Cntr[2][32];
#endif


DINT TML_BuildMessage(UINT AxisID, UINT Channel , UINT OpCode, UINT Address, UDINT OpData1, UDINT OpData2, USINT MessageLength, USINT DataType, TML_MGR_typ* mgr);
DINT TML_InterpretMessage(TML_MGR_typ* mgr);
DINT TML_MGR(TML_MGR_typ* mgr);
DINT CalcUnits(TML_typ* tml);

DINT ReadValue(char** p , DINT *val );

void _INIT TML_rsv_INIT(void)
{
int i , k;
plcstring buf[5];

	KK_Disable_All_TML = 0;

	KK_STOP_TML_Server = 0;

	Kick_Repeats = 1;

	KK_BypassHeartBeat = 0;

	ABS_TVL_Pos = ABS_TVL_Pos;

	Max_TML_Process = 10;

	HeartBeatTrig_Level = 2.5; //2.5;

	KK_TML_PowerON = KK_TML_PowerON;

	//StopStateMachineEvaluation = 1;

#ifdef TML_CMD_LOGS	
	AxisID_filter = 5;	
	memset(&Cmd_Log_Mgr , 0 , sizeof(Cmd_Log_Mgr));
	Cmd_Log_Mgr.AxisID_filter = AxisID_filter;
#endif

#ifdef KK_SUPER_TRACE

	KK_Min_ET_Trig_level = 50;

	for(k = 0 ; k < 2 ; k++){
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){
			KK_Max_ET[k][i] = KK_Min_ET_Trig_level * 10;
			TimerStart(&KK_Tmr[k][i], 5.0);
		}
	}

#endif
	OneDrivePerTime = 0;
	
	VectorStateMach[0].Status = VectorStateMach[0].Status;
	AxisCh[0].AxisID = AxisCh[0].AxisID ;
	TML_MTR_INST[0].Disable = TML_MTR_INST[0].Disable;

	for(i = 0 ; i < TML_MGR_NUM ; i++)	
		TML_mgr[i].pLog = (UDINT)&LogMgr;
	

}


void _CYCLIC TML_rsv(void)
{
UINT i , k , n;
 USINT indx;
USINT status;
TML_Axis_typ* ax;
TML_MGR_typ* mgr;
TML_typ *tml;
UINT ul;


	if(ProjectConfig_Hrdw_ERROR)
		return;

	if(KK_STOP_TML_Server)
		return;


	if(!StopStateMachineEvaluation){
		
		for (i = 0 ; i < VECTORS_NUM ; i++)
			StateVectorSrv(&VectorStateMach[i] , TML_Thread);	

		TML_Thread++;
		if(TML_Thread >= VECTORS_NUM)
			TML_Thread = 0;

		

	}else{
	
		for (i = 0 ; i < VECTORS_NUM ; i++){
			VectorStateMach[i].OutVect.Mode = 0;
			VectorStateMach[i].OutVect.x = 0;
			VectorStateMach[i].OutVect.vel = 0;
			VectorStateMach[i].OutVect.volt = 0;
		}	
	}

	for(i = 0 ; i < TML_SERVO_NUM ; i++)
		TML_MTR_INST[i]._int._posCnt++;

	// Potem wyrzucic
	if(KK_Disable_All_TML){
		KK_Disable_All_TML = 0;
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){

			if(TML_MTR_INST[i].pState)
				TML_MTR_INST[i].Disable = 1;
			

		}
	}
	if(KK_Enable_All_TML){
		KK_Enable_All_TML = 0;
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){

			if(TML_MTR_INST[i].pState)
				TML_MTR_INST[i].Disable = 0;
			

		}
	}
	///////////////////////////////////

	

	// CAN Module Manager
	MSG_Thread++;
	if(MSG_Thread >= TML_SERVO_NUM)
		MSG_Thread = 0;
		
	for(i = 0 ; i < TML_MGR_NUM ; i++)
		TML_MGR(&TML_mgr[i]);


	// Log Errors from TML Servos
	
	if(!TML_MTR_CUT_POWER){
		
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){
		

			if(!TML_MTR_INST[i].Disable && TML_MTR_INST[i].pState ){

				if(!TML_MTR_INST[i].pState->simul){
					
						
					if(TML_MTR_INST[i].pState->FbkWarning != 0.0)
						SetBit(&ErrorMgr.warnings , WARN_AVC_LIMITS +i);				
				 
					if(TML_MTR_INST[i].Error &&  (TML_MTR_INST[i].xCMD != TML_RESTART))	{

						
						if(((TML_MTR_INST[i].xCMD > TML_WAIT_FOR_DOWNLOAD) && (TML_MTR_INST[i].xCMD < TML_DOWNL))
							|| (TML_MTR_INST[i].xCMD == TML_IDLE) || (TML_MTR_INST[i].xCMD == TML_ERROR)){// do not interrupt init and download
							
							if(!TML_STOP_SEND_ERROR){


								LogTxt(&LogMgr, "TML  %d EStop Err. %x " , (DINT)i , (UDINT)TML_MTR_INST[i].ErrorReg);
																
								TML_MTR_CUT_POWER = 1;
#ifdef TML_CMD_LOGS							
								Cmd_Log_Mgr.PauseLogging = 1;
#endif
								KK_TML_Error_TimeStamp = clock_ms();
								
								//Errors(&ErrorMgr ,ERROR_MOTOR , ERROR_TML_1 + i , TML_MTR_INST[i].ErrorReg);

								///////  New errors evaluation  /////////////////////////

								if(TML_MTR_INST[i].ErrorReg > 0){
															
									k = 0;
									for(n=0 ; n < 16 ; n++ ){

										if(k < 4){
											if(GetBit((UINT)TML_MTR_INST[i].ErrorReg , n)){
											
												Errors(&ErrorMgr ,ERROR_MOTOR , ERROR_DRV_01 + k*10+ i , n+1);
												k+=1;

											}
										}					

									}
								
								}			
								/////////////////////////////////////////////////////////
							}
						}					
														
					}	

				}
			}
		
			
		}

	}

}

DINT TML_MGR(TML_MGR_typ* mgr)
{ int i , k , h , n;
 DINT d , t; 
 float f , delta;
 USINT indx;
TML_Axis_typ* ax;
TML_typ *tml;
LOGMGR_obj *logger;
UINT ul;

UINT Tml_Cnt;

	
	TML_InterpretMessage(mgr);

		
	logger = (LOGMGR_obj*)mgr->pLog;

	n = -1;
		
		
	for(k = 0 ; k < 2 ; k++){

		//MsgInProgress[k] = 0;

		if(mgr->hrdw[k].AxisNum > 0){
			
		
/**********************************************/
/*** Check for PT Status changes  & current position **/

			for(i = 0 ; i < mgr->hrdw[k].AxisNum ; i++){ 

				n++;

				if(!mgr->pAxis[k])
					continue;
					//break;
				
				ax = &mgr->pAxis[k][i];				
				if(!ax)
					continue;
					//break;

				if(!mgr->pTML[k])
					continue;
					//break;
				
				tml = &mgr->pTML[k][i];				
				if(!tml)
					continue;
					//break;

				
				
				if(tml->Disable){

					if(tml->pState)
						tml->_int._pos = (DINT)(tml->pState->OutVect.x   * tml->_int.kPos);

				}

							
				
				//////////////////////////////////	
				// Watch for Flags in Messages
				
				// new Error Register
				if(ax->Flag & 0x02){
					
					ax->Flag &= 0xFD;

					tml->ErrorReg = ax->DriveErrorRegister ;
					LogTxt(logger , "TML %s Err: %X  " , tml->Name , tml->ErrorReg);

					
					//tml->ErrorReg = tml->ErrorReg & 0xFFEE; // CAN and Serial Error - store in logbook but mask
		
					if((tml->_int.Init >0) && (tml->ErrorReg > 0)){ 	

						tml->Error = 1;
						
						if(!(ax->DriveStatusRegisterL & 0x8000)){ // Set Error only when Axis is Off 
							tml->_int.Init = 0;
							tml->xCMD = TML_ERROR;
							
						
						}
						
					}

					
				}
				// new Status Register
				if(ax->Flag & 0x0C){
					ax->Flag &= 0xF3;

					tml->StatusReg = (UDINT)ax->DriveStatusRegisterL  + ((UDINT)ax->DriveStatusRegisterH <<16) ; 

					
					if(tml->_cfg.HeartBeat > 0.0)
						TimerStart(&ax->HeartBeat, tml->_cfg.HeartBeat * HeartBeatTrig_Level ); // * 1.25 Just to allow one message lost

					else
						TimerStart(&ax->HeartBeat, HEARTBEAT_tm * 2);
					

					if(tml->pState)
						tml->pState->StatusReg = tml->StatusReg; 

#ifdef KK_SUPER_TRACE

					KK_Ind_StatusReg_Cntr[k][i]++;
#endif					

					
				}
			
				tml->EnableInp = !(tml->ErrorReg & 0x8000);
				/////////////////////////////////
#ifdef KK_SUPER_TRACE

				if(tml->_int.Init > 0){
					
					if((UDINT)ax->HeartBeat.ET > KK_Max_ET[k][i])
						KK_Max_ET[k][i] = (UDINT)ax->HeartBeat.ET;
					
					if(TimerIsTimeOut(&KK_Tmr[k][i])){

						if(KK_Max_ET[k][i] < KK_Min_ET_Trig_level){
							
							if(logger)
								LogTxt(logger , "TML %s Hrbt Min %d  " , tml->Name , KK_Max_ET[k][i]);	

						}
						
						KK_Max_ET[k][i] = 0;
						TimerStart(&KK_Tmr[k][i], 4.0);
					}					
				
				}				
				TimerExecute(&KK_Tmr[k][i]);
#endif		

				//////////////////////////////////
				// Heart beat Expired
				if((TimerIsTimeOut(&ax->HeartBeat) && tml->_int.Init && TimerIsTimeOut(&ax->InitTmr))  && !KK_BypassHeartBeat){

					if(logger)
						LogTxt(logger , "TML %s Hrbt TMO  " , tml->Name );		

					
					TimerStart(&ax->HeartBeat, 3600.0);


					ax->HeartBeat.IN = 0;
					ax->InitTmr.IN = 0;

					ax->HeartBeat.Q = 0;
					ax->InitTmr.Q = 0;

					
					tml->Status = TML_HEARTBEAT_ERR;
					tml->xCMD = TML_ERROR;
					
					tml->Error = 1;
					//tml->ErrorReg |= 0x20; // Feedback Error
					tml->ErrorReg |= 0x1; // Can Bus error
					
					tml->_int.Init = 0;	

					ax->VarAddress = 0;

					//TML_MTR_CUT_POWER = 1;	
				
										
				}	

				switch(ax->VarAddress){

					case TML_myInputs_adr:
	
					
						tml->AnInp[0] = ax->DataLow >> 4; 
						tml->AnInp[1] = ax->DataHigh & 0x0FFF;						

						tml->DigInp[0] = Uint2Bool(ax->DataLow & 0x0001); 
						tml->DigInp[1] = Uint2Bool(ax->DataLow & 0x0002); 
						tml->DigInp[2] = Uint2Bool(ax->DataLow & 0x0004); 
						tml->DigInp[3] = Uint2Bool(ax->DataLow & 0x0008); 

						tml->DigOut_stat[0] = Uint2Bool(ax->DataHigh & 0x1000);  
						tml->DigOut_stat[1] = Uint2Bool(ax->DataHigh & 0x2000);  
						tml->DigOut_stat[2] = Uint2Bool(ax->DataHigh & 0x4000);  

						if(tml->_cfg.actPos2_scale != 0.0){

							if(tml->pState){

								tml->pState->FbkVect.x2 = tml->AnInp[0] * tml->_cfg.actPos2_scale;
								tml->PosFBK = tml->pState->FbkVect.x2;
							}
							
						}
						

					break;


					case TML_OSC_Status_adr:

						
						if(tml->pState)
							tml->pState->FbkVect.Status = ax->DataLow;
						
						
					break;

					case TML_OSC_Center_adr:

						
						if(tml->pState){

							if(tml->_int.kPos != 0.0)
								tml->pState->FbkVect.Center = (float)((DINT)ax->DataLow + ((DINT)ax->DataHigh <<16)) / tml->_int.kPos ;

						}
						
					break;					
					
					case TML_MCR_1_adr:
					case TML_MCR_adr:

						tml->MCRReg = ax->DataLow; 	

						if(tml->pState)
							tml->pState->MCRReg = tml->MCRReg;
				

					break;


					case TML_deltaAPOS_adr:

						_deltaAPOS[n] =  ((DINT)ax->DataLow + ((DINT)ax->DataHigh <<16)) ;


					break;


					
					case TML_deltaAPOS2_adr:
					
						_deltaAPOS2[n] =  ((DINT)ax->DataLow + ((DINT)ax->DataHigh <<16)) ;


						if(_deltaAPOS[n]  != 0)
							SlipFactor[n] = (((float)_deltaAPOS2[n])/((float)_deltaAPOS[n])) * 32.0;


						TVL_MAP_Indx[n]++;
						TVL_MAP_Indx_New[n] = 1;
						


					break;
					
			 		
					// new current position received
					case TML_TPOS_adr:
					case TML_APOS_adr:
					case TML_myAPOS_adr:
					case TML_myAPOS_adr2:

						if(tml->Status != TML_STAT_PT_MODE_OK){
							
							tml->_int.cnt = tml->_int._posCnt;
							tml->_int._posCnt = 0;

						}
						
			
						if(tml->_int.Init){	
							
							switch(tml->_cfg.absFbk){


								case 1:
								case 2:	
								case 3:	

									ax->curPos = ((DINT)ax->DataLow + ((DINT)ax->DataHigh <<16) + ax->_lastPos) ;

								break;	

								default:

									ax->curPos = ((DINT)ax->DataLow + ((DINT)ax->DataHigh <<16)) ;
															
								break;


							}								
							
							if(tml->_int.kPos != 0.0){

								if(tml->_cfg.actPos2_scale == 0.0){
									
									tml->PosFBK = (float)ax->curPos / tml->_int.kPos; 								
									delta = tml->PosFBK - ((float)ax->_curPos / tml->_int.kPos);

								}
								ax->_curPos = ax->curPos ;
							}
							else{
								tml->PosFBK = 0;
								delta = 0;
							}

							if(tml->pState){

								tml->pState->actPosDINT = ax->curPos;
								tml->pState->FbkVect.x = (float)ax->curPos / tml->_int.kPos; 					
								tml->pState->FbkVect.vel = delta * 10.0; // 100 ms period
														
							}	

						}
			
					break;
				
					case TML_Version_adr:

						ax->Version = (UDINT)ax->DataLow + ((UDINT)ax->DataHigh <<16);	
						
						
					break;

					case TML_SATS_adr:

						ax->SATS = (UINT)ax->DataLow;	
						
						
					break;
				
					case TML_var_I1_adr:

						//ax->VarAddress = 0; 
						ax->pointer = ax->DataLow;

					break;

					case TML_var_I2_adr:

						if((ax->ProgramVersion == 0xFFFFFFFF)){

							ax->ProgramVersion = 0;
							
							ax->ProgramVersion += ((UDINT)(ax->DataLow & 0xFF00) >> 8);     
							ax->ProgramVersion += ((UDINT)(ax->DataLow & 0x00FF)<< 8) ;   
							ax->ProgramVersion = ax->ProgramVersion << 16;
													
						}	
						else{
							
							ax->ProgramVersion += ((UDINT)(ax->DataLow & 0xFF00) >> 8);     
							ax->ProgramVersion += ((UDINT)(ax->DataLow & 0x00FF)<< 8) ;  
						}
						

					break;
						
					case TML_var_deltaAPOS_int: // delta APOS in 10ms
					
						memcpy(&ax->deltaAPOS , &ax->DataLow , 2);

					break;

					
					case TML_AVC_Status_adr: // 
					
				
						memcpy(&tml->pState->curStep , &ax->DataLow , 2);
					

					break;

					default:

#ifdef KK_SUPER_TRACE

						if(ax->VarAddress > 0)
							KK_Ind_UnknwonAdr_Cntr[k][i]++;
#endif
						

					break;

				}

				if(ax->VarAddress > 0){
					
#ifdef KK_SUPER_TRACE					
						KK_VarAddress[k][i] = ax->VarAddress;
						KK_Address_Cnt[k]++;
#endif
						
						ax->VarAddress = 0;
						
						if(tml->_cfg.HeartBeat > 0.0)
							TimerStart(&ax->HeartBeat, tml->_cfg.HeartBeat * HeartBeatTrig_Level ); // * 1.25 Just to allow one message lost

						else
							TimerStart(&ax->HeartBeat, HEARTBEAT_tm * 2);

				}

				
				if(tml->pState){

					if(tml->pState->simul)
						tml->pState->FbkVect.Mode = tml->pState->Mode;
					
				}

				// Clear Flags and Start timer for initialization	
				if(tml->xCMD == TML_RESTART){				
						
					tml->Status = TML_STAT_INIT;
					
					ax->Version = 0;
					tml->Error = 0;
					tml->ErrorReg = 0;
					tml->_int.Init = 0;	
					
					ax->HeartBeat.IN = 0;
					ax->HeartBeat.Q = 0;
		
					TimerStart(&ax->InitTmr ,INIT_tm);
					
					tml->xCMD ++;

				}	
				
				TimerExecute(&ax->HeartBeat);
				TimerExecute(&ax->InitTmr);
				
			
			}

/// *******  END of Checking 	

					

/************************/
//	Send Messages

		
			Tml_Cnt = 0;
			if(mgr->hrdw[k].TXCount == mgr->hrdw[k].TXCountReadBack){

				PROCESS_NEXT_TML:

				Tml_Cnt++;
				if(Tml_Cnt > Max_TML_Process)
					goto BUSY_USE_NEXT_CHANNEL;
		
				
				mgr->hrdw[k]._indx ++;
				
				if(mgr->hrdw[k]._indx >= mgr->hrdw[k].AxisNum)
					mgr->hrdw[k]._indx = 0;

				i = mgr->hrdw[k]._indx;

				if(!mgr->pAxis[k])
					return;
				
				ax = &mgr->pAxis[k][i];
				if(!ax)
					return; 

				if(!mgr->pTML[k])
					break;
			
				tml = &mgr->pTML[k][i];

				if(!tml)
					break;
			
				//tml->_int.msgProcess = 0;

				
				if(!tml->pState)					
					goto PROCESS_NEXT_TML;


				//////////////  ******************  ////////////////////////////
				////////////   MAIN XCMD execution on state machine

				if(mgr->hrdw[k].TXCount != mgr->hrdw[k].TXCountReadBack)	
					goto BUSY_USE_NEXT_CHANNEL;	
				
			
				switch(tml->xCMD){
					
					case TML_IDLE: // Idle

						
						break;


					case TML_RESET_ONLY_CMD:							


						tml->_int.Init = 0;						

						TML_BuildMessage(ax->AxisID , k , 0x0402, 0 , 0 ,0 , 0 , 2 , mgr); // Reset Drive

						tml->xCMD  = 0;	


						break;

					
					case TML_RESTART + 1: // Reset Drive

						
						tml->_int.Init = 0;
						
						switch(tml->_cfg.absFbk){


						case 1: // store last known position before restart

						ax->_lastPos = ax->curPos;  

						break;	


						case 2:// take last store postion at init

						ax->_lastPos = tml->_cfg.absLastPos ;  
						tml->_cfg.absFbk = 1;
								
						break;	

						case 3:// take last store postion at init

						if(tml->_cfg.pAbsLastPos)
						ax->_lastPos = *tml->_cfg.pAbsLastPos ;  
							
						break;	


						default:

						ax->_lastPos = 0;


						break;


						}		


						TML_BuildMessage(ax->AxisID , k , 0x2327, 0 , 161 ,0 , 2 , 1 , mgr); // MasterID=161
						
						tml->xCMD ++;

						break;					

					case TML_RESTART + 2: //

						CalcUnits(tml);

						if(tml->_cfg.Appl_ID_adr == 0) // Standard address
							TML_BuildMessage(ax->AxisID , k , 0x2166, 0 , 0x4FCF , 0 , 2 , 1 , mgr); // var_i1=0x4FCF
						else	
							TML_BuildMessage(ax->AxisID , k , 0x2166, 0 , tml->_cfg.Appl_ID_adr  , 0 , 2 , 1 , mgr); 
							
						tml->xCMD ++;
						

						break;	

					case TML_RESTART + 3: // 
					
						TML_BuildMessage(ax->AxisID , k , 0x9108, 0 , 0x03670366 , 0 , 4 , 2 , mgr); // var_i2=(var_I1+),spi

						ax->ProgramVersion = 0xFFFFFFFF;
						tml->xCMD ++;

						break;


					case TML_RESTART + 4: //						
				
						d = 0x036700A1 ;
						
						TML_BuildMessage(ax->AxisID , k , 0xB204, 0 , d , 0 , 4 , 2 , mgr); // ??var_i2
						
						tml->xCMD ++;

						break;


					case TML_RESTART + 5: //							
											
						TML_BuildMessage(ax->AxisID , k , 0x9108, 0 , 0x03670366 , 0 , 4 , 2 , mgr); // var_i2=(var_I1+),spi

						tml->xCMD ++;

						break;


					case TML_RESTART + 6: // 							
					
						d = 0x036700A1 ;
						TML_BuildMessage(ax->AxisID , k , 0xB204, 0 , d , 0 , 4 , 2 , mgr); // ??var_i2

						TimerStart(&ax->InitTmr , 1.0);
						
						tml->xCMD ++;

						break;


					case TML_RESTART + 7: // Wait for Program Version							


						if(ax->InitTmr.ET < 1000)
							break;							
						
						else if(((ax->ProgramVersion &  0xFFFF0000) != 0xFFFF0000)
						&& ((ax->ProgramVersion &  0x0000FFFF) != 0x0000FFFF)){
							
							ax->HeartBeat.IN = 0;
						
							if((ax->ProgramVersion == tml->ProgramVersion) || KK_DoNotChangeTMLProgram){
								TML_BuildMessage(ax->AxisID , k , 0x0402, 0 , 0 ,0 , 0 , 2 , mgr); // Reset Drive
								tml->xCMD ++;
							}
							else{

								OneDrivePerTime = 1;
								tml->xCMD = TML_WAIT_FOR_DOWNLOAD;
								
							}	

						}						
						else if(TimerIsTimeOut(&ax->InitTmr)){	

							//if(ax->ProgramVersion != 0xFFFFFFFF){

							tml->_int.restartCnt++;
							tml->xCMD = TML_RESTART;										

							//}

						}	
							
							
						break;


					case TML_RESTART + 8: // Set SRH_Mask
					
						if(ax->Version > 0 ){
							TML_BuildMessage(ax->AxisID , k , 0x2363 , 0 , 0xD3C1 ,0 , 2 , 1 , mgr); // Set SRH_MASK=0xD3C1 / 2363 D3C1 							
							tml->xCMD ++;
						}
					
						break;	


					case TML_RESTART + 9: // Set heartbeat

						if(tml->_cfg.HeartBeat > 0.0){
							d = (DINT)(tml->_cfg.HeartBeat * 2000.0/4.0);
							TML_BuildMessage(ax->AxisID , k , TML_set_Param_0_int+7 , 0  , d , 0 , 2, 1 , mgr); // PARAM_h

						}							
						
						tml->xCMD ++;
						
						
						break;		

					case TML_RESTART + 10: // Get SRL or set Home Value

						if(tml->_cfg.absFbk == 10){

							if(tml->_cfg.pAbsLastPos)
								d = (*tml->_cfg.pAbsLastPos);	
							else
								d = 0;
						
							TML_BuildMessage(ax->AxisID , k , TML_set_Cmd_Param_long , 0  , d , 0 , 4, 2 , mgr); // PARAM_x // Set Cmd_Param for homing							

						}
						else	
							TML_BuildMessage(ax->AxisID , k , 0xB204 , 0 , 0x090E ,0 , 4 , 2 , mgr); // Read SRL
							
						tml->xCMD ++;
						
						break;	

					case TML_RESTART + 11: // Get SRH

						if(tml->_cfg.absFbk == 10){
							d = (-1);						
							TML_BuildMessage(ax->AxisID , k , TML_set_CmdWord_int , 0  , d , 0 , 2, 1 , mgr); // PARAM_x - Set Home (-1)
						}
						else
							TML_BuildMessage(ax->AxisID , k , 0xB204 , 0 , 0x090F ,0 , 4 , 2 , mgr); // Read SRH

						TimerStart(&ax->InitTmr , 0.5);

						tml->xCMD ++;
						/*
						
						tml->Status = TML_STAT_READY;

						if(tml->_cfg.kppMax != 0){

							TimerStart(&ax->InitTmr , 2.0);
							tml->xCMD ++;

						}	
						else{	
							
							tml->xCMD = TML_IDLE;

							if(tml->_cfg.HeartBeat > 0.0)
								TimerStart(&ax->HeartBeat, tml->_cfg.HeartBeat * 3.0);

							else
								TimerStart(&ax->HeartBeat, HEARTBEAT_tm * 3);

							TimerStart(&ax->InitTmr , 1.0);


							tml->_int.Init = 1;
							tml->_int.restartCnt = 0;
							
							if(logger)
								LogTxt(logger , "TML %s Restarted" , tml->Name);

						}
						*/
						
						break;					


					case TML_RESTART + 12: // Set KPP

						if(!TimerIsTimeOut(&ax->InitTmr))
							break;

						tml->Status = TML_STAT_READY;

						if(tml->_cfg.kppMax != 0){

							if(tml->_cfg.kpp > 32767)
								tml->_cfg.kpp = 32767;							
							else if(tml->_cfg.kpp < -32767)
								tml->_cfg.kpp = -32767;					

							if(tml->_cfg.kppMax != 0)
								TML_BuildMessage(ax->AxisID , k , 0x205E , 0  , tml->_cfg.kpp , 0 , 2, 1 , mgr); // KPP=
													
							tml->xCMD ++;

						}	
						else{	
							
							tml->xCMD = TML_IDLE;

							if(tml->_cfg.HeartBeat > 0.0)
								TimerStart(&ax->HeartBeat, tml->_cfg.HeartBeat * 3.0);

							else
								TimerStart(&ax->HeartBeat, HEARTBEAT_tm * 1);

							TimerStart(&ax->InitTmr , 1.0);


							tml->_int.Init = 1;
							tml->_int.restartCnt = 0;
							
							if(logger)
								LogTxt(logger , "TML %s Restarted" , tml->Name);

						}

						/*
						if(tml->_cfg.kpp > 32767)
							tml->_cfg.kpp = 32767;							
						else if(tml->_cfg.kpp < -32767)
							tml->_cfg.kpp = -32767;					

						if(tml->_cfg.kppMax != 0)
							TML_BuildMessage(ax->AxisID , k , 0x205E , 0  , tml->_cfg.kpp , 0 , 2, 1 , mgr); // KPP=
												
						tml->xCMD ++;
						*/
						
						break;	

					case TML_RESTART + 13: // Set KIP


						if(tml->_cfg.kip > 32767)
							tml->_cfg.kip = 32767;
						else if(tml->_cfg.kip < -32767)
							tml->_cfg.kip = -32767;

						if(tml->_cfg.kipMax != 0)																		
							TML_BuildMessage(ax->AxisID , k , 0x2060 , 0  , tml->_cfg.kip , 0 , 2, 1 , mgr); // KIP=

						if(tml->_cfg.HeartBeat > 0.0)
							TimerStart(&ax->HeartBeat, tml->_cfg.HeartBeat * 3.0 );
						else
							TimerStart(&ax->HeartBeat, HEARTBEAT_tm * 3);

						TimerStart(&ax->InitTmr , 1.0);

													
						tml->_int.Init = 1;
						tml->_int.restartCnt = 0;
						
						if(logger)
							LogTxt(logger , "TML %s Restarted" , tml->Name);
						
						tml->xCMD = TML_IDLE;
						
						break;	

					

					/////////////////////////////////////////////////////////////
					
					case TML_OSC_CUST_CMD:

						d = tml->pState->Param[0];						
						TML_BuildMessage(ax->AxisID , k , TML_set_DwellIn_long , 0  , d , 0 , 4, 2 , mgr); // PARAM_x
						tml->xCMD ++;


						break;	

					case TML_OSC_CUST_CMD+1:

						d = tml->pState->Param[1];						
						TML_BuildMessage(ax->AxisID , k , TML_set_DwellOut_long , 0  , d , 0 , 4, 2 , mgr); // PARAM_x
						tml->xCMD ++;


						break;	


					case TML_OSC_CUST_CMD+2:						

						d = (DINT) (tml->pState->fParam[0] * 65535.0);						
						TML_BuildMessage(ax->AxisID , k , TML_set_OSC_Speed_fixed, 0  , d , 0 , 4, 2 , mgr); // PARAM_x
						tml->xCMD ++;
											
						break;

					case TML_OSC_CUST_CMD+3:

						d = tml->pState->Param[2];						
						TML_BuildMessage(ax->AxisID , k , TML_set_MinPos_long, 0  , d , 0 , 4, 2 , mgr); // PARAM_x
						tml->xCMD ++;


						break;	


					case TML_OSC_CUST_CMD+4:

						d = tml->pState->Param[3];						
						TML_BuildMessage(ax->AxisID , k , TML_set_MaxPos_long, 0  , d , 0 , 4, 2 , mgr); // PARAM_x
						tml->xCMD ++;


						break;	

					case TML_OSC_CUST_CMD+5:

						d = (DINT)tml->pState->cmdWord;						
						TML_BuildMessage(ax->AxisID , k , TML_set_CmdWord_long, 0  , d , 0 , 4, 4 , mgr); // PARAM_x
						tml->xCMD = TML_IDLE;


						break;	
					

					//////////////////////////////////////////////////////////////////////////////////////
					case TML_CUST_MODE: //
						
						d = (DINT) tml->pState->fParam[0];						
						TML_BuildMessage(ax->AxisID , k , TML_set_Param_0_int , 0  , d , 0 , 2, 1 , mgr); // PARAM_x
						tml->xCMD ++;

						break;
					
					case TML_CUST_MODE+1: // 

						d = (DINT) tml->pState->fParam[1];						
						TML_BuildMessage(ax->AxisID , k , TML_set_Param_1_int , 0  , d , 0 , 2, 1 , mgr); // PARAM_x
						tml->xCMD ++;	
						
					
						break;

					case TML_CUST_MODE+2: //

						d = (DINT) tml->pState->fParam[2];						
						TML_BuildMessage(ax->AxisID , k , TML_set_Param_2_int , 0  , d , 0 , 2, 1 , mgr); // PARAM_x
						tml->xCMD ++;
											
						break;

					case TML_CUST_MODE+3: //

						d = (DINT) tml->pState->fParam[3];						
						TML_BuildMessage(ax->AxisID , k , TML_set_Param_3_int , 0  , d , 0 , 2, 1 , mgr); // PARAM_x
						tml->xCMD ++;
											
						break;

					case TML_CUST_MODE+4: //

						d = (DINT) tml->pState->fParam[4];						
						TML_BuildMessage(ax->AxisID , k , TML_set_Param_4_int , 0  , d , 0 , 2, 1 , mgr); // PARAM_x
						tml->xCMD ++;
											
						break;

					case TML_CUST_MODE+5: //

						d = (DINT) tml->pState->fParam[5];						
						TML_BuildMessage(ax->AxisID , k , TML_set_Param_5_int , 0  , d , 0 , 2, 1 , mgr); // PARAM_x
						tml->xCMD ++;
											
						break;
						
					case TML_CUST_MODE+6: //

						d = (DINT) tml->pState->fParam[6];						
						TML_BuildMessage(ax->AxisID , k , TML_set_Param_6_int , 0  , d , 0 , 2, 1 , mgr); // PARAM_x
						tml->xCMD ++;
											
						break;
							
					case TML_CUST_MODE+7: //

						d = (DINT) tml->pState->fParam[7];						
						TML_BuildMessage(ax->AxisID , k , TML_set_Param_7_int , 0  , d , 0 , 2, 1 , mgr); // PARAM_x
						tml->xCMD ++;
											
						break;

					case TML_CUST_MODE+8: //

						d = (DINT) tml->pState->cmdWord;						
						TML_BuildMessage(ax->AxisID , k , TML_set_CmdWord_int , 0  , d , 0 , 2, 1 , mgr); // PARAM_x
						tml->xCMD ++;
											
						break;

					case TML_CUST_MODE+9: //

						tml->Status = TML_STAT_CUSTOM_OK;

						tml->xCMD = TML_IDLE;
											
						break;



					///////////////////////////////////////////////////////////////////////////////////////

					case TML_SET_P_Max :

						d = (DINT)(tml->pState->fParam[V_fParam_Max] * tml->_int.kPos);
						TML_BuildMessage(ax->AxisID , k , TML_set_P_Max_long, 0 , d , 0 , 4 , 2 , mgr); 
												
						tml->xCMD = TML_SET_P_Min;
						
						break;	
						
					case TML_SET_P_Min :

						d = (DINT)(tml->pState->fParam[V_fParam_Min]  * tml->_int.kPos);
						TML_BuildMessage(ax->AxisID , k , TML_set_P_Min_long, 0 , d , 0 , 4 , 2 , mgr); 
												
						tml->xCMD = TML_SET_P_Steer;
						
						break;	

					case TML_SET_P_Steer : 
						
						d = (DINT)(tml->pState->fParam[V_fParam_Steer] * tml->_int.kPos);
						TML_BuildMessage(ax->AxisID , k , TML_set_P_Steer_long, 0 , d , 0 , 4 , 2 , mgr); 
												
						tml->xCMD = TML_SET_P_Jog;
						
					break;					
					
					case TML_SET_P_Jog :

						d = (DINT) (tml->pState->fParam[V_fParam_Jog] * tml->_int.kVel * 65535.0);						
						TML_BuildMessage(ax->AxisID , k , TML_set_P_Jog_long, 0  , d , 0 , 4, 2 , mgr); 
						
						tml->xCMD = TML_SET_P_Time;
											
					break;	
						
					case TML_SET_P_Time :

						d = tml->pState->Param[V_Param_Time];
						TML_BuildMessage(ax->AxisID , k , TML_set_P_Time_long, 0 , d , 0 , 4 , 2 , mgr); 
												
						tml->xCMD = TML_SET_P_DwellIn;
						
						break;	
					
					case TML_SET_P_DwellIn :

						d = tml->pState->Param[V_Param_DwellIn];
						TML_BuildMessage(ax->AxisID , k , TML_set_P_DwellIn_long, 0 , d , 0 , 4 , 2 , mgr); 
												
						tml->xCMD = TML_SET_P_DwellOut;
						break;		
				

					case TML_SET_P_DwellOut :

						d = tml->pState->Param[V_Param_DwellOut];
						TML_BuildMessage(ax->AxisID , k , TML_set_P_DwellOut_long, 0 , d , 0 , 4 , 2 , mgr); 
												
						tml->xCMD = TML_SET_P_Amplit;

					break;	


					case TML_SET_P_Amplit :

						d = (DINT)(tml->pState->fParam[V_fParam_Amplit] * tml->_int.kPos);
						TML_BuildMessage(ax->AxisID , k , TML_set_P_Amplit_long, 0 , d , 0 , 4 , 2 , mgr); 
												
						tml->xCMD = TML_IDLE;
						
					break;


					case TML_SET_Cmd_Word :

						d = (DINT) tml->pState->cmdWord;							
						TML_BuildMessage(ax->AxisID , k , TML_set_CmdWord_int, 0  , d , 0 , 2, 1 , mgr); // 
												
						tml->xCMD = TML_IDLE;
						
					break;			

									
					case TML_SET_Cmd_Param :

						d = tml->pState->Param[V_Param_Cmd_Param];
						TML_BuildMessage(ax->AxisID , k , TML_set_Cmd_Param_long, 0 , d , 0 , 4 , 2 , mgr); 
												
						tml->xCMD = TML_IDLE;
						
					break;


					case TML_SET_Home :
					
						d = (DINT)(tml->pState->fParam[V_fParam_HomePos] * tml->_int.kPos);
						TML_BuildMessage(ax->AxisID , k , TML_set_Cmd_Param_long, 0 , d , 0 , 4 , 2 , mgr); 
												
						tml->xCMD = TML_SET_Home2;
						
					break;
					
					
					case TML_SET_Home2 :

						d = (-1);						
						TML_BuildMessage(ax->AxisID , k , TML_set_CmdWord_int , 0  , d , 0 , 2, 1 , mgr); // PARAM_x - Set Home (-1)

						tml->xCMD = TML_IDLE;

					break;				

					//////////////////////////////////////////////////////////////////////////////////////
					case TML_HOLD_MODE: //					

						TML_BuildMessage(ax->AxisID , k , 0x01C4, 0 , 0 ,0 , 0 , 0 , mgr); // STOP
						tml->xCMD ++;

					break;
					
					case TML_HOLD_MODE+1: // 
						
						TML_BuildMessage(ax->AxisID , k , 0x0510 , 0 , 0 ,0 , 0 , 0 , mgr); // EINT
						tml->xCMD ++;			
						
					
					break;

					case TML_HOLD_MODE+2: //
																		
						TML_BuildMessage(ax->AxisID , k , 0x0102, 0 , 0 ,0 , 0 , 0 , mgr); // AXISON

						if(tml->Status > 0)
							tml->Status = TML_STAT_HOLD_OK;
							
						tml->xCMD = TML_IDLE;
											
					break;
						

					//////////////////////////////////////////////////////////////////////////////////////

					case TML_POS_MODE: // 						

						TML_BuildMessage(ax->AxisID , k , 0x0102, 0 , 0 ,0 , 0 , 0 , mgr); // AXISON
						tml->xCMD++;

					break;	

					
					case TML_POS_MODE+1: // 
						
						tml->Status = TML_STAT_POS_MODE_INIT;
						
						d = ax->curPos; // 
						d = 1234;
						tml->_int._pos = d;
						TML_BuildMessage(ax->AxisID , k , 0x24A8, 0 , d , 0 , 4 , 2 , mgr); // EREFP= current Position
						tml->xCMD++;
					
												
					break;						

					case TML_POS_MODE+2: // 
						
						TML_BuildMessage(ax->AxisID , k , 0x5909, 0 , 0x0000FF3F , 0 , 4 , 2 , mgr); // EXTREF 0
						tml->xCMD++;

										
					break;
					

					case TML_POS_MODE+3: // 						

						TML_BuildMessage(ax->AxisID , k , 0x5909, 0 , 0x8700BFC0 , 0 , 4, 2 , mgr); // MODE PE
						tml->xCMD++;
					

					break;					


					case TML_POS_MODE+4: // 

						if(tml->pState->maxVel > tml->_cfg.maxVel)
							f = tml->_cfg.maxVel ;
						else if(tml->pState->maxVel == 0.0)
							f = tml->_cfg.maxVel ;
						else
							f = tml->pState->maxVel;
												
						d = (DINT)(f * tml->_int.kVel *  65535.0); 
						TML_BuildMessage(ax->AxisID , k , 0x24A0, 0 , d , 0 , 4 , 2 , mgr); // CSPD=
												
						tml->xCMD++;						
									
					break;

					case TML_POS_MODE+5: // 
						
						TML_BuildMessage(ax->AxisID , k , 0x5A57, 0 , 0x0004FFFF  , 0 , 4 , 2 , mgr); // UPGRADE2 = 1
						tml->xCMD++;
					
					
					break;				
				

					case TML_POS_MODE+6: // 					
			

						TML_BuildMessage(ax->AxisID , k , 0x0108, 0 , 0 , 0 , 0 , 2 , mgr); // UPD
						
						tml->xCMD++;
							
									
					break;
					
					case TML_POS_MODE+7: // 							
			
						tml->_int._floatPos = 0.0;
					
						tml->Status = TML_STAT_POS_MODE_OK;						
						tml->pState->FbkVect.Mode = vectSt_Mode_Pos;
						tml->_int._pos = 0x7FFFFFFF;
						tml->xCMD = TML_IDLE;
														
					break;
					

					//////////////////////////////////////////////////////////////////////////////////////

					case TML_VEL_MODE: // 

						//TML_BuildMessage(ax->AxisID , k , 0x0002, 0 , 0 ,0 , 0 , 0 , mgr); // AXISOFF
						tml->xCMD++;

					break;	

					case TML_VEL_MODE +1: // 

						tml->Status = TML_STAT_VEL_MODE_INIT;

						//d = (DINT)(tml->pState->OutVect.vel * tml->_int.kVel * 65535.0 ); // 
						////tml->_int._vel = tml->pState->OutVect.vel;
						d = 0;
						tml->_int._vel = 0.0;
						TML_BuildMessage(ax->AxisID , k , 0x24A8, 0 , d , 0 , 4 , 2 , mgr); // EREF=
						tml->xCMD++;
					
									
					break;

					case TML_VEL_MODE + 2: // 
						
						tml->xCMD++;

					break;

					case TML_VEL_MODE + 3: // 

						TML_BuildMessage(ax->AxisID , k , 0x5909, 0 , 0x8300B3C0 , 0 , 4 , 2 , mgr); // MODE SE
						tml->xCMD++;
					

					break;

					case TML_VEL_MODE + 4: // 

						if(tml->pState->maxAcc > tml->_cfg.maxAcc)
							f = tml->_cfg.maxAcc ;
						else if(tml->pState->maxAcc == 0.0)
							f = tml->_cfg.maxAcc;
						else
							f = tml->pState->maxAcc;

						d = (DINT)(f * tml->_int.kAcc *  65535.0); 						
						TML_BuildMessage(ax->AxisID , k , 0x24A2, 0 , d , 0 , 4 , 2 , mgr); // CACC=
						tml->xCMD++;

					break;

					case TML_VEL_MODE + 5: // 

						TML_BuildMessage(ax->AxisID , k , 0x5A57, 0 , 0x0004FFFF  , 0 , 4 , 2 , mgr); // UPGRADE2 = 1
						tml->xCMD++;

					break;

					
					case TML_VEL_MODE + 6: // 
						
						TML_BuildMessage(ax->AxisID , k , 0x0108, 0 , 0 , 0 , 0 , 2 , mgr); // UPD
						tml->xCMD++;
		
					break;
					

					case TML_VEL_MODE + 7: // 

						TML_BuildMessage(ax->AxisID , k , 0x0102, 0 , 0 ,0 , 0 , 0 , mgr); // AXISON
						
						tml->Status = TML_STAT_VEL_MODE_OK;
						tml->pState->FbkVect.Mode = vectSt_Mode_Vel;
						
						//tml->_int._vel = 0; This was wrong
						tml->_int._vel = tml->pState->OutVect.vel + 0.001; // this force to send again when mode is changed
						tml->xCMD = TML_IDLE;
						

					break;


					//////////////////////////////////////////////////////////////////////////////////////

					case TML_TORQ_MODE: //
					
						TML_BuildMessage(ax->AxisID , k , 0x0002, 0 , 0 ,0 , 0 , 0 , mgr); // AXISOFF
						tml->xCMD++;

					break;	

					case TML_TORQ_MODE + 1: // 

						d = (DINT)(tml->pState->OutVect.amp * 1365 ); // 
						tml->_int._amp = tml->pState->OutVect.amp;
						TML_BuildMessage(ax->AxisID , k , 0x20A9, 0 , d , 0 , 2 , 1 , mgr); // EREFT=
						tml->xCMD++;
												
					break;

					case TML_TORQ_MODE + 2: // 
						
						TML_BuildMessage(ax->AxisID , k , 0x5909, 0 , 0x0000FF3F , 0 , 4 , 2 , mgr); // EXTREF 0
						tml->xCMD++;

					break;

					case TML_TORQ_MODE + 3: // 

						TML_BuildMessage(ax->AxisID , k , 0x5909, 0 , 0x8100B1C0  , 0 , 4 , 2 , mgr); // MODE TES
						tml->xCMD++;
					

					break;

					case TML_TORQ_MODE + 4: // 
					
						TML_BuildMessage(ax->AxisID , k , 0x0108, 0 , 0 , 0 , 0 , 2 , mgr); // UPD
						tml->xCMD++;
		
					break;
				

					case TML_TORQ_MODE + 5: // 
						
						TML_BuildMessage(ax->AxisID , k , 0x0102, 0 , 0 ,0 , 0 , 0 , mgr); // AXISON						
						tml->Status = TML_STAT_TORQ_MODE_OK;
						tml->pState->FbkVect.Mode = vectSt_Mode_Torq;
						tml->_int._amp = tml->pState->OutVect.amp +0.00001; // Force to send any value
						tml->xCMD = TML_IDLE;
						

					break;						

					//////////////////////////////////////////////////////////////////////////////////////


					case TML_VOLT_MODE: // 


						TML_BuildMessage(ax->AxisID , k , 0x0002, 0 , 0 ,0 , 0 , 0 , mgr); // AXISOFF
						tml->xCMD++;

					break;
					
					case TML_VOLT_MODE+1: // 

						
						d = (DINT)(tml->pState->OutVect.volt* 1365 ); // 
						tml->_int._volt = tml->pState->OutVect.volt;
						TML_BuildMessage(ax->AxisID , k , 0x20A9, 0 , d , 0 , 2 , 1 , mgr); // EREFV=
						tml->xCMD++;
											
					break;

					case TML_VOLT_MODE + 2: // 
						
						TML_BuildMessage(ax->AxisID , k , 0x5909, 0 , 0x0000FF3F , 0 , 4 , 2 , mgr); // EXTREF 0
						tml->xCMD++;

					break;

					case TML_VOLT_MODE + 3: // 

						TML_BuildMessage(ax->AxisID , k , 0x5909, 0 , 0x8000B0C0 , 0 , 4 , 2 , mgr); // MODE VES
						tml->xCMD++;


					break;

					
					case TML_VOLT_MODE + 4: // 
											
						TML_BuildMessage(ax->AxisID , k , 0x0108, 0 , 0 , 0 , 0 , 2 , mgr); // UPD
						tml->xCMD++;
		
					break;

					case TML_VOLT_MODE + 5: // 
											
						
						TML_BuildMessage(ax->AxisID , k , 0x0102, 0 , 0 ,0 , 0 , 0 , mgr); // AXISON

						
						//tml->xCMD = TML_VOLT_MODE + 6;// UWAGA
											
						tml->xCMD = TML_VOLT_MODE + 9;
		
					break;

					case TML_VOLT_MODE + 6: // 
											
						TML_BuildMessage(ax->AxisID , k , 0x0108, 0 , 0 , 0 , 0 , 2 , mgr); // UPD
						tml->xCMD++;
		
					break;

					case TML_VOLT_MODE + 7: // 
											
						
						TML_BuildMessage(ax->AxisID , k , 0x0102, 0 , 0 ,0 , 0 , 0 , mgr); // AXISON
						tml->xCMD++;
		
					break; 


					case TML_VOLT_MODE + 8: // 
											
						TML_BuildMessage(ax->AxisID , k , 0x0108, 0 , 0 , 0 , 0 , 2 , mgr); // UPD
						tml->xCMD++;
		
					break;
				

					case TML_VOLT_MODE + 9: // 
					
						//TML_BuildMessage(ax->AxisID , k , 0x0108, 0 , 0 , 0 , 0 , 2 , mgr); // UPD
						
						tml->Status = TML_STAT_VOLT_MODE_OK;
						tml->pState->FbkVect.Mode = vectSt_Mode_Volt;
						
						tml->_int._volt = tml->pState->OutVect.volt+0.01; // Force to send any value
						tml->xCMD = TML_IDLE;
												

					break;
						

					//////////////////////////////////////////////////////////////////////////////////////	

					case TML_PT_MODE: // 


						TML_BuildMessage(ax->AxisID , k , 0x0002, 0 , 0 ,0 , 0 , 0 , mgr); // AXISOFF
						tml->xCMD++;

					break;
					
					case TML_PT_MODE + 1: // 
						
						d = 0x8080 &  0xF080;
						
						t = 2;
						//t = 4;
						t = t<< 9;
						t = t & 0x0F00;
						
						d = d | t;

						d = (d << 16);

						ax->PointCounter = 0;

						TML_BuildMessage(ax->AxisID , k , 0x1880, 0 ,d  , 0 , 2 , 1 , mgr); // SETPT Clear Buffer
						tml->xCMD++;
											
											
					break;

					case TML_PT_MODE + 2: // 

													
						TML_BuildMessage(ax->AxisID , k , 0x5909, 0 , 0x870AFFC0 , 0 , 4 , 2 , mgr); // MODE PT
						tml->xCMD++;

					break;

					case TML_PT_MODE + 3: // 

						TML_BuildMessage(ax->AxisID , k , 0x0108, 0 , 0 , 0 , 0 , 2 , mgr); // UPD
						tml->xCMD++;

					break;

					case TML_PT_MODE + 4: // 

					
						TML_BuildMessage(ax->AxisID , k , 0x5909, 0 , 0x0000DFFF , 0 , 4 , 2 , mgr); // CPR  , CPA = 0#2000FFFF
						tml->xCMD++;


					break;



					case TML_PT_MODE + 5: // 

					
						TML_BuildMessage(ax->AxisID , k , 0x5909, 0 , 0x0000BFFF, 0 , 4 , 2 , mgr); // TUM0
						
						tml->xCMD++;


					break;


					
					case TML_PT_MODE + 6: // 

										
						TML_BuildMessage(ax->AxisID , k , 0xC800 | (ax->PointCounter & 0x007F) , 0 , 0 , tml->_int.PVTPeriod , 6 , 3 , mgr); // PTP 0L, 625U , 0
						ax->PointCounter++;
						tml->xCMD++;


					break;

					
					
				
					case TML_PT_MODE + 7: // 


						TML_BuildMessage(ax->AxisID , k , 0x0108, 0 , 0 , 0 , 0 , 2 , mgr); // UPD
						tml->xCMD++;
						

					break;

					case TML_PT_MODE + 8: // 
										
						TML_BuildMessage(ax->AxisID , k , 0x0102, 0 , 0 ,0 , 0 , 0 , mgr); // AXISON
						tml->xCMD++;


					break;

					case TML_PT_MODE + 9: // 

																
						TML_BuildMessage(ax->AxisID , k , 0xC800 | (ax->PointCounter & 0x007F), 0 , 0 , tml->_int.PVTPeriod , 6 , 3 , mgr); // PTP 0L, 625U , 0
						ax->PointCounter++;

						tml->_int._pos = (DINT)(tml->pState->OutVect.x   * tml->_int.kPos);
						tml->_int.startPos = tml->PosFBK - tml->pState->OutVect.x;

						tml->xCMD++;

					break;



					case TML_PT_MODE+10: // 
			
						tml->Status = TML_STAT_PT_MODE_OK;
						tml->pState->FbkVect.Mode = vectSt_Mode_PT;
						tml->xCMD = TML_IDLE;
																
					break;


					
					////////////////////////////////////////////////////////////
					
					case TML_ARC_CUST_CMD:

						if(tml->pState->fParam[0] > tml->_cfg.maxVel)
							f = tml->_cfg.maxVel ;
						else if(tml->pState->fParam[0] == 0.0)
							f = tml->_cfg.maxVel;
						else
							f = tml->pState->fParam[0];
						
						d = (DINT)(f * tml->_int.kVel *  65535.0); 
						TML_BuildMessage(ax->AxisID , k , TML_set_TouchVel_fixed, 0 , d , 0 , 4 , 2 , mgr); 
												
						tml->xCMD++;	


					break;


					case TML_ARC_CUST_CMD+1:

						if(tml->pState->fParam[1] > tml->_cfg.maxVel)
							f = tml->_cfg.maxVel ;
						else if(tml->pState->fParam[1] == 0.0)
							f = tml->_cfg.maxVel;
						else
							f = tml->pState->fParam[1];
						
						d = (DINT)(f * tml->_int.kVel *  65535.0); 
						TML_BuildMessage(ax->AxisID , k , TML_set_RetVel_fixed, 0 , d , 0 , 4 , 2 , mgr); 
												
						tml->xCMD++;	


					break;


					case TML_ARC_CUST_CMD+2:
													
						d = (DINT)(tml->pState->fParam[2] * tml->_int.kPos);
						TML_BuildMessage(ax->AxisID , k , TML_set_ArcTrshld_long, 0 , d , 0 , 4 , 2 , mgr); 
												
						tml->xCMD++;	


					break;

					case TML_ARC_CUST_CMD+3:
													
						d = tml->pState->Param[0];
						TML_BuildMessage(ax->AxisID , k , TML_set_RetTM_long, 0 , d , 0 , 4 , 2 , mgr); 
												
						tml->xCMD++;	


					break;

					case TML_ARC_CUST_CMD+4:
													
						d = tml->pState->Param[1];
						TML_BuildMessage(ax->AxisID , k , TML_set_TouchTM_long, 0 , d , 0 , 4 , 2 , mgr); 
												
						tml->xCMD++;	


					break;						

					case TML_ARC_CUST_CMD+5:
													
						d = 1;
						TML_BuildMessage(ax->AxisID , k , TML_set_CmdWord_int, 0  , d , 0 , 2, 1 , mgr); // 
												
						tml->xCMD = TML_IDLE;

					break;

					
					//////////////////////////////////////////////////////////

					case TML_MOVE_REL_CMD:
						
						//TML_BuildMessage(ax->AxisID , k , 0x01C4, 0 , 0 ,0 , 0 , 0 , mgr); // STOP

						/*
						if(tml->pState->fParam[0] > tml->_cfg.maxAcc)
							f = tml->_cfg.maxAcc ;
						else if(tml->pState->fParam[0] == 0.0)
							f = tml->_cfg.maxAcc;
						else
							f = tml->pState->fParam[0];

						d = (DINT)(f * tml->_int.kAcc *  65535.0); 						
						TML_BuildMessage(ax->AxisID , k , 0x24A2, 0 , d , 0 , 4 , 2 , mgr); // CACC=
						*/
						
						tml->xCMD ++;

					break;
					
					case TML_MOVE_REL_CMD+1: // 
						
						//TML_BuildMessage(ax->AxisID , k , 0x0510 , 0 , 0 ,0 , 0 , 0 , mgr); // EINT
						//TML_BuildMessage(ax->AxisID , k , 0x0108, 0 , 0 , 0 , 0 , 2 , mgr); // UPD
						tml->xCMD++;

					break;
															
					case TML_MOVE_REL_CMD+2:

						
						if(tml->pState->fParam[0] > tml->_cfg.maxAcc)
							f = tml->_cfg.maxAcc ;
						else if(tml->pState->fParam[0] == 0.0)
							f = tml->_cfg.maxAcc;
						else
							f = tml->pState->fParam[0];

						d = (DINT)(f * tml->_int.kAcc *  65535.0); 						
						TML_BuildMessage(ax->AxisID , k , 0x24A2, 0 , d , 0 , 4 , 2 , mgr); // CACC=
						
						
						tml->xCMD++;


					break;

					case TML_MOVE_REL_CMD+3:

						if(tml->pState->fParam[1] > tml->_cfg.maxVel)
							f = tml->_cfg.maxVel ;
						else if(tml->pState->fParam[1] == 0.0)
							f = tml->_cfg.maxVel;
						else
							f = tml->pState->fParam[1];
						
						d = (DINT)(f * tml->_int.kVel *  65535.0); 
						TML_BuildMessage(ax->AxisID , k , 0x24A0, 0 , d , 0 , 4 , 2 , mgr); // CSPD=
												
						tml->xCMD++;	

					break;

					case TML_MOVE_REL_CMD+4:

						f = tml->pState->fParam[2];
						d = (DINT)(f * tml->_int.kPos); 
						TML_BuildMessage(ax->AxisID , k , 0x249E, 0 , d , 0 , 4 , 2 , mgr); // CPOS=
												
						tml->xCMD++;	


					break;

					case TML_MOVE_REL_CMD+5:

						TML_BuildMessage(ax->AxisID , k , 0x5909, 0 , 0x0000DFFF , 0 , 4 , 2 , mgr); // CPR = 0x0000DFFF  , CPA = 0#2000FFFF
												
						tml->xCMD++;	


					break;

					case TML_MOVE_REL_CMD+6:

														
						TML_BuildMessage(ax->AxisID , k , 0x5909, 0 , 0x8701BFC1 , 0 , 4 , 2 , mgr); // MODE PP
						
						tml->xCMD++;

					break;

					case TML_MOVE_REL_CMD+7:

						//if(KK_TUM)
							//TML_BuildMessage(ax->AxisID , k , 0x5909, 0 , 0x4000FFFF, 0 , 4 , 2 , mgr); // TUM1
						
						tml->xCMD++;
						
					break;					
										
					case TML_MOVE_REL_CMD+8:

						TML_BuildMessage(ax->AxisID , k , 0x0108, 0 , 0 , 0 , 0 , 2 , mgr); // UPD

						tml->xCMD++;

					break;	

					case TML_MOVE_REL_CMD+9:

						TML_BuildMessage(ax->AxisID , k , 0x0102, 0 , 0 ,0 , 0 , 0 , mgr); // AXISON	
						tml->xCMD = TML_IDLE;

					break;	


					////////////////////////////////////////////
					case TML_AXIS_ON_CMD:

						TML_BuildMessage(ax->AxisID , k , 0x0102, 0 , 0 ,0 , 0 , 0 , mgr); // AXISON	

						tml->xCMD = TML_IDLE;
						

					break;

					case TML_AXIS_OFF_CMD:

						TML_BuildMessage(ax->AxisID , k , 0x0002, 0 , 0 ,0 , 0 , 0 , mgr); // AXISOFF

						tml->xCMD = TML_IDLE;
						
					break;


					///////////////////////////////////////////////////////////////////////////////////////////

					// PROGRAM DOWNLOADING ///////////////////////////////////////////////////////////////

					case TML_DOWNL:

						mgr->BlockTrans[k] = ax->AxisID;
						mgr->Firmware[k] = 0;
						ax->FirmwareVersion = 0;
						tml->_int.Init = 0;	
						TML_BuildMessage(ax->AxisID , k , 0xD801, 0 , 0x000000A0 , 0 , 2 , 1 , mgr); // GetVersion
						
						tml->xCMD++;
						
					break;							

					case TML_DOWNL + 1:


						if((mgr->Firmware[k] > 0) || 1){ // Nie sprawdzam , bo to nie dziala dobrze

							ax->FirmwareVersion = mgr->Firmware[k];

							if((ax->FirmwareVersion != tml->FirmwareVersion) && 0){ // Nie sprawdzam , bo to nie dziala dobrze
								mgr->BlockTrans[k] = 0;
								OneDrivePerTime = 0;
								tml->Error = 1;
								tml->ErrorReg = 0xFFFF;
								tml->xCMD = TML_ERROR - 1;
								
								if(logger)
									LogTxt(logger , "TML %s Firmw Err: %s " , tml->Name ,  UDINT2ASC(ax->FirmwareVersion));
								
							}

							else if((File_RW.CMD == 0) && !File_RW.FileLocked){

								if(logger)
									LogTxt(logger , "TML %s Firmw OK: %s " , tml->Name , UDINT2ASC(ax->FirmwareVersion));
								
								strcpy(File_RW.fileName , tml->_cfg.programName);
								strcpy(File_RW.deviceName, "Data");
											
								File_RW.CMD = F_READ;
								File_RW.Done = 0;
								//File_RW.FileLocked = 1;

								tml->xCMD++;

							}	
						}
						


					break;	

					case TML_DOWNL +2:

						if((File_RW.CMD == 0) && File_RW.Done){ 

							
							if((!File_RW.Error && File_RW.pMem)){

								pointer = File_RW.pMem;

								TML_BuildMessage(ax->AxisID , k , 0x2166, 0 , 0x4000 , 0 , 2 , 1 , mgr); // var_i1=0x400
							
								tml->xCMD++;
							}
							else{
								File_RW.CMD = F_FREE_MEM;								
								mgr->BlockTrans[k] = 0;
								OneDrivePerTime = 0;
								tml->xCMD = TML_ERROR - 2;
								tml->Error = 1;
								tml->ErrorReg = 0xFFFE;
								if(logger)
									LogTxt(logger , "TML %s Progr Err: %d  " , tml->Name , tml->xCMD);
							}
						}	


					break;	

					case TML_DOWNL +3:

						d = 0x00010366 ;

						TML_BuildMessage(ax->AxisID , k , 0x90A8, 0 , d , 0 , 4 , 2 , mgr); // (var_i1),spi = 1; - disable the autorun mode

						tml->xCMD++;
 
					break;


					case TML_DOWNL +4:

						Ret = ReadValue((char**)&pointer , &Value);
						
						TML_BuildMessage(ax->AxisID , k , 0x2166, 0 , Value , 0 , 2 , 1 , mgr); // var_i1=xxxx
						memPointer = Value; 

						tml->xCMD++;
							

					break;	
					


					case TML_DOWNL +5:
					
						Ret = ReadValue((char**)&pointer , &Value);

						if(pointer > File_RW.pMem + File_RW.Len){
							File_RW.CMD = F_FREE_MEM;
							tml->xCMD = TML_ERROR - 3;	
							tml->Error = 1;
							tml->ErrorReg = 0xFFFE;
							if(logger)
								LogTxt(logger , "TML %s Progr Err: %d  " , tml->Name , tml->xCMD);
							
							OneDrivePerTime = 0;
							mgr->BlockTrans[k] = 0;
							
						}

						else if(Ret > 0){

							Value = Value << 16;
							Value += 0x0366;
						
							TML_BuildMessage(ax->AxisID , k , 0x9028, 0 , Value , 0 , 4 , 2 , mgr); // (var_i1+),spi = x;
							memPointer ++;
							tml->xCMD++;

							
						}
						else if(Ret < 0){

							Ret = ReadValue((char**)&pointer , &Value);
							if((pointer > File_RW.pMem + File_RW.Len)
								|| (Value < 0x4000) ){
								File_RW.CMD = F_FREE_MEM;
								OneDrivePerTime = 0;
								mgr->BlockTrans[k] = 0;
								if(logger)
									LogTxt(logger , "TML %s Progr Loaded: %s  " , tml->Name ,  UDINT2ASC(ax->ProgramVersion));


								tml->xCMD = TML_DOWNL_DONE; //Success
									
							}	
							else{							
									
								TML_BuildMessage(ax->AxisID , k , 0x2166, 0 , Value , 0 , 2 , 1 , mgr); // var_i1=xxxx
								memPointer = Value; 
								
							}
				
						}
						else{
							mgr->BlockTrans[k] = 0;
							OneDrivePerTime = 0;
							File_RW.CMD = F_FREE_MEM;							
							tml->xCMD = TML_ERROR - 4 ;
							tml->Error = 1;
							tml->ErrorReg = 0xFFFE;
							if(logger)
								LogTxt(logger , "TML %s Progr Err: %d  " , tml->Name , tml->xCMD);
						}
							

						

					break;


					case TML_DOWNL +6:

						d = 0x036600A1 ;
						TML_BuildMessage(ax->AxisID , k , 0xB204, 0 , d , 0 , 4 , 2 , mgr); // ??var_i1
						tml->xCMD++;
 
					break;

					case TML_DOWNL +7:						

						if(ax->pointer == memPointer)							
							tml->xCMD = TML_DOWNL +5;

					break;	



					///////////////////////////////////////////////////////////////////////////////////
					case TML_UpdateFilter: // 

						if(tml->_cfg.signFilter > 0.0 && tml->_cfg.signFilter < 1.0)
							d = (int)(((1-tml->_cfg.signFilter)* 4000.0)+1000.0);
						else if (tml->_cfg.signFilter >= 1.0)
							d = 0;
						else
							d = 32767;
					
											
						TML_BuildMessage(ax->AxisID , k , TML_set_signFilter_int, 0  , d , 0 , 2, 1 , mgr); // signFilter=
						
						tml->xCMD = TML_IDLE;
					
					
					break;

					case TML_ClearFilter: // 

												
						TML_BuildMessage(ax->AxisID , k , TML_set_signFilter_int, 0  , 32767 , 0 , 2, 1 , mgr); // signFilter=
						
						tml->xCMD = TML_IDLE;
					
					
					break;

					
					case TML_FullFilter: // 
					
																	
						TML_BuildMessage(ax->AxisID , k , TML_set_signFilter_int, 0  , 0 , 0 , 2, 1 , mgr); // signFilter=
						
						tml->xCMD = TML_IDLE;
					
					
					break;

					case TML_SATP: // 						
						
						if(tml->_cfg.satpMax > 0)
							TML_BuildMessage(ax->AxisID , k , 0x2065, 0 , tml->_cfg.satpMax, 0 , 2 , 1 , mgr); // SATP=
						
						
						tml->xCMD = TML_IDLE;
					
					
					break;	

					case TML_SATP_Zero: // 	
					
						if(tml->_cfg.satpMax > 0)												
							TML_BuildMessage(ax->AxisID , k , 0x2065 , 0  , 32767 , 0 , 2, 1 , mgr); // SATP=
											
						tml->xCMD = TML_IDLE;
						
					
					break;		
					
					case TML_SetGain: // 										
																		
						tml->xCMD = TML_IDLE;				
											
					break;
					

					case TML_SetGain_Zero: // 
						
						tml->xCMD = TML_IDLE;							
					
					break;						


					case TML_KPP: // 


						if(tml->_cfg.kpp > 32767)
							tml->_cfg.kpp = 32767;	
						else if(tml->_cfg.kpp < -32767)
							tml->_cfg.kpp = -32767;

						if(tml->_cfg.kppMax != 0)
							TML_BuildMessage(ax->AxisID , k , 0x205E , 0  , tml->_cfg.kpp , 0 , 2, 1 , mgr); // KPP=
												
						tml->xCMD = TML_KIP;
					
					
					break;	

					case TML_KPP_Zero: // 

						if(tml->_cfg.kpp > 32767)
							tml->_cfg.kpp = 32767;							
						else if(tml->_cfg.kpp < -32767)
							tml->_cfg.kpp = -32767;

						if(tml->_cfg.kppMax != 0)
							TML_BuildMessage(ax->AxisID , k , 0x205E , 0  , 0 , 0 , 2, 1 , mgr); // KPP=
												
						tml->xCMD = TML_KIP_Zero;
					
					
					break;	

					case TML_KIP: // 

						if(tml->_cfg.kip > 32767)
							tml->_cfg.kip = 32767;
						else if(tml->_cfg.kip < -32767)
							tml->_cfg.kip = -32767;

						if(tml->_cfg.kipMax != 0)																		
							TML_BuildMessage(ax->AxisID , k , 0x2060 , 0  , tml->_cfg.kip , 0 , 2, 1 , mgr); // KIP=
						
						tml->xCMD = TML_IDLE;
					
					
					break;	
					

					case TML_KIP_Zero: // 

						if(tml->_cfg.kip > 32767)
							tml->_cfg.kip = 32767;
						else if(tml->_cfg.kip < -32767)
							tml->_cfg.kip = -32767;

						if(tml->_cfg.kipMax != 0)																		
							TML_BuildMessage(ax->AxisID , k , 0x2060 , 0  , 0 , 0 , 2, 1 , mgr); // KIP=
						
						tml->xCMD = TML_IDLE;
					
					
					break;	

					
					case TML_SET_OUT0_CMD: // 
						
						tml->xCMD = TML_IDLE;							
					
					break;	

					case TML_SET_OUT1_CMD: // 
						
						tml->xCMD = TML_IDLE;							
					
					break;

					
					case TML_RST_OUT0_CMD: // 
												
						tml->xCMD = TML_IDLE;							
					
					break;	

					case TML_RST_OUT1_CMD: // 
						
						tml->xCMD = TML_IDLE;							
					
					break;

					
					//////////////////////////////////////////////////////////////////////////////////////

				
					case TML_ERROR:

						tml->Status = TML_STAT_DRIVE_ERR;
						mgr->BlockTrans[k] = 0;
						OneDrivePerTime = 0;
						tml->Error = 1;
						
					break;	
					


				}
#ifdef KK_SUPER_TRACE

				if(tml->xCMD >0)
					KK_Proc_XCMD++;
#endif				
				
				if(mgr->hrdw[k].TXCount != mgr->hrdw[k].TXCountReadBack)	
					goto BUSY_USE_NEXT_CHANNEL;	

				if(tml->xCMD !=TML_IDLE)
					goto PROCESS_NEXT_TML;
	
				///////////////////////////////////////
				///////////////////////////////////////
				// Vector Mode Listener //			

				if(tml->_int.Init){ 

#ifdef KK_SUPER_TRACE				
					KK_Proc_Vect_State++;
#endif

					if(tml->pState){


						// Reset warnings
						tml->pState->FbkWarning = 0;

						// Should be uncommment						
						if(tml->pState->simul)
							tml->_int._pos = (DINT)(tml->pState->OutVect.x   * tml->_int.kPos);

						//if(Master.ESTOP || tml->Disable){
						if(tml->Disable){	

							// Take state from simulation
							if(!tml->pState->simul)
								tml->pState->FbkVect.Mode = vectSt_Mode_OFF;

								
							if((tml->StatusReg & 0x8000))
								TML_BuildMessage(ax->AxisID , k , 0x0002, 0 , 0 ,0 , 0 , 0 , mgr); // AXISOFF
							
							
						}	

						else if(!tml->pState->simul && !tml->Error){
							
							switch(tml->pState->OutVect.Mode ){

								
								case vectSt_Mode_Idle:


									if(ax->DriveStatusRegisterL & 0x8000){
										
										TML_BuildMessage(ax->AxisID , k , 0x0002, 0 , 0 ,0 , 0 , 0 , mgr); // AXISOFF

									}											
									else{

										if(tml->Status > 0)
											tml->Status = TML_STAT_IDLE;
										
										tml->pState->FbkVect.Mode = vectSt_Mode_Idle;
									}
									
																	
								break;	

								case vectSt_Mode_Hold:


									if((tml->Status == TML_STAT_HOLD_OK) && (tml->pState->xCMD != VECT_Refresh_Mode))
										tml->pState->FbkVect.Mode = vectSt_Mode_Hold;

									else if(tml->Status != TML_STAT_HOLD_INIT){
										
										if(tml->pState->xCMD == VECT_Refresh_Mode)
											tml->pState->xCMD = 0;
										
										tml->Status = TML_STAT_HOLD_INIT;					
										
										tml->xCMD = TML_HOLD_MODE;

									}	

								break;	


								case vectSt_Mode_Home:


								break;	


								case vectSt_Mode_Drive_Independant:

										tml->Status = TML_STAT_DRIVE_SELF_CNTRL;
										
										tml->pState->FbkVect.Mode = vectSt_Mode_Drive_Independant;


								break;

								case vectSt_Mode_Custom:

									if((tml->Status == TML_STAT_CUSTOM_OK) && (tml->pState->xCMD != VECT_Refresh_Mode)){


									}
									else if(tml->Status != TML_STAT_CUSTOM_INIT){


										if(tml->pState->xCMD == VECT_Refresh_Mode)
											tml->pState->xCMD = 0;
										
										
										tml->Status = TML_STAT_CUSTOM_INIT;
										
										tml->xCMD = TML_CUST_MODE;
											
										
									}	




								break;	


								case vectSt_Mode_Pos:									
									

									if((tml->Status == TML_STAT_POS_MODE_OK) && (tml->pState->xCMD != VECT_Refresh_Mode)){


										// Hardware Limits switches warnings
										if(tml->DigInp[2] )											
											tml->pState->FbkWarning = 1.0;								
											
										else if(tml->DigInp[3])								
											tml->pState->FbkWarning = -1.0;
										

										if(tml->xCMD == 0){
											
											if(tml->_int._floatPos != tml->pState->OutVect.x){
												
												d = (DINT)(tml->pState->OutVect.x * tml->_int.kPos); // 
												tml->_int._floatPos = tml->pState->OutVect.x;
												TML_BuildMessage(ax->AxisID , k , 0x24A8, 0 , d , 0 , 4 , 2 , mgr); // EREF=

												tml->_int.cnt = tml->_int._posCnt;
												tml->_int._posCnt = 0;

												//tml->_int.msgProcess = 1;

												
											}
										}
										
										
									}
									else if(tml->Status != TML_STAT_POS_MODE_INIT){

										if(tml->pState->xCMD == VECT_Refresh_Mode)
											tml->pState->xCMD = 0;
										
										
										tml->Status = TML_STAT_POS_MODE_INIT;
										tml->xCMD = TML_POS_MODE;												
										
									}	

										
										


								break;	

								case vectSt_Mode_Vel:

									if(tml->Status == TML_STAT_VEL_MODE_OK && (tml->pState->xCMD != VECT_Refresh_Mode)){	

						
										tml->pState->FbkWarning = 0;


										
										if(tml->_cfg.AnalLimitPos > 0){
											

											if(tml->AnInp[1] > tml->_cfg.AnalLimitPos ){

												if(tml->pState->OutVect.vel > 0.0){
													
													tml->pState->FbkWarning = 2;
													tml->pState->OutVect.vel = 0;

												}
											}	

											else if(tml->AnInp[1] < tml->_cfg.AnalLimitNeg ){

												if(tml->pState->OutVect.vel < 0.0){	
													
													tml->pState->FbkWarning = -2;
													tml->pState->OutVect.vel = 0;

												}
											}
											

										}


										// Consider software limits only when they are not equal
										
										if(tml->pState->OutVect.softLimits[0] != tml->pState->OutVect.softLimits[1]){
											

											if(tml->PosFBK > tml->pState->OutVect.softLimits[1]){

																					
												if(tml->pState->OutVect.vel > 0.0){
													
													tml->pState->FbkWarning = 1;
													tml->pState->OutVect.vel = 0;

												}
										
											}
											else if(tml->PosFBK < tml->pState->OutVect.softLimits[0]){

																					
												if(tml->pState->OutVect.vel < 0.0){
													
													tml->pState->FbkWarning = -1;
													tml->pState->OutVect.vel = 0;

												}
											
											}
																							
										}
										
										
										if(fabsf(tml->pState->OutVect.vel) > tml->_cfg.maxVel ){

											tml->pState->FbkWarning = 2;

											if(tml->pState->OutVect.vel > tml->_cfg.maxVel)
												tml->pState->OutVect.vel = tml->_cfg.maxVel;
											else
												tml->pState->OutVect.vel = tml->_cfg.maxVel * (-1.0);


										}	

										

										if(!(tml->StatusReg & 0x8000))
											TML_BuildMessage(ax->AxisID , k , 0x0102, 0 , 0 ,0 , 0 , 0 , mgr); // AXISON
											

										else{
											
											if(tml->_int._vel != tml->pState->OutVect.vel){
													tml->_int._vel = tml->pState->OutVect.vel;
													tml->_int.KickCntr = Kick_Repeats;
											}
											else if(tml->_int.KickCntr > 0)
												tml->_int.KickCntr--;
											
									
											if(tml->_int.KickCntr > 0){													
												
												f = tml->pState->OutVect.vel * fabsf(tml->_int.kVel);
												//tml->_int._vel = tml->pState->OutVect.vel;
												
												d = (DINT)(f * 65535.0 ); 

												if(tml->_cfg.rev_motor < 0)
													d = d* ( -1);
												
												TML_BuildMessage(ax->AxisID , k , 0x24A8, 0 , d , 0 , 4 , 2 , mgr); // EREFS=

												tml->_int.cnt = tml->_int._posCnt;
												tml->_int._posCnt = 0;

												//tml->_int.msgProcess = 1;
											}	


										}
										
									}
									else if(tml->Status != TML_STAT_VEL_MODE_INIT){


										if(tml->pState->xCMD == VECT_Refresh_Mode)
											tml->pState->xCMD = 0;
										
										tml->Status = TML_STAT_VEL_MODE_INIT;	
										tml->xCMD = TML_VEL_MODE;
									}	
										


								break;	

								case vectSt_Mode_Torq:

									if((tml->Status == TML_STAT_TORQ_MODE_OK)&& (tml->pState->xCMD != VECT_Refresh_Mode)){

											if(!(tml->StatusReg & 0x8000))
												TML_BuildMessage(ax->AxisID , k , 0x0102, 0 , 0 ,0 , 0 , 0 , mgr); // AXISON

											else if(tml->_int._amp != tml->pState->OutVect.amp){
											
												d = (DINT)(tml->pState->OutVect.amp * 1365);
												tml->_int._amp = tml->pState->OutVect.amp;

												if(tml->_cfg.rev_motor < 0)
													d = d* ( -1);
												
												TML_BuildMessage(ax->AxisID , k , 0x20A9, 0 , d , 0 , 2 , 1 , mgr); // EREF=

												tml->_int.cnt = tml->_int._posCnt;
												tml->_int._posCnt = 0;

												//tml->_int.msgProcess = 1;

											}
									}
									else if(tml->Status != TML_STAT_TORQ_MODE_INIT){


										if(tml->pState->xCMD == VECT_Refresh_Mode)
											tml->pState->xCMD = 0;
										

										tml->Status = TML_STAT_TORQ_MODE_INIT;
										
										TML_BuildMessage(ax->AxisID , k , 0x0102, 0 , 0 ,0 , 0 , 0 , mgr); // AXISON
										tml->xCMD = TML_TORQ_MODE;
									}
							
								break;	

								case vectSt_Mode_Volt:

									tml->pState->FbkWarning = 0;

									if((tml->Status == TML_STAT_VOLT_MODE_OK)&& (tml->pState->xCMD != VECT_Refresh_Mode)){


										if(tml->pState->OutVect.volt > 24.0)
											tml->pState->OutVect.volt = 24.0;
										else if(tml->pState->OutVect.volt < (-24.0))
											tml->pState->OutVect.volt = (-24.0);


										if(tml->DigInp[2] != tml->DigInp[3]){
										
											if(tml->DigInp[2] ){
												
												tml->pState->FbkWarning = 1.0;
												
												if(tml->pState->OutVect.volt > 0)
													tml->pState->OutVect.volt = 0.0;
											}	
											else if(tml->DigInp[3]){
												
												tml->pState->FbkWarning = -1.0;

												if(tml->pState->OutVect.volt < 0)
													tml->pState->OutVect.volt = 0.0;
												
											}
										}
										
									
										
										// Consider software limits only when they are not equal
										
										if(tml->pState->OutVect.softLimits[0] != tml->pState->OutVect.softLimits[1]){
											

											if(tml->PosFBK > tml->pState->OutVect.softLimits[1]){
											
												tml->pState->FbkWarning = 1;
										
											}
											else if(tml->PosFBK < tml->pState->OutVect.softLimits[0]){
												
												tml->pState->FbkWarning = -1;
											
											}
																							
										}
																					

										if(!(tml->StatusReg & 0x8000))
												TML_BuildMessage(ax->AxisID , k , 0x0102, 0 , 0 ,0 , 0 , 0 , mgr); // AXISON

										
										else if((tml->pState->OutVect.volt > 0.0) 
											//&& (tml->DigInp[2] || (tml->pState->FbkWarning > 0))){ // Limit Switch
											&& ((tml->pState->FbkWarning > 0))){ // Limit Switch
										
											TML_BuildMessage(ax->AxisID , k , 0x20A9, 0 , 0 , 0 , 2 , 1 , mgr); // EREFV=0
											tml->_int._volt = 0;
										}

										else if((tml->pState->OutVect.volt < 0.0)
											//&& (tml->DigInp[3] || (tml->pState->FbkWarning  < 0))){ // Limit Switch
											&& ((tml->pState->FbkWarning  < 0))){ // Limit Switch
										
											TML_BuildMessage(ax->AxisID , k , 0x20A9, 0 , 0 , 0 , 2 , 1 , mgr); // EREFV=0
											tml->_int._volt = 0;
										}
										
										else if(tml->_int._volt != tml->pState->OutVect.volt){
											
											d = (DINT)(tml->pState->OutVect.volt* 1365 ); //
											
											//if( tml->_int.kVel < 0)
											if(tml->_cfg.rev_motor < 0)
												d = d* ( -1);
												
											tml->_int._volt = tml->pState->OutVect.volt;
											TML_BuildMessage(ax->AxisID , k , 0x20A9, 0 , d , 0 , 2 , 1 , mgr); // EREFV=
										
											tml->_int.cnt = tml->_int._posCnt;
											tml->_int._posCnt = 0;

											//tml->_int.msgProcess = 1;
										}
										
									}
									else if(tml->Status != TML_STAT_VOLT_MODE_INIT){


										if(tml->pState->xCMD == VECT_Refresh_Mode)
											tml->pState->xCMD = 0;
										
										
										tml->Status = TML_STAT_VOLT_MODE_INIT;	
										tml->xCMD = TML_VOLT_MODE;
									}									
							
							
								break;	
					
								case vectSt_Mode_PT:

									tml->pState->FbkWarning = 0;

									
									if((tml->Status == TML_STAT_PT_MODE_OK)&& (tml->pState->xCMD != VECT_Refresh_Mode)){

										
										/*
										if(!(tml->MCRReg & 0xA)){

											TML_MTR_CUT_POWER = 1;
											
											tml->xCMD = TML_ERROR;											
											
											break;

										}	
										*/

										// Consider software limits only when they are not equal	
										tml->pState->FbkWarning = 0;

										/*
										if(tml->pState->OutVect.softLimits[0] != tml->pState->OutVect.softLimits[1]){												

											if(tml->pState->OutVect.x > tml->pState->OutVect.softLimits[1]){
											
												tml->pState->FbkWarning = 1;
										
											}
											else if(tml->pState->OutVect.x < tml->pState->OutVect.softLimits[0]){
												
												tml->pState->FbkWarning = -1;
											
											}
																							
										}
										*/
										
										if(ax->Flag & 0x10){ // check is new PVT status is in Status Register
	
											ax->Flag  &= 0xEF; // Reset flag			
											
											if(ax->PVTstatus & 0x4000) {// Check if buffer is low
	
												//ax->PVTstatus &= 0xBFFF;

												if(tml->pState->FbkWarning == 0)														
													d = (DINT)(tml->pState->OutVect.x *	tml->_int.kPos); 
												else
													d = tml->_int._pos;

												if(tml->_int.const_PT != 0)
													TML_BuildMessage(ax->AxisID , k , 0xC800 | (ax->PointCounter & 0x007F), 0 , tml->_int.const_PT , tml->_int.PVTPeriod , 6 , 3 , mgr); // PTP 0L, 625U , 0
												else													
													TML_BuildMessage(ax->AxisID , k , 0xC800 | (ax->PointCounter & 0x007F), 0 , d - tml->_int._pos , tml->_int.PVTPeriod , 6 , 3 , mgr); // PTP 0L, 625U , 0
												
												ax->PointCounter++;

													
												tml->_int.cnt = tml->_int._posCnt;
												tml->_int._posCnt = 0;

												//tml->_int.msgProcess = 1;
												
												tml->_int._deltaPos = d - tml->_int._pos ;				
												
												tml->_int._pos = d; 
												
	
											}
										}
									}
									else if(tml->Status != TML_STAT_PT_MODE_INIT){


										if(tml->pState->xCMD == VECT_Refresh_Mode)
											tml->pState->xCMD = 0;
										
										
										tml->Status = TML_STAT_PT_MODE_INIT;
										
										TML_BuildMessage(ax->AxisID , k , 0x0102, 0 , 0 ,0 , 0 , 0 , mgr); // AXISON
										tml->xCMD = TML_PT_MODE;
										
									}	
							
							
								break;	
								

							}
							
						}
					}
				}			
				

				if(mgr->hrdw[k].TXCount != mgr->hrdw[k].TXCountReadBack)	
					goto BUSY_USE_NEXT_CHANNEL;	
				
				if(tml->xCMD !=TML_IDLE)
					goto PROCESS_NEXT_TML;


				if(tml->pState){

						if(tml->pState->xCmd_busy){
							tml->pState->xCmd_busy = 0;
							goto PROCESS_NEXT_TML;		

						}
						
				}
				
				///////////////////////////////////////
				///////////////////////////////////////
				// Process command from Vectore state either				
				//if(tml->xCMD == TML_IDLE && tml->pState && (!tml->_int.msgProcess)){ //  When no ther command is processing
				if(tml->_int.Init){

#ifdef KK_SUPER_TRACE

					if(tml->pState->xCMD != 0)
						KK_Proc_Vect_XCMD++;

#endif
					
					
					switch(tml->pState->xCMD){


						case VECT_UpdateSignFilter:
							
							tml->xCMD = TML_UpdateFilter;
							
						break;	

						case VECT_ClearSignFilter:
							
							tml->xCMD = TML_ClearFilter;
							
						break;	

						case VECT_FullSignFilter:
							
							tml->xCMD = TML_FullFilter;
							
						break;

						case VECT_Set_Gain:
							
							tml->xCMD = TML_SetGain;
							
						break;

						case VECT_Set_Gain_Zero:
							
							tml->xCMD = TML_SetGain_Zero;
							
						break;

						case VECT_Set_PID_Param:
							
							tml->xCMD = TML_KPP;
							
						break;

						case VECT_Set_SATP:
							
							tml->xCMD = TML_SATP;
							
						break;

						case VECT_Set_SATP_Zero:
							
							tml->xCMD = TML_SATP_Zero;
							
						break;

						case VECT_Set_KPP:
							
							tml->xCMD = TML_KPP;
							
						break;

						case VECT_Set_KPP_Zero:
							
							tml->xCMD = TML_KPP_Zero;
							
						break;						

						case VECT_Set_Param_0:
						case VECT_Set_Param_1:
						case VECT_Set_Param_2:
						case VECT_Set_Param_3:
						case VECT_Set_Param_4:
						case VECT_Set_Param_5:
						case VECT_Set_Param_6:
						case VECT_Set_Param_7:

							h = tml->pState->xCMD - VECT_Set_Param_0;
							d = (DINT) tml->pState->fParam[h];
							
							TML_BuildMessage(ax->AxisID , k , TML_set_Param_0_int +h, 0  , d , 0 , 2, 1 , mgr); // PARAM_h
							
							tml->xCMD = TML_IDLE;
					
							
						break;

						case VECT_Set_CmdWord:
							
							d = (DINT) tml->pState->cmdWord;
							
							TML_BuildMessage(ax->AxisID , k , TML_set_CmdWord_int, 0  , d , 0 , 2, 1 , mgr); // 
							
							//tml->xCMD = TML_SET_Cmd_Word;
							tml->xCMD = TML_IDLE;
					
							
						break;


						case VECT_Set_MaxError:
							
							if(tml->pState->fParam[0] > 0.0)
								d = (DINT)(tml->pState->fParam[0]* tml->_int.kPos); // 
							else
								d = 0;

							// Hardcoded
							d = (DINT)( tml->_int.kPos * 0.05); // 0.1V
								
							TML_BuildMessage(ax->AxisID , k , TML_set_MaxError_long, 0 , d , 0 , 4 , 2 , mgr); // MaxError
		
							tml->xCMD = TML_IDLE;

						break;


						////////////////////

						case VECT_Set_OSC_Max:
							d = (DINT)(tml->pState->fParam[V_fParam_Max] * tml->_int.kPos);
							TML_BuildMessage(ax->AxisID , k , TML_set_P_Max_long, 0 , d , 0 , 4 , 2 , mgr); 

						break;

						
						case VECT_Set_OSC_Min:

							d = (DINT)(tml->pState->fParam[V_fParam_Min] *  tml->_int.kPos);
							TML_BuildMessage(ax->AxisID , k , TML_set_P_Min_long, 0 , d , 0 , 4 , 2 , mgr); 


						break;	
						
						case VECT_Set_OSC_Time:

							d = tml->pState->Param[V_Param_Time];
							TML_BuildMessage(ax->AxisID , k , TML_set_P_Time_long, 0 , d , 0 , 4 , 2 , mgr); 

						break;	
												
						
						case VECT_Set_OSC_DwellIn:

							d = tml->pState->Param[V_Param_DwellIn];
							TML_BuildMessage(ax->AxisID , k , TML_set_P_DwellIn_long, 0 , d , 0 , 4 , 2 , mgr); 

						break;
						
						case VECT_Set_OSC_DwellOut:

							d = tml->pState->Param[V_Param_DwellOut];
							TML_BuildMessage(ax->AxisID , k , TML_set_P_DwellOut_long, 0 , d , 0 , 4 , 2 , mgr); 
												
						break;
						
						case VECT_Set_OSC_Steer: 

							d = (DINT)(tml->pState->fParam[V_fParam_Steer] * tml->_int.kPos);
							TML_BuildMessage(ax->AxisID , k , TML_set_P_Steer_long, 0 , d , 0 , 4 , 2 , mgr);

						break;
						
						case VECT_Set_OSC_Cmd_Param:

							d = tml->pState->Param[V_Param_Cmd_Param];
							TML_BuildMessage(ax->AxisID , k , TML_set_Cmd_Param_long, 0 , d , 0 , 4 , 2 , mgr); 

						break;
						
						case VECT_Set_OSC_Jog_Volt:

							d = (DINT) (tml->pState->fParam[V_fParam_Jog] * tml->_int.kVolt);	
							TML_BuildMessage(ax->AxisID , k , TML_set_P_Jog_long, 0  , d , 0 , 4, 2 , mgr); 
						
						break;

						case VECT_Set_OSC_Jog_Speed:
	
							d = (DINT) (tml->pState->fParam[V_fParam_Jog] * tml->_int.kVel *  65535.0 );	
							TML_BuildMessage(ax->AxisID , k , TML_set_P_Jog_long, 0  , d , 0 , 4, 2 , mgr); 
						
						break;

						case VECT_Set_OSC_Jog_Step:
	
							d = (DINT) (tml->pState->fParam[V_fParam_Jog] * tml->_int.kPos);	
							TML_BuildMessage(ax->AxisID , k , TML_set_P_Jog_long, 0  , d , 0 , 4, 2 , mgr); 
						
						break;
						
						case VECT_Set_OSC_Amplit:

							d = (DINT)(tml->pState->fParam[V_fParam_Amplit] *  tml->_int.kPos);
							TML_BuildMessage(ax->AxisID , k , TML_set_P_Amplit_long, 0 , d , 0 , 4 , 2 , mgr); 

						break;	


						case VECT_Set_OSC_AllParam:

							tml->xCMD = TML_SET_P_Max;

						break;


						case VECT_Set_All_Run_Param:

							tml->xCMD = TML_SET_P_Time;

						break;					


						case VECT_Set_OSC_Home:

							tml->xCMD = TML_SET_Home;

						break;						

						//////////////////////


						case VECT_OSC_Start_Cmd:

							tml->xCMD = TML_OSC_CUST_CMD;

						break;

						case VECT_OSC_Update_Cmd:

							tml->xCMD = TML_OSC_CUST_CMD+2;

						break;

						case VECT_OSC_Stop_Cmd:
							
							tml->xCMD = TML_OSC_CUST_CMD+ 4;	

						break;

						case VECT_OSC_Stop2_Cmd:
							
							tml->xCMD = TML_OSC_CUST_CMD+ 5;	

						break;

						


						case VECT_Move_Rel_Cmd:
							
							tml->xCMD = TML_MOVE_REL_CMD;	

						break;	

						case VECT_ARC_Start_Cmd:
							
							tml->xCMD = TML_ARC_CUST_CMD;	

						break;	

						case VECT_ARC_Stop_Cmd:
							
							d = 0;
							TML_BuildMessage(ax->AxisID , k , TML_set_CmdWord_int, 0  , d , 0 , 2, 1 , mgr); // 

						break;

						case VECT_ZERO_AMPS_Cmd:					

							if((ax->SATS > 0)
								&& (ax->SATS <= 32767)){
								
								d = 32767;
								TML_BuildMessage(ax->AxisID , k , TML_set_SATS, 0  , d , 0 , 2, 1 , mgr); // 

							}

						break;

						case VECT_DEFAULT_AMPS_Cmd:	

							if((ax->SATS > 0)
								&& (ax->SATS <= 32767)){
							
								d = (DINT)ax->SATS;
								TML_BuildMessage(ax->AxisID , k , TML_set_SATS, 0  , d , 0 , 2, 1 , mgr); // 
							}

						break;


						case VECT_Set_OUT0:
							
							TML_BuildMessage(ax->AxisID , k , 0xEC00, 0  , 0x00000001 ,0 , 4, 2 , mgr); // Set Out0 to 1 ( OUT(0)=0x0000;)

						break;

						case VECT_Rst_OUT0:

							TML_BuildMessage(ax->AxisID , k , 0xEC00, 0  , 0x00010001 , 0 , 4, 2 , mgr); // Reset Out0 to 0 ( OUT(0)=0x0001;)

						break;

						case VECT_Set_OUT1:

							TML_BuildMessage(ax->AxisID , k , 0xEC00, 0  , 0x00000002 ,0 , 4, 2 , mgr); // Set Out1 to 1 ( OUT(1)=0x0000;)

						break;

						case VECT_Rst_OUT1:

							TML_BuildMessage(ax->AxisID , k , 0xEC00, 0  , 0x00020002 , 0 , 4, 2 , mgr); // Reset Out1 to 0 ( OUT(1)=0x0001;)

						break;

						
						case VECT_Set_OUT4:

							TML_BuildMessage(ax->AxisID , k , 0xEC00, 0  , 0x00000010 ,0 , 4, 2 , mgr); // Set Out1 to 1 ( OUT(1)=0x0000;)

						break;

						case VECT_Rst_OUT4:

							TML_BuildMessage(ax->AxisID , k , 0xEC00, 0  , 0x00100010 , 0 , 4, 2 , mgr); // Reset Out1 to 0 ( OUT(1)=0x0001;)

						break;

						case VECT_RESTART_SRV_Cmd:

							tml->xCMD = TML_RESTART;	

						break;


						case VECT_Set_FFL:

							if(tml->pState->fParam[0] > 0.0)
								d = (DINT)(tml->pState->fParam[0] * 1.0); // 
							else
								d = 0;
							
							TML_BuildMessage(ax->AxisID , k , TML_set_FFL, 0  , d , 0 , 2, 1 , mgr); //


						break;						
									
					}
				tml->pState->xCMD = 0; 
			}

				if(tml->pState)	
					tml->pState->xCmd_busy = tml->xCMD;
				
				if(mgr->hrdw[k].TXCount != mgr->hrdw[k].TXCountReadBack){					
					
					goto BUSY_USE_NEXT_CHANNEL;				

				}
				
				if(tml->xCMD !=TML_IDLE){					

					goto PROCESS_NEXT_TML;

				}
				
				/*********************/

					
			}	
			
		}
		BUSY_USE_NEXT_CHANNEL:{;}
		
	}

		
	return 1;
	
}



DINT TML_BuildMessage(UINT AxisID, UINT Channel , UINT OpCode, UINT Address, UDINT OpData1, UDINT OpData2, USINT MessageLength, USINT DataType, TML_MGR_typ* mgr){
UINT *pTxData;
USINT *pTxCount;
USINT *pTxDataSize;
UDINT *TxIdent;
UINT temp , temp1 , CANIdHigh , CANIdLow;
UDINT TxCANIdentifier_TS;



	if(!mgr)
		return -1;
	
	////  Super Trace
#ifdef KK_SUPER_TRACE

	if(OpCode == 0x0402)
		LogTxt(&LogMgr , "Axis %d Reset" , (UDINT)AxisID);

	else if(OpCode == TML_set_Param_0_int+7)
		LogTxt(&LogMgr , "Axis %d Set Tmr %d" , (UDINT)AxisID , OpData1);

	
	if((OpCode == 0x0410) || (OpCode == 0x0510))
			KK_StrangeCode_Cntr++;

	KK_BuiltMsg_Cntr++;

	if((AxisID < 32) && (Channel < 2))
		KK_Ind_BuiltMsg_Cntr[Channel][AxisID]++;

#endif

#ifdef TML_CMD_LOGS

	if(!Cmd_Log_Mgr.PauseLogging){
		
		//if((Cmd_Log_Mgr.AxisID_filter == 0)
			//|| (Cmd_Log_Mgr.AxisID_filter == AxisID)){

		if((AxisID >= 5) && (AxisID <= 8)){
			
			if(Cmd_Log_Mgr.curIndx >= 128)
				Cmd_Log_Mgr.curIndx = 0;

			Cmd_Log_Mgr.logs[Cmd_Log_Mgr.curIndx].AxisID = AxisID;
			//Cmd_Log_Mgr.logs[Cmd_Log_Mgr.curIndx].Address = Address;
			//Cmd_Log_Mgr.logs[Cmd_Log_Mgr.curIndx].Channel = Channel;
			//Cmd_Log_Mgr.logs[Cmd_Log_Mgr.curIndx].DataType = DataType;
			//Cmd_Log_Mgr.logs[Cmd_Log_Mgr.curIndx].MessageLength = MessageLength;
			Cmd_Log_Mgr.logs[Cmd_Log_Mgr.curIndx].OpCode = OpCode;
			Cmd_Log_Mgr.logs[Cmd_Log_Mgr.curIndx].OpData1 = OpData1;
			Cmd_Log_Mgr.logs[Cmd_Log_Mgr.curIndx].OpData2 = OpData2;
			Cmd_Log_Mgr.logs[Cmd_Log_Mgr.curIndx].TimeStamp = clock_ms();

			Cmd_Log_Mgr.curIndx++;

		}
	}
	
#endif

	//////////////////////////////////////////

	pTxData = mgr->hrdw[Channel].TXDataWord0;
	pTxCount = &mgr->hrdw[Channel].TXCount;
	TxIdent = &mgr->hrdw[Channel].TXIdent;
	pTxDataSize = &mgr->hrdw[Channel].TXDataSize;

	switch (DataType){

		case 1:/* Send 16-bit data*/
			*pTxData = (UINT)OpData1;		
		
		case 2:/* Send 32-bit data*/
			
			*pTxData = (UINT)OpData1;				/* LOW word */
			*(pTxData +1) = (UINT)OpData2;			/* HIGH word */
		
		case 3:/* Send 48-bit data*/
			
			*pTxData = (UINT)OpData1;				/* 1st word */
			*(pTxData +1) = (UINT)(OpData1>>16);	/* 2nd word */
			*(pTxData+2) = (UINT)OpData2;			/* 3rd word */
		
		case 4:/* Send 64-bit data*/

			*pTxData = (UINT)OpData1;				/* 1st word */
			*(pTxData +1) = (UINT)(OpData1>>16);	/* 2nd word */
			*(pTxData +2) = (UINT)OpData2;			/* 3rd word */
			*(pTxData +3) = (UINT)(OpData2>>16);	/* 4nd word */
			
	}	

	temp  = (Address & 0x01FF)| OpCode; /*Build OpCode for write variable command*/
	temp1 = (temp>>3)& 0xFFC0 ; /*Align to 29-bit and keep 7 bits from OpCode*/
	CANIdHigh = ((AxisID & 0x01FF)>>3) | temp1; /*High word of CAN identifier*/
	CANIdLow = ((AxisID & 0x01FF)<<13) | (temp & 0x01FF); /*Low word of CAN identifier*/
	
	TxCANIdentifier_TS = CANIdHigh;
	TxCANIdentifier_TS = (TxCANIdentifier_TS << 16) | CANIdLow;
	TxCANIdentifier_TS = (TxCANIdentifier_TS << 3) | 0x1;


	

	*TxIdent = TxCANIdentifier_TS;
	*pTxDataSize = MessageLength;
	(*pTxCount)++;

	//MsgInProgress[Channel] = 1;	
	return 1;
}



DINT TML_InterpretMessage(TML_MGR_typ* mgr){
USINT *pCountRegister;
UDINT *pRxCANidentifier ; 
UINT *pRxCANdata;
TML_Axis_typ *ax;
USINT SenderID;
UINT i , k;

	if(!mgr)
		return -1;

#ifdef KK_SUPER_TRACE

	KK_RsvMsg_Cntr++;

#endif

	for(i = 0; i < 2 ; i++){	

		if(mgr->hrdw[i].AxisNum > 0){
				
			
			pCountRegister = &mgr->hrdw[i].RXCount;

			if((*pCountRegister) != mgr->hrdw[i]._oldRxCount){

					mgr->hrdw[i]._oldRxCount = (*pCountRegister);

					pRxCANidentifier = &mgr->hrdw[i].RXIdent0;
					pRxCANdata 	  = &mgr->hrdw[i].RXData0Word0;


					// Find Sender //
					SenderID = (USINT)((*pRxCANidentifier) >> 3);

					ax = 0;
					for(k = 0 ; k < mgr->hrdw[i].AxisNum ; k++){

						if(mgr->pAxis[i]){
							if((mgr->pAxis[i][k].AxisID & 0x00FF)== SenderID){
								ax = &mgr->pAxis[i][k];
								break;
								
							}	
						}
							
					}
					if(!ax)
						return 0;

#ifdef KK_SUPER_TRACE					
					KK_Ind_RcvMsg_Cntr[i][k]++;
#endif
					/////////////////////////////////////////////////////////////
					// Parse message //
					// Firmware version
					if((*pRxCANidentifier) == 0xD80A0009){
						
						mgr->Firmware[i] = ((UDINT)pRxCANdata[1] + ((UDINT)pRxCANdata[0] <<16));
					}
						
					
					///////////////////////////////////////////////////////
					/*Received 32-bit variable*/
					else if((*pRxCANidentifier)& 0x800){ /* Check if 16 or 32-bit variable - bit 11 */ 

						if(pRxCANdata[0] == 0x090E){ /* Status Received */
							
							ax->Flag |= 0x0C; //bit 2 & 3  (* New Status received *)	
							ax->DriveStatusRegisterL = pRxCANdata[1];
							ax->DriveStatusRegisterH = pRxCANdata[2];
							

						}
						else{ /* General variable received. Save address to Axis structure*/
							ax->Flag |= 0x01; //bit 0 (* New Variable received *)	

							ax->VarAddress = pRxCANdata[0];
							ax->DataLow  = pRxCANdata[1];
							ax->DataHigh = pRxCANdata[2];
						
						}
					}
					////////////////////////////////////////////
					/*Received 16-bit variable*/
					else if(pRxCANdata[0] == 0x08FC){  /* MER register received */
						if(pRxCANdata[1] && 0xFFEF){ // Mask Serial comunnication error
							ax->Flag |= 0x02; //bit 1 (* New Error received *)	
							ax->DriveErrorRegister = pRxCANdata[1];
						}
					}
					/***********/
					else if(pRxCANdata[0] == 0x0863){  /* PVT status register received*/
						
						ax->Flag |= 0x10; //bit 4 (* New PVT status received *)	
						ax->PVTstatus = pRxCANdata[1];

					
					}					
					/***********/
					else {  /* other variable received*/	
						
						ax->Flag |= 0x01; //bit 0 (* New Variable received *)	
						ax->VarAddress = pRxCANdata[0];
						ax->DataLow  = pRxCANdata[1];
					
					}


			}	

		}
	}

return 1;	
}

DINT ReadValue(char **p, DINT *val){

	
	if(*p == strchr(*p , 0x0D)){
		(*p)+= 2;
		return -1;
	}	

	else {

		*val = 0;	
			
		while( (**p != 0x0D) || (**p != 0x0A)){

			
			if((**p >= '0') && (**p <= '9')){
				*val = *val<<4;
				*val += (**p) - '0';
			}	
			else if((**p >= 'A') && (**p <= 'F')){
				*val = *val<<4;
				*val += (**p) - 'A' + 10;
			}	
			else{
				(*p)++;
				break;
			}	

			(*p)++;
			
		}

						
	}
				
	(*p)++;		

return 1;
}

DINT CalcUnits(TML_typ* tml){

	if( (tml->_cfg.rev_motor != 0.0) && (tml->_cfg.loopPeriod > 0)){
		tml->_int.kPos = (tml->_cfg.units * fabsf(tml->_cfg.rev_motor)) * tml->_cfg.rev_scale ;
		tml->_int.kVel = tml->_int.kPos * tml->_cfg.loopPeriod ; 
		tml->_int.kAcc = tml->_int.kVel * tml->_cfg.loopPeriod ;
		//tml->_int.PVTPeriod = 0.02/ tml->_cfg.loopPeriod;
		tml->_int.PVTPeriod = (UINT)(tml->_cfg.PVTPeriod / tml->_cfg.loopPeriod + 0.5);
		return 1;
	}
	else
		return -1;
	
	
return 1;	
}



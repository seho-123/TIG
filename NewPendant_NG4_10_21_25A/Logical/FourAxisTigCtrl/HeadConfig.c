/********************************************************************
 * COPYRIGHT --  
 ********************************************************************
 * Package: FourAxisTigCtrl
 * File: HeadConfig.c
 * Author: ckaczkowski
 * Created: April 27, 2015
 * Directions - implemented 7 Febr 2018
   	TML_MTR_INST[i]._cfg.rev_motor - negative value change direction in Vel , Torq and Volt mode
	TML_MTR_INST[i]._cfg.rev_scale - negative value change pos and vel feedback (NOT Movement direction) and move direction in PT mode
 *******************************************************************/

#include <bur/plctypes.h>
#ifdef _DEFAULT_INCLUDES
	#include <AsDefault.h>
#endif

#include <math.h>

#ifndef _HEADCONFIG_C
#define _HEADCONFIG_C

#include <..\GlobDef.h>
#include <..\GlobDecl.h>
#include <..\..\Lib\LCDLib.c>


DINT NextDivider(DINT *in , DINT mod , BOOL dir);
DINT PickPinsNo(DINT *indx , DINT mod  );
void ParametrAssignToPointers(MASTER_typ *m  , UINT indx);


DINT ConfigureHead(MASTER_typ *m  , UINT headType );

DINT Configure_U_BEND_HP_PINS(MASTER_typ *m  , UINT headType );
DINT Configure_U_BEND_HP_ENC(MASTER_typ * m,UINT headType);
DINT Configure_OMEGA_16INCH_HP_ENCODER(MASTER_typ *m  , UINT headType );
DINT Configure_BPV_FACE_OSC(MASTER_typ * m, UINT headType);
DINT Configure_SUPER_MINI(MASTER_typ * m, UINT headType);
DINT Configure_U_BEND_HP_ENC_BEMF(MASTER_typ * m,UINT headType);
DINT Configure_BPV_F_HEAD(MASTER_typ * m, UINT headType);
DINT Configure_F_HEAD_HP_ENCODER(MASTER_typ * m,UINT headType);
DINT Configure_F_HEAD_HP_ENC_BEMF(MASTER_typ * m , UINT headType);
DINT Configure_BPV_FACE_OSC_ENC(MASTER_typ * m, UINT headType);
DINT Configure_BPV_FACE_OSC_EXP(MASTER_typ * m, UINT headType);
DINT Configure_BPV2_FACE_OSC_EXP(MASTER_typ * m, UINT headType);

DINT Configure_M_94(MASTER_typ * m, UINT headType);
DINT Configure_BPV_v2(MASTER_typ * m, UINT headType);
DINT Configure_MIG_TIG(MASTER_typ * m, UINT headType);

DINT Configure_BPV_v2_MPBO(MASTER_typ * m, UINT headType);
DINT Configure_BPV_v2_MPGH(MASTER_typ * m, UINT headType);
DINT Configure_BPV_v2_MPGV(MASTER_typ * m, UINT headType);

DINT Configure_BPV_v2_TT_BO(MASTER_typ * m, UINT headType);
DINT Configure_BPV_v2_MT_BO(MASTER_typ * m, UINT headType);

DINT Configure_BPV_v2_MT_BO_TOS(MASTER_typ * m, UINT headType);
DINT Configure_BPV_v2_TT_BO_TOS(MASTER_typ * m, UINT headType);

DINT  Configure_F_HEAD_HP_MINI_ENC(MASTER_typ * m,UINT headType);


DINT Configure_RUBIX(MASTER_typ * m, UINT headType);
DINT Configure_F_HEAD_MINI_STND(MASTER_typ * m,UINT headType);
DINT Configure_F_HEAD_MINI_OMEGA(MASTER_typ * m,UINT headType);
DINT Configure_D_HEAD_HP(MASTER_typ * m,UINT headType);

DINT Configure_CLAMSHELL_HEAD(MASTER_typ * m, UINT headType);
DINT Configure_CHERRYPOINT_BPV1_HEAD(MASTER_typ * m, UINT headType);
DINT Configure_CHERRYPOINT_BPV2_HEAD(MASTER_typ * m, UINT headType);
DINT Configure_CHERRYPOINT_MT_BP2_HEAD(MASTER_typ * m, UINT headType);



DINT  DefaultCalibr_U_BEND_HP_PINS(CurCalib_typ* defCalib);
DINT  DefaultCalibr_OMEGA_16INCH_HP_ENCODER(CurCalib_typ* defCalib);
DINT  DefaultCalibr_F_HEAD_HP_ENCODER(CurCalib_typ* defCalib);
DINT  DefaultCalibr_BPV_F_HEAD(CurCalib_typ* defCalib);

DINT Configure_BPV_v2_MT(MASTER_typ * m, UINT headType);
DINT Configure_BPV_V1_MT(MASTER_typ * m, UINT headType);

DINT  DefaultCalibr_F_HEAD_HP_MINI_ENC(CurCalib_typ* defCalib);
DINT  DefaultCalibr_U_BEND_HP_ENC(CurCalib_typ* defCalib);
DINT  DefaultCalibr_BPV_FACE_OSC(CurCalib_typ* defCalib);
DINT  DefaultCalibr_SUPER_MINI(CurCalib_typ* defCalib);
DINT  DefaultCalibr_U_BEND_HP_ENC_BEMF(CurCalib_typ* defCalib);
DINT  DefaultCalibr_F_HEAD_HP_ENC_BEMF(CurCalib_typ* defCalib);
DINT  DefaultCalibr_M_94(CurCalib_typ* defCalib);
DINT  DefaultCalibr_BPV_v2(CurCalib_typ* defCalib);
DINT  DefaultCalibr_BPV_v2_MPBO(CurCalib_typ* defCalib);
DINT  DefaultCalibr_BPV_v2_MPGH(CurCalib_typ* defCalib);
DINT  DefaultCalibr_BPV_v2_MPGV(CurCalib_typ* defCalib);

DINT  DefaultCalibr_BPV_v2_TT_BO(CurCalib_typ* defCalib);
DINT  DefaultCalibr_BPV_v2_MT_BO(CurCalib_typ* defCalib);

DINT  DefaultCalibr_BPV_v2_MT_BO_TOS(CurCalib_typ* defCalib);
DINT  DefaultCalibr_BPV_v2_TT_BO_TOS(CurCalib_typ* defCalib);

DINT  DefaultCalibr_RUBIX(CurCalib_typ* defCalib);
DINT  DefaultCalibr_F_HEAD_MINI_STND(CurCalib_typ* defCalib);
DINT  DefaultCalibr_F_HEAD_MINI_OMEGA(CurCalib_typ* defCalib);
DINT  DefaultCalibr_D_HEAD_HP(CurCalib_typ* defCalib);

DINT  DefaultCalibr_BPV_v2_MT(CurCalib_typ* defCalib);
DINT  DefaultCalibr_BPV_V1_MT(CurCalib_typ* defCalib);

DINT  DefaultCalibr_CLAMSHELL_HEAD(CurCalib_typ* defCalib);
DINT  DefaultCalibr_CHERRYPOINT_BPV1_HEAD(CurCalib_typ* defCalib);
DINT  DefaultCalibr_CHERRYPOINT_BPV2_HEAD(CurCalib_typ* defCalib);
DINT  DefaultCalibr_MIG_TIG(CurCalib_typ* defCalib);





float Gen_one;

DINT ConfigureHead(MASTER_typ *m  , UINT headType ){
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;


	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;

	///
	if(curCalib->GenSetup[SETUP_POLE_ELEMENTS] < 2)
		curCalib->GenSetup[SETUP_POLE_ELEMENTS] = 2;

	else if(curCalib->GenSetup[SETUP_POLE_ELEMENTS] > 32)
		curCalib->GenSetup[SETUP_POLE_ELEMENTS] = 32;
	/////////

	for(i = 0 ; i < PROCESS_NUM ; i++)
		Process[i].ConfigReady = 0;

	for(i = 0 ; i < TML_SERVO_NUM ; i++){
		TML_MTR_INST[i].pState = 0;
		TML_MTR_INST[i]._cfg.NotAutoDownload = 0; // Default - auto download setup
		TML_MTR_INST[i]._cfg.MtrType = 0; // Default - DC Motor
	}	

	for(i=0 ; i < VECTORS_NUM; i++){

		VectorStateMach[i].Indx = i;
	}

	//// This is only to not forget Synch Configuration
	WIRE_Param_Set[0].pSynchMode = &WFSynchMode;	
	WIRE_Param_Set[0].pSynchClock = &SynchClckToWF;
	
	WIRE_Param_Set[1].pSynchMode = &WPSynchMode;	
	WIRE_Param_Set[1].pSynchClock = &SynchClckToWP;

	TVL_ROT_Param_Set[0].pSynchMode = &TVLSynchMode;
	TVL_ROT_Param_Set[0].pSynchClock = &SynchClckToTVL;

	


	///////////   NEW HEAD Configuration - will be from file parser   /////////////////////	
	switch(headType){	
		/************ 0 **********/
		case U_BEND_HP_PINS:

			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
			m->pCfg->HeadCfg.TVL.DC_Indx = 0;

			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			m->pCfg->HeadCfg.TVL.EncPerTick = 160;
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 / 4.0; // 1/4"

			
			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX; // Must be even is disabled
			
			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			

			
		break;

		/************ 1 ************/	
		case U_BEND_HP_ENC:
		
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
			m->pCfg->HeadCfg.TVL.DC_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			m->pCfg->HeadCfg.TVL.EncPerTick = 200; // (4000 * 4) / (10 * 1/4") * 32 ( becaue 1/32" is one tick")
			m->pCfg->HeadCfg.TVL.PinsPerRot = 640;  // 80 pins , 1/4" per pin	
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /32.0; // 1/32"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;						
					
			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF_1;
			m->pCfg->HeadCfg.WF.DC_A_Indx = DC_AX_WF;
			m->pCfg->HeadCfg.WF.DC_B_Indx = DC_AX_WF_1;
			

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP_1;	
			m->pCfg->HeadCfg.WP.DC_A_Indx = DC_AX_WP;
			m->pCfg->HeadCfg.WP.DC_B_Indx = DC_AX_WP_1;			
			

			// OSC 
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 5;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 1;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX; // Must be even is disabled

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

			// frame size if zero always speed factor is 1.0
			m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;
		
			Configure_U_BEND_HP_ENC(m , U_BEND_HP_ENC);
			DefaultCalibr_U_BEND_HP_ENC(m->pDefaultCalib);

			
		break;

		/************ 2 ************/	
		case F_HEAD_HP_ENCODER:
			
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
			m->pCfg->HeadCfg.TVL.DC_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			m->pCfg->HeadCfg.TVL.EncPerTick = 38;  // 1/16 inch 
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /16.0; // 1/16"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF_1;
			m->pCfg->HeadCfg.WF.DC_A_Indx = DC_AX_WF;
			m->pCfg->HeadCfg.WF.DC_B_Indx = DC_AX_WF_1;
			

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP_1;	
			m->pCfg->HeadCfg.WP.DC_A_Indx = DC_AX_WP;
			m->pCfg->HeadCfg.WP.DC_B_Indx = DC_AX_WP_1;			
			
			// OSC
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 5.0;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 1;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			
			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX; // Must be even is disabled

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used
			
			
			/////////////////////////////////////////////////////	

			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;
			
			Configure_F_HEAD_HP_ENCODER(m , F_HEAD_HP_ENCODER);			
			DefaultCalibr_F_HEAD_HP_ENCODER(m->pDefaultCalib);			
			
			
		break;

		/************ 3 ************/	
		/************ 29 ************/
		case BPV_F_HEAD:
		case BPV_v1_MT:	
			
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;

			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
						
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			//m->pCfg->HeadCfg.TVL.EncPerTick  = 5085;  //  5084.8094458543457034129135792358	// For 1/32 "
			m->pCfg->HeadCfg.TVL.EncPerTick  = 5088; // aby bylo 32 razy
			m->pCfg->HeadCfg.TVL.EncPerTick_SecEnc = 159; // (4000 * 4) / (1" * Pi * 32)
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration	
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /32.0; // 1/32"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF_1;			
			m->pCfg->HeadCfg.WF.TML_A_Indx = TML_AX_WF;
			m->pCfg->HeadCfg.WF.TML_B_Indx = TML_AX_WF_1;

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP_1;			
			m->pCfg->HeadCfg.WP.TML_A_Indx = TML_AX_WP;
			m->pCfg->HeadCfg.WP.TML_B_Indx = TML_AX_WP_1;

			// OSC
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;
			
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 4;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			// WRST
			m->pCfg->HeadCfg.WRST.PROC_Indx = PROC_WRST;
			m->pCfg->HeadCfg.WRST.VECT_A_Indx = VECT_WRST;
			m->pCfg->HeadCfg.WRST.VECT_B_Indx = VECT_WRST;			
			m->pCfg->HeadCfg.WRST.TML_A_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.TML_B_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.Limits_Harcoded = 0;		

			m->pCfg->HeadCfg.WRST.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.WRST.BtnJog_Mode = BTN_JOG_MODE_SINGLE;		

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 1;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX;
			m->pCfg->HeadCfg.INDX.VECT_A_Indx = VECT_INDX_1;
			m->pCfg->HeadCfg.INDX.VECT_B_Indx = VECT_INDX_2;			
			m->pCfg->HeadCfg.INDX.DC_A_Indx = DC_INDX_1;
			m->pCfg->HeadCfg.INDX.DC_B_Indx = DC_INDX_2;
			m->pCfg->HeadCfg.INDX.BtnJog_Gain = 1.0;

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

			/////////////////////////////////////////////////////	

			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;

			switch(headType){
		
				case BPV_F_HEAD:
					Configure_BPV_F_HEAD(m , BPV_F_HEAD);			
					DefaultCalibr_BPV_F_HEAD(m->pDefaultCalib);
				break;

				case BPV_v1_MT:
					Configure_BPV_V1_MT(m , BPV_v1_MT);			
					DefaultCalibr_BPV_V1_MT(m->pDefaultCalib);
				break;
			}				
			
		break;

		/************ 4 ************/	
		case OMEGA_16INCH_HP_ENCODER:

			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
		
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
			m->pCfg->HeadCfg.TVL.DC_Indx = 0;

			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			m->pCfg->HeadCfg.TVL.PinsPerRot  = 1024;
			m->pCfg->HeadCfg.TVL.EncPerTick = 10312656 * 4 / m->pCfg->HeadCfg.TVL.PinsPerRot  ;
			curCalib->GenSetup[SETUP_PIN_PER_ROT] = m->pCfg->HeadCfg.TVL.PinsPerRot;
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /16.0; // ????????????????????????

			
			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX; // Must be even is disabled

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used
									
		break;

		/************ 5 ************/	
		case OMEGA_10INCH_HP_ENCODER:

			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
		
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
			m->pCfg->HeadCfg.TVL.DC_Indx = 0;

			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			m->pCfg->HeadCfg.TVL.PinsPerRot  = 1024;
			m->pCfg->HeadCfg.TVL.EncPerTick = 10312656 * 4 / m->pCfg->HeadCfg.TVL.PinsPerRot  ;
			curCalib->GenSetup[SETUP_PIN_PER_ROT] = m->pCfg->HeadCfg.TVL.PinsPerRot;			
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /16.0; // ????????????????????????

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX; // Must be even is disabled

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used
					
		break;

		/************ 6 ************/	
		case OMEGA_8INCH_HP_ENCODER:

			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
		
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
			m->pCfg->HeadCfg.TVL.DC_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			m->pCfg->HeadCfg.TVL.PinsPerRot  = 1024;
			m->pCfg->HeadCfg.TVL.EncPerTick = 10312656 * 4 / m->pCfg->HeadCfg.TVL.PinsPerRot  ;
			curCalib->GenSetup[SETUP_PIN_PER_ROT] = m->pCfg->HeadCfg.TVL.PinsPerRot;			
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /16.0; // ????????????????????????

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX; // Must be even is disabled

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used
		
		break;

		/************ 7 ************/	
		case F_HEAD_HP_MINI_ENC:				
		

			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
			m->pCfg->HeadCfg.TVL.DC_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			m->pCfg->HeadCfg.TVL.EncPerTick = 38;  // 1/16 inch 
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /16.0; // 1/16"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			
					
			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.DC_A_Indx = DC_AX_WF;
			m->pCfg->HeadCfg.WF.DC_B_Indx = DC_AX_WF;
			

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP;	
			m->pCfg->HeadCfg.WP.DC_A_Indx = DC_AX_WP;
			m->pCfg->HeadCfg.WP.DC_B_Indx = DC_AX_WP;			
			

			// OSC 
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 5;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 1;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX; // Must be even is disabled

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

			//////////////////////
			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;
		
			Configure_F_HEAD_HP_MINI_ENC(m , F_HEAD_HP_MINI_ENC);
			DefaultCalibr_F_HEAD_HP_MINI_ENC(m->pDefaultCalib);
	
		break;

		
		/************ SUPER_MINI - 8 ************/	
		case SUPER_MINI:
			
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;

				
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = VECT_TVL+1;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = TML_AX_TVL+1;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
						
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = -1;	
			m->pCfg->HeadCfg.TVL.EncPerTick  = (1024 * 4 * (300564/1300) * (36.0/33.0)) / (1.25 * M_PI * 32); //5088; 
			m->pCfg->HeadCfg.TVL.EncPerTick_SecEnc = 255; // (4000 * 4) / (0.625 * Pi * 32)
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration	
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /32.0; // 1/32"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF;			
			m->pCfg->HeadCfg.WF.TML_A_Indx = TML_AX_WF;
			m->pCfg->HeadCfg.WF.TML_B_Indx = TML_AX_WF;

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP;			
			m->pCfg->HeadCfg.WP.TML_A_Indx = TML_AX_WP;
			m->pCfg->HeadCfg.WP.TML_B_Indx = TML_AX_WP;

			// OSC
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;
			
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 4;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			// WRST
			m->pCfg->HeadCfg.WRST.PROC_Indx = PROC_WRST;
			m->pCfg->HeadCfg.WRST.VECT_A_Indx = VECT_WRST;
			m->pCfg->HeadCfg.WRST.VECT_B_Indx = VECT_WRST;			
			m->pCfg->HeadCfg.WRST.TML_A_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.TML_B_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.Limits_Harcoded = 0;		

			m->pCfg->HeadCfg.WRST.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.WRST.BtnJog_Mode = BTN_JOG_MODE_SINGLE;		

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 1;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX;
			m->pCfg->HeadCfg.INDX.VECT_A_Indx = VECT_INDX_1;
			m->pCfg->HeadCfg.INDX.VECT_B_Indx = VECT_INDX_2;			
			m->pCfg->HeadCfg.INDX.DC_A_Indx = DC_INDX_1;
			m->pCfg->HeadCfg.INDX.DC_B_Indx = DC_INDX_2;
			m->pCfg->HeadCfg.INDX.BtnJog_Gain = 1.0;

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = VECT_OSC + 1;
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = VECT_WF + 1;

			/////////////////////////////////////////////////////	

			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;
			
			Configure_SUPER_MINI(m , SUPER_MINI);			
			DefaultCalibr_SUPER_MINI(m->pDefaultCalib);
			
		break;

		/************ BPV_FACE_OSC - 9  ************/	
		case BPV_FACE_OSC:
			
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
						
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			//m->pCfg->HeadCfg.TVL.EncPerTick  = 5085;  //  5084.8094458543457034129135792358	// For 1/32 "
			m->pCfg->HeadCfg.TVL.EncPerTick  = 5088; // aby bylo 32 razy
			m->pCfg->HeadCfg.TVL.EncPerTick_SecEnc = 159; // (4000 * 4) / (1" * Pi * 32)
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration	
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /32.0; // 1/32"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF_1;			
			m->pCfg->HeadCfg.WF.TML_A_Indx = TML_AX_WF;
			m->pCfg->HeadCfg.WF.TML_B_Indx = TML_AX_WF_1;

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP_1;			
			m->pCfg->HeadCfg.WP.TML_A_Indx = TML_AX_WP;
			m->pCfg->HeadCfg.WP.TML_B_Indx = TML_AX_WP_1;

			// OSC
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;
			
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 12;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			// WRST
			m->pCfg->HeadCfg.WRST.PROC_Indx = PROC_WRST;
			m->pCfg->HeadCfg.WRST.VECT_A_Indx = VECT_WRST;
			m->pCfg->HeadCfg.WRST.VECT_B_Indx = VECT_WRST;			
			m->pCfg->HeadCfg.WRST.TML_A_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.TML_B_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.Limits_Harcoded = 0;		

			m->pCfg->HeadCfg.WRST.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.WRST.BtnJog_Mode = BTN_JOG_MODE_SINGLE;		

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 1;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX;
			m->pCfg->HeadCfg.INDX.VECT_A_Indx = VECT_INDX_1;
			m->pCfg->HeadCfg.INDX.VECT_B_Indx = VECT_INDX_2;			
			m->pCfg->HeadCfg.INDX.DC_A_Indx = DC_INDX_1;
			m->pCfg->HeadCfg.INDX.DC_B_Indx = DC_INDX_2;
			m->pCfg->HeadCfg.INDX.BtnJog_Gain = 1.0;

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

			/////////////////////////////////////////////////////	

			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;
			
			Configure_BPV_FACE_OSC(m , BPV_FACE_OSC);			
			DefaultCalibr_BPV_FACE_OSC(m->pDefaultCalib);
			
		break;

		
		/************ 10 ************/	
		case U_BEND_HP_ENC_BEMF:
		
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
			m->pCfg->HeadCfg.TVL.DC_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			m->pCfg->HeadCfg.TVL.EncPerTick = 200; // (4000 * 4) / (10 * 1/4") * 32 ( becaue 1/32" is one tick")
			m->pCfg->HeadCfg.TVL.PinsPerRot = 640;	// 80 pins , 1/4" per pin	
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /32.0; // 1/32"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE; 					
					
			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF_1;
			m->pCfg->HeadCfg.WF.DC_A_Indx = DC_AX_WF;
			m->pCfg->HeadCfg.WF.DC_B_Indx = DC_AX_WF_1;
			

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP_1;	
			m->pCfg->HeadCfg.WP.DC_A_Indx = DC_AX_WP;
			m->pCfg->HeadCfg.WP.DC_B_Indx = DC_AX_WP_1; 		
			

			// OSC 
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 5;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 1;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX; // Must be even is disabled

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

			// frame size if zero always speed factor is 1.0
			m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;
		
			Configure_U_BEND_HP_ENC_BEMF(m , U_BEND_HP_ENC_BEMF);
			DefaultCalibr_U_BEND_HP_ENC_BEMF(m->pDefaultCalib);

			
		break;

		/************ 11 ************/	
		case F_HEAD_HP_ENC_BEMF:

			
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
			m->pCfg->HeadCfg.TVL.DC_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;
			m->pCfg->HeadCfg.TVL.EncPerTick = 38;  // 1/16 inch 
			m->pCfg->HeadCfg.TVL.EncPerTick_SecEnc = 38;
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /16.0; // 1/16"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF_1;
			m->pCfg->HeadCfg.WF.DC_A_Indx = DC_AX_WF;
			m->pCfg->HeadCfg.WF.DC_B_Indx = DC_AX_WF_1;
			

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP_1;	
			m->pCfg->HeadCfg.WP.DC_A_Indx = DC_AX_WP;
			m->pCfg->HeadCfg.WP.DC_B_Indx = DC_AX_WP_1;			
			
			// OSC
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 5.0;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 1;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			
			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX; // Must be even is disabled

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used
			
			
			/////////////////////////////////////////////////////	

			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;
			
			Configure_F_HEAD_HP_ENC_BEMF(m , F_HEAD_HP_ENCODER);			
			DefaultCalibr_F_HEAD_HP_ENC_BEMF(m->pDefaultCalib);			
			
			
		break;

		/************ BPV_FACE_OSC_ENC - 12  ************/	
		case BPV_FACE_OSC_ENC:
			
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
						
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			//m->pCfg->HeadCfg.TVL.EncPerTick  = 5085;  //  5084.8094458543457034129135792358	// For 1/32 "
			m->pCfg->HeadCfg.TVL.EncPerTick  = 5088; // aby bylo 32 razy
			m->pCfg->HeadCfg.TVL.EncPerTick_SecEnc = 159; // (4000 * 4) / (1" * Pi * 32)
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration	
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /32.0; // 1/32"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF_1;			
			m->pCfg->HeadCfg.WF.TML_A_Indx = TML_AX_WF;
			m->pCfg->HeadCfg.WF.TML_B_Indx = TML_AX_WF_1;

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP_1;			
			m->pCfg->HeadCfg.WP.TML_A_Indx = TML_AX_WP;
			m->pCfg->HeadCfg.WP.TML_B_Indx = TML_AX_WP_1;

			// OSC
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;
			
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 12;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			// WRST
			m->pCfg->HeadCfg.WRST.PROC_Indx = PROC_WRST;
			m->pCfg->HeadCfg.WRST.VECT_A_Indx = VECT_WRST;
			m->pCfg->HeadCfg.WRST.VECT_B_Indx = VECT_WRST;			
			m->pCfg->HeadCfg.WRST.TML_A_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.TML_B_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.Limits_Harcoded = 0;		

			m->pCfg->HeadCfg.WRST.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.WRST.BtnJog_Mode = BTN_JOG_MODE_SINGLE;		

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 1;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX;
			m->pCfg->HeadCfg.INDX.VECT_A_Indx = VECT_INDX_1;
			m->pCfg->HeadCfg.INDX.VECT_B_Indx = VECT_INDX_2;			
			m->pCfg->HeadCfg.INDX.DC_A_Indx = DC_INDX_1;
			m->pCfg->HeadCfg.INDX.DC_B_Indx = DC_INDX_2;
			m->pCfg->HeadCfg.INDX.BtnJog_Gain = 1.0;

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

			/////////////////////////////////////////////////////	

			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;
			
			Configure_BPV_FACE_OSC_ENC(m , BPV_FACE_OSC_ENC);			
			DefaultCalibr_BPV_FACE_OSC(m->pDefaultCalib);
			
		break;

		/************ BPV_FACE_OSC_EXP - 13  ************/	
		case BPV_FACE_OSC_EXP:
		/************ BPV2_FACE_OSC_EXP - 27  ************/	
		case BPV2_FACE_OSC_EXP:	
			
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
						
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			//m->pCfg->HeadCfg.TVL.EncPerTick  = 5085;  //  5084.8094458543457034129135792358	// For 1/32 "
			m->pCfg->HeadCfg.TVL.EncPerTick  = 5088; // aby bylo 32 razy
			m->pCfg->HeadCfg.TVL.EncPerTick_SecEnc = 159; // (4000 * 4) / (1" * Pi * 32)
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration	
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /32.0; // 1/32"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF_1;			
			m->pCfg->HeadCfg.WF.TML_A_Indx = TML_AX_WF;
			m->pCfg->HeadCfg.WF.TML_B_Indx = TML_AX_WF_1;

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP_1;			
			m->pCfg->HeadCfg.WP.TML_A_Indx = TML_AX_WP;
			m->pCfg->HeadCfg.WP.TML_B_Indx = TML_AX_WP_1;

			// OSC
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;
			
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 12;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			// WRST
			m->pCfg->HeadCfg.WRST.PROC_Indx = PROC_WRST;
			m->pCfg->HeadCfg.WRST.VECT_A_Indx = VECT_WRST;
			m->pCfg->HeadCfg.WRST.VECT_B_Indx = VECT_WRST;			
			m->pCfg->HeadCfg.WRST.TML_A_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.TML_B_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.Limits_Harcoded = 0;		

			m->pCfg->HeadCfg.WRST.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.WRST.BtnJog_Mode = BTN_JOG_MODE_SINGLE;		

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 1;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX;
			m->pCfg->HeadCfg.INDX.VECT_A_Indx = VECT_INDX_1;
			m->pCfg->HeadCfg.INDX.VECT_B_Indx = VECT_INDX_2;			
			m->pCfg->HeadCfg.INDX.DC_A_Indx = DC_INDX_1;
			m->pCfg->HeadCfg.INDX.DC_B_Indx = DC_INDX_2;
			m->pCfg->HeadCfg.INDX.BtnJog_Gain = 1.0;

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

			/////////////////////////////////////////////////////	

			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;


			switch(headType){

				case BPV_FACE_OSC_EXP:					
					Configure_BPV_FACE_OSC_EXP(m , BPV_FACE_OSC_EXP);
				break;

				case BPV2_FACE_OSC_EXP:					
					Configure_BPV2_FACE_OSC_EXP(m , BPV2_FACE_OSC_EXP);
				break;			
			}
			
			
			
			DefaultCalibr_BPV_FACE_OSC(m->pDefaultCalib);
			
		break;

		/************ 14 ************/	
		case M_94:
			
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
						
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			//m->pCfg->HeadCfg.TVL.EncPerTick  = 5085;  //  5084.8094458543457034129135792358	// For 1/32 "
			m->pCfg->HeadCfg.TVL.EncPerTick  = 5088; // aby bylo 32 razy
			m->pCfg->HeadCfg.TVL.EncPerTick_SecEnc = 159; // (4000 * 4) / (1" * Pi * 32)
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration	
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /32.0; // 1/32"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF_1;
			m->pCfg->HeadCfg.WF.DC_A_Indx = DC_AX_WF;
			m->pCfg->HeadCfg.WF.DC_B_Indx = DC_AX_WF_1;
			

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP_1;	
			m->pCfg->HeadCfg.WP.DC_A_Indx = DC_AX_WP;
			m->pCfg->HeadCfg.WP.DC_B_Indx = DC_AX_WP_1;			
			

			// OSC
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;
			
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 4;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			// WRST
			m->pCfg->HeadCfg.WRST.PROC_Indx = PROC_WRST;
			m->pCfg->HeadCfg.WRST.VECT_A_Indx = VECT_WRST;
			m->pCfg->HeadCfg.WRST.VECT_B_Indx = VECT_WRST;			
			m->pCfg->HeadCfg.WRST.TML_A_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.TML_B_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.Limits_Harcoded = 0;		

			m->pCfg->HeadCfg.WRST.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.WRST.BtnJog_Mode = BTN_JOG_MODE_SINGLE;		

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 1;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX;
			m->pCfg->HeadCfg.INDX.VECT_A_Indx = VECT_INDX_1;
			m->pCfg->HeadCfg.INDX.VECT_B_Indx = VECT_INDX_2;			
			m->pCfg->HeadCfg.INDX.DC_A_Indx = DC_INDX_1;
			m->pCfg->HeadCfg.INDX.DC_B_Indx = DC_INDX_2;
			m->pCfg->HeadCfg.INDX.BtnJog_Gain = 1.0;

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

			/////////////////////////////////////////////////////	

			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;
			
			Configure_M_94(m , M_94);			
			DefaultCalibr_M_94(m->pDefaultCalib);
			
		break;


///////////////////////////////////////
///////  BPV Ver 2 Heads		
//////////////////////////////////////

		/************ BPV_v2 - 15 ************/	
		/************ BPV_v2_TT_BO - 19 ************/	
		case BPV_v2:
		case BPV_v2_Video:
		case BPV_v2_TT_BO:
		case MIG_TIG_HEAD:	
					
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = VECT_TVL;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = TML_AX_TVL;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;

			

			// This is like BPV
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			//m->pCfg->HeadCfg.TVL.EncPerTick  = 5085;  //  5084.8094458543457034129135792358	// For 1/32 "
			m->pCfg->HeadCfg.TVL.EncPerTick  = 5088; // aby bylo 32 razy
			m->pCfg->HeadCfg.TVL.EncPerTick_SecEnc = 159; // (4000 * 4) / (1" * Pi * 32)
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration	
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /32.0; // 1/32"
			/////////////////////

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			

			// I took it from BPV Head
			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF_1;			
			m->pCfg->HeadCfg.WF.TML_A_Indx = TML_AX_WF;
			m->pCfg->HeadCfg.WF.TML_B_Indx = TML_AX_WF_1;

			m->pCfg->HeadCfg.WF.VECT_Aux_A_Indx = VECT_AUX_WF;
			m->pCfg->HeadCfg.WF.VECT_Aux_B_Indx = VECT_AUX_WF_1;			
			m->pCfg->HeadCfg.WF.TML_Aux_A_Indx = TML_AUX_AX_WF;
			m->pCfg->HeadCfg.WF.TML_Aux_B_Indx = TML_AUX_AX_WF_1;

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP_1;			
			m->pCfg->HeadCfg.WP.TML_A_Indx = TML_AX_WP;
			m->pCfg->HeadCfg.WP.TML_B_Indx = TML_AX_WP_1;

			// OSC
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;
			
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 4;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			// WRST
			m->pCfg->HeadCfg.WRST.PROC_Indx = PROC_WRST;
			m->pCfg->HeadCfg.WRST.VECT_A_Indx = VECT_WRST;
			m->pCfg->HeadCfg.WRST.VECT_B_Indx = VECT_WRST;			
			m->pCfg->HeadCfg.WRST.TML_A_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.TML_B_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.Limits_Harcoded = 0;		

			m->pCfg->HeadCfg.WRST.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.WRST.BtnJog_Mode = BTN_JOG_MODE_SINGLE;		

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 1;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			
			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX;
			m->pCfg->HeadCfg.INDX.VECT_A_Indx = VECT_INDX_1;
			m->pCfg->HeadCfg.INDX.VECT_B_Indx = VECT_INDX_2;			
			m->pCfg->HeadCfg.INDX.TML_A_Indx = TML_AX_INDX;
			m->pCfg->HeadCfg.INDX.TML_B_Indx = TML_AX_INDX_1;
			m->pCfg->HeadCfg.INDX.BtnJog_Gain = 1.0;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;


			if(headType != MIG_TIG_HEAD){

				// WB
				m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
				m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
				
				m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
				m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

				
				// Lamp On Off
				m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = VECT_OSC + 1;
				m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = VECT_INDX_1 + 1;

			}
		

			/////////////////////////////////////////////////////	

			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;

			switch(headType){

				case BPV_v2:
				case BPV_v2_Video:	

					Configure_BPV_v2(m , headType);			
					DefaultCalibr_BPV_v2(m->pDefaultCalib);

				break;

				
				case BPV_v2_TT_BO:

					Configure_BPV_v2_TT_BO(m , headType);			
					DefaultCalibr_BPV_v2_TT_BO(m->pDefaultCalib);


				break;		

				case MIG_TIG_HEAD:
					
					m->pCfg->HeadCfg.OSC.BtnJog_Gain = 20.0; 

					m->pCfg->HeadCfg.INDX.VECT_B_Indx = 0;			
					m->pCfg->HeadCfg.INDX.TML_B_Indx = 0;

					m->pCfg->HeadCfg.WF.VECT_B_Indx = m->pCfg->HeadCfg.WF.VECT_A_Indx;			
					m->pCfg->HeadCfg.WF.TML_B_Indx = m->pCfg->HeadCfg.WF.TML_A_Indx;

					m->pCfg->HeadCfg.WP.VECT_B_Indx = m->pCfg->HeadCfg.WP.VECT_A_Indx;			
					m->pCfg->HeadCfg.WP.TML_B_Indx = m->pCfg->HeadCfg.WP.TML_A_Indx;
			 
					
					Configure_MIG_TIG(m , headType);
					DefaultCalibr_MIG_TIG(m->pDefaultCalib);


				break;


			}
			
		break;

		
		/************ BPV_v2_MPBO - 16 ************/ 
		/************ BPV_v2_MT_BO - 20 ************/ 
		/************ BPV_v2_MT - 28 ************/
		case BPV_v2_MPBO:
		case BPV_v2_MT_BO:
		case BPV_v2_MT:
						
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = VECT_TVL;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = TML_AX_TVL;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;

			// This is like BPV
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			

			
			//m->pCfg->HeadCfg.TVL.EncNominator = 39546 * 1024 * 4 / (1.875 * M_PI * 32 ) ;
			//m->pCfg->HeadCfg.TVL.EncDenominator = 540;
			//m->pCfg->HeadCfg.TVL.EncPerTick = (DINT)ceil(m->pCfg->HeadCfg.TVL.EncNominator / m->pCfg->HeadCfg.TVL.EncDenominator );

			m->pCfg->HeadCfg.TVL.EncScale = 540.0 *  (1.875 * M_PI * 32 ) / (39546 * 1024 * 4);
			m->pCfg->HeadCfg.TVL.EncPerTick = (DINT)ceil(1.0/m->pCfg->HeadCfg.TVL.EncScale);
			
			m->pCfg->HeadCfg.TVL.EncPerTick_SecEnc = 159; // (4000 * 4) / (1" * Pi * 32)
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration	
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /32.0; // 1/32"
			/////////////////////

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			
			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF_1;			
			m->pCfg->HeadCfg.WF.TML_A_Indx = TML_AX_WF;
			m->pCfg->HeadCfg.WF.TML_B_Indx = TML_AX_WF_1;

			m->pCfg->HeadCfg.WF.VECT_Aux_A_Indx = VECT_AUX_WF;
			m->pCfg->HeadCfg.WF.VECT_Aux_B_Indx = VECT_AUX_WF_1;			
			m->pCfg->HeadCfg.WF.TML_Aux_A_Indx = TML_AUX_AX_WF;
			m->pCfg->HeadCfg.WF.TML_Aux_B_Indx = TML_AUX_AX_WF_1;

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP_1;			
			m->pCfg->HeadCfg.WP.TML_A_Indx = TML_AX_WP;
			m->pCfg->HeadCfg.WP.TML_B_Indx = TML_AX_WP_1;

			// OSC
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;
			
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 4;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			// WRST
			m->pCfg->HeadCfg.WRST.PROC_Indx = PROC_WRST;
			m->pCfg->HeadCfg.WRST.VECT_A_Indx = VECT_WRST;
			m->pCfg->HeadCfg.WRST.VECT_B_Indx = VECT_WRST;			
			m->pCfg->HeadCfg.WRST.TML_A_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.TML_B_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.Limits_Harcoded = 0;		

			//m->pCfg->HeadCfg.WRST.BtnJog_Gain = 24.0;	
			m->pCfg->HeadCfg.WRST.BtnJog_Gain = 0.24;	
			m->pCfg->HeadCfg.WRST.BtnJog_Mode = BTN_JOG_MODE_SINGLE;		

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 1;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			
			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX;
			m->pCfg->HeadCfg.INDX.VECT_A_Indx = VECT_INDX_1;
			m->pCfg->HeadCfg.INDX.VECT_B_Indx = VECT_INDX_2;			
			m->pCfg->HeadCfg.INDX.TML_A_Indx = TML_AX_INDX;
			m->pCfg->HeadCfg.INDX.TML_B_Indx = TML_AX_INDX_1;
			m->pCfg->HeadCfg.INDX.BtnJog_Gain = 1.0;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			
			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = VECT_OSC + 1;
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = VECT_INDX_1 + 1;


			/////////////////////////////////////////////////////	

			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;

			switch(headType){
		
				case BPV_v2_MPBO:

					Configure_BPV_v2_MPBO(m , headType);			
					DefaultCalibr_BPV_v2_MPBO(m->pDefaultCalib);

				break;

				case BPV_v2_MT:

					Configure_BPV_v2_MT(m , headType);			
					DefaultCalibr_BPV_v2_MT(m->pDefaultCalib);


				break;

				case BPV_v2_MT_BO:
					
					Configure_BPV_v2_MT_BO(m , headType);			
					DefaultCalibr_BPV_v2_MT_BO(m->pDefaultCalib);

				break;

			}		
			
		break;

		/************ BPV_v2_MPGH - 17 ************/ 
		/************ BPV_v2_TT_BO_TOS - 21 ************/ 
		case BPV_v2_MPGH:
		case BPV_v2_TT_BO_TOS:	
			
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
				
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;

			// This is like BPV
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			
			
			//m->pCfg->HeadCfg.TVL.EncNominator = (75 * 50)  * 1024 * 4 / (0.625 * M_PI * 32 ) ;
			//m->pCfg->HeadCfg.TVL.EncDenominator = -19;
			//m->pCfg->HeadCfg.TVL.EncPerTick  = (DINT)ceil(m->pCfg->HeadCfg.TVL.EncNominator/m->pCfg->HeadCfg.TVL.EncDenominator); 

			m->pCfg->HeadCfg.TVL.EncScale = -19.0 *  (0.625 * M_PI * 32 ) / ((75 * 50)  * 1024 * 4) ;
			m->pCfg->HeadCfg.TVL.EncPerTick = (DINT)ceil(1.0/m->pCfg->HeadCfg.TVL.EncScale);
			
			m->pCfg->HeadCfg.TVL.EncPerTick_SecEnc = 159; // (4000 * 4) / (1" * Pi * 32)
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration	
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /32.0; // 1/32"
			/////////////////////

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			
			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF;			
			m->pCfg->HeadCfg.WF.TML_A_Indx = TML_AX_WF;
			m->pCfg->HeadCfg.WF.TML_B_Indx = TML_AX_WF;

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP;			
			m->pCfg->HeadCfg.WP.TML_A_Indx = TML_AX_WP;
			m->pCfg->HeadCfg.WP.TML_B_Indx = TML_AX_WP;

			// OSC
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;
			
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 9;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			// WRST
			m->pCfg->HeadCfg.WRST.PROC_Indx = PROC_WRST;
			m->pCfg->HeadCfg.WRST.VECT_A_Indx = VECT_WRST;
			m->pCfg->HeadCfg.WRST.VECT_B_Indx = VECT_WRST;			
			m->pCfg->HeadCfg.WRST.TML_A_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.TML_B_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.Limits_Harcoded = 0;		

			//m->pCfg->HeadCfg.WRST.BtnJog_Gain = 24.0; 
			m->pCfg->HeadCfg.WRST.BtnJog_Gain = 0.24;	
			m->pCfg->HeadCfg.WRST.BtnJog_Mode = BTN_JOG_MODE_SINGLE;		

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 1;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			
			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX;
			m->pCfg->HeadCfg.INDX.VECT_A_Indx = VECT_INDX_1;
			m->pCfg->HeadCfg.INDX.VECT_B_Indx = 0;			
			m->pCfg->HeadCfg.INDX.TML_A_Indx = TML_AX_INDX;
			m->pCfg->HeadCfg.INDX.TML_B_Indx = 0;
			m->pCfg->HeadCfg.INDX.BtnJog_Gain = 1.0;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			
			// Lamp On Off
			
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0;
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = VECT_TVL;

			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = VECT_INDX_1;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = TML_AX_INDX;			


			/////////////////////////////////////////////////////	

			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;


			switch(headType){

				case BPV_v2_MPGH:

					Configure_BPV_v2_MPGH(m , headType);			
					DefaultCalibr_BPV_v2_MPGH(m->pDefaultCalib);


				break;
			
				case BPV_v2_TT_BO_TOS:	

					Configure_BPV_v2_TT_BO_TOS(m , headType);			
					DefaultCalibr_BPV_v2_TT_BO_TOS(m->pDefaultCalib);

				break;

			}			
			
			
		break;


		
		/************ BPV_v2_MPGV - 18 ************/ 
		/************ BPV_v2_MT_BO_TOS - 22 ************/ 		
		case BPV_v2_MPGV:
		case BPV_v2_MT_BO_TOS:	
			
			/////////

			
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;

			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = VECT_TVL;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = TML_AX_TVL;

			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;


			// This is like BPV
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	

			//m->pCfg->HeadCfg.TVL.EncNominator = 16209.6631 * 25.4;
			//m->pCfg->HeadCfg.TVL.EncDenominator = -32;
			//m->pCfg->HeadCfg.TVL.EncPerTick = (DINT)ceil(m->pCfg->HeadCfg.TVL.EncNominator / m->pCfg->HeadCfg.TVL.EncDenominator );

			m->pCfg->HeadCfg.TVL.EncScale = -32.0 /  (16209.6631 * 25.4);
			m->pCfg->HeadCfg.TVL.EncPerTick = (DINT)ceil(1.0/m->pCfg->HeadCfg.TVL.EncScale);

			m->pCfg->HeadCfg.TVL.EncPerTick_SecEnc = 159; // (4000 * 4) / (1" * Pi * 32)
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration	
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /32.0; // 1/32"
			/////////////////////

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;


			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF_1;			
			m->pCfg->HeadCfg.WF.TML_A_Indx = TML_AX_WF;
			m->pCfg->HeadCfg.WF.TML_B_Indx = TML_AX_WF_1;

			
			m->pCfg->HeadCfg.WF.VECT_Aux_A_Indx = VECT_AUX_WF;
			m->pCfg->HeadCfg.WF.VECT_Aux_B_Indx = VECT_AUX_WF_1;			
			m->pCfg->HeadCfg.WF.TML_Aux_A_Indx = TML_AUX_AX_WF;
			m->pCfg->HeadCfg.WF.TML_Aux_B_Indx = TML_AUX_AX_WF_1;
			

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP_1;			
			m->pCfg->HeadCfg.WP.TML_A_Indx = TML_AX_WP;
			m->pCfg->HeadCfg.WP.TML_B_Indx = TML_AX_WP_1;

			// OSC
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;

			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 17;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			// WRST
			m->pCfg->HeadCfg.WRST.PROC_Indx = PROC_WRST;
			m->pCfg->HeadCfg.WRST.VECT_A_Indx = VECT_WRST;
			m->pCfg->HeadCfg.WRST.VECT_B_Indx = VECT_WRST;			
			m->pCfg->HeadCfg.WRST.TML_A_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.TML_B_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.Limits_Harcoded = 0;		

			//m->pCfg->HeadCfg.WRST.BtnJog_Gain = 24.0; 
			m->pCfg->HeadCfg.WRST.BtnJog_Gain = 0.24;	
			m->pCfg->HeadCfg.WRST.BtnJog_Mode = BTN_JOG_MODE_SINGLE;	

					
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 1;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;


			// INDX
			
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX;
			m->pCfg->HeadCfg.INDX.VECT_A_Indx = VECT_INDX_1;
			m->pCfg->HeadCfg.INDX.VECT_B_Indx = VECT_INDX_2;			
			m->pCfg->HeadCfg.INDX.TML_A_Indx = TML_AX_INDX;
			m->pCfg->HeadCfg.INDX.TML_B_Indx = TML_AX_INDX_1;
			m->pCfg->HeadCfg.INDX.BtnJog_Gain = 1.0;
			
			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;

			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;


			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = VECT_OSC + 1;
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = VECT_INDX_1 + 1;

			
			/////////////////////////////////////////////////////	

			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;


			switch(headType){

				case BPV_v2_MPGV:

					Configure_BPV_v2_MPGV(m , headType);			
					DefaultCalibr_BPV_v2_MPGV(m->pDefaultCalib);

				break;
			
				case BPV_v2_MT_BO_TOS:	

					Configure_BPV_v2_MT_BO_TOS(m , headType);			
					DefaultCalibr_BPV_v2_MT_BO_TOS(m->pDefaultCalib);

				break;


			}		
			
			
		break;

		
		///////////////////////////////////////////////////////////////////////////////

		/************ 23 ************/	
		case RUBIX:					
		
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
			m->pCfg->HeadCfg.TVL.DC_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			m->pCfg->HeadCfg.TVL.EncPerTick = 38;  // 1/16 inch 
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /16.0; // 1/16"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			
					
			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.TML_A_Indx = TML_AX_WF;
			m->pCfg->HeadCfg.WF.TML_B_Indx = TML_AX_WF;
			//m->pCfg->HeadCfg.WF.DC_A_Indx = DC_AX_WF;
			//m->pCfg->HeadCfg.WF.DC_B_Indx = DC_AX_WF;			

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = 0;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = 0;	
			/*
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP;	
			m->pCfg->HeadCfg.WP.DC_A_Indx = DC_AX_WP;
			m->pCfg->HeadCfg.WP.DC_B_Indx = DC_AX_WP;
			*/
			

			// OSC 
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 5;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 1;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX; // Must be even is disabled

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

			//////////////////////
			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;
		
			Configure_RUBIX(m , RUBIX);
			DefaultCalibr_RUBIX(m->pDefaultCalib);
	
		break;
		
		///////////////////////////////////////////////////////////////////////////////

		/************ 24 ************/	
		case F_HEAD_MINI_STND:	
			
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
			m->pCfg->HeadCfg.TVL.DC_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			m->pCfg->HeadCfg.TVL.EncPerTick = 38;  // 1/16 inch 
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /16.0; // 1/16"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;
				
					
			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.TML_A_Indx = TML_AX_WF;
			m->pCfg->HeadCfg.WF.TML_B_Indx = TML_AX_WF;
				

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = 0;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = 0;	
					

			// OSC 
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 5;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 1;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX; // Must be even is disabled

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

			//////////////////////
			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;
		
			Configure_F_HEAD_MINI_STND(m , F_HEAD_MINI_STND);
			DefaultCalibr_F_HEAD_MINI_STND(m->pDefaultCalib);

		break;	

		/************ 25 ************/	
		case F_HEAD_MINI_OMEGA: 		// Like F_HEAD_HP_MINI_ENC [7]		
		

			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
			m->pCfg->HeadCfg.TVL.DC_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			m->pCfg->HeadCfg.TVL.EncPerTick = 38;  // 1/16 inch 
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /16.0; // 1/16"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			
					
			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.DC_A_Indx = DC_AX_WF;
			m->pCfg->HeadCfg.WF.DC_B_Indx = DC_AX_WF;
			

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP;	
			m->pCfg->HeadCfg.WP.DC_A_Indx = DC_AX_WP;
			m->pCfg->HeadCfg.WP.DC_B_Indx = DC_AX_WP;			
			

			// OSC 
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 5;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 1;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX; // Must be even is disabled

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

			//////////////////////
			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;
		
			Configure_F_HEAD_MINI_OMEGA(m , F_HEAD_MINI_OMEGA);
			DefaultCalibr_F_HEAD_MINI_OMEGA(m->pDefaultCalib);
	
		break;

		/************ 26 ************/	
		case D_HEAD_HP: 		// Like F_HEAD_MINI_OMEGA [25]	????	


			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			
			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
			m->pCfg->HeadCfg.TVL.DC_Indx = 0;
			
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			m->pCfg->HeadCfg.TVL.EncPerTick = 38;  // 1/16 inch 
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /16.0; // 1/16"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			
					
			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.DC_A_Indx = DC_AX_WF;
			m->pCfg->HeadCfg.WF.DC_B_Indx = DC_AX_WF;
			

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP;	
			m->pCfg->HeadCfg.WP.DC_A_Indx = DC_AX_WP;
			m->pCfg->HeadCfg.WP.DC_B_Indx = DC_AX_WP;			
			

			// OSC 
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 5;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 1;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX; // Must be even is disabled

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used
		

			//////////////////////
			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;
		
			Configure_D_HEAD_HP(m , D_HEAD_HP);
			DefaultCalibr_D_HEAD_HP(m->pDefaultCalib);
	
		break;

		/************ 31 ************/
		case CLAMSHELL_HEAD: // Based on BPV_F_HEAD
				
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;
			m->pCfg->HeadCfg.GEN.AVC_Mode = MODE_DUAL_AVC;


			// Gas SOlenoid & WRST
			/*
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = TML_AX_WRST + 1;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = TML_AX_WF_1 + 1;
			*/
			
			/** WF & WP -
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx_2 = VECT_WF + 1;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx_2 = TML_AX_WF + 1;	
			*/

			
			//////
			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
						
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			//m->pCfg->HeadCfg.TVL.EncPerTick  = 5085;  //  5084.8094458543457034129135792358	// For 1/32 "
			m->pCfg->HeadCfg.TVL.EncPerTick  = 9800; // aby bylo 32 razy
			m->pCfg->HeadCfg.TVL.EncPerTick_SecEnc = 159; // (4000 * 4) / (1" * Pi * 32)
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration	
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /32.0; // 1/32"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF;			
			m->pCfg->HeadCfg.WF.TML_A_Indx = TML_AX_WF;
			m->pCfg->HeadCfg.WF.TML_B_Indx = TML_AX_WF;

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP;			
			m->pCfg->HeadCfg.WP.TML_A_Indx = TML_AX_WP;
			m->pCfg->HeadCfg.WP.TML_B_Indx = TML_AX_WP;

			// OSC
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;
			
			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 4;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			// WRST
			m->pCfg->HeadCfg.WRST.PROC_Indx = PROC_WRST;
			m->pCfg->HeadCfg.WRST.VECT_A_Indx = VECT_WRST;
			m->pCfg->HeadCfg.WRST.VECT_B_Indx = VECT_WRST;			
			m->pCfg->HeadCfg.WRST.TML_A_Indx = TML_AX_WF_1; //TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.TML_B_Indx = TML_AX_WF_1; //TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.Limits_Harcoded = 0;		

			m->pCfg->HeadCfg.WRST.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.WRST.BtnJog_Mode = BTN_JOG_MODE_SINGLE;		

			
			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC2;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC2;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 1;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;
			
			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX;
			m->pCfg->HeadCfg.INDX.VECT_A_Indx = VECT_INDX_1;
			m->pCfg->HeadCfg.INDX.VECT_B_Indx = VECT_INDX_2;			
			m->pCfg->HeadCfg.INDX.DC_A_Indx = DC_INDX_1;
			m->pCfg->HeadCfg.INDX.DC_B_Indx = DC_INDX_2;
			m->pCfg->HeadCfg.INDX.BtnJog_Gain = 1.0;

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;
			
			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

			/////////////////////////////////////////////////////	

			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;
			
			Configure_CLAMSHELL_HEAD(m , CLAMSHELL_HEAD);			
			DefaultCalibr_CLAMSHELL_HEAD(m->pDefaultCalib);
			
			
		break;
		/***************************/
		/***************************/
		
		/******32 - 33 - 34 ********************/
		case CHERRYPOINT_BP1_HEAD:
		case CHERRYPOINT_BP2_HEAD:	
		case CHERRYPOINT_MT_BP2_HEAD:
		
		// From BPV FLANGE OSC ENC+POT  == BPV_FACE_OSC_EXP
		
			
			m->pCfg->HeadCfg.GEN.Torch_Mode = MODE_SINGLE_TORCH;

			// TVL
			m->pCfg->HeadCfg.SwitchHead.VECT_Indx = 0;	
			m->pCfg->HeadCfg.SwitchHead.TML_Indx = 0;

			m->pCfg->HeadCfg.TVL.PROC_Indx = PROC_TVL;
			m->pCfg->HeadCfg.TVL.TML_Indx = TML_AX_TVL;
						
			m->pCfg->HeadCfg.TVL.VECT_Indx = VECT_TVL;
			m->pCfg->HeadCfg.TVL.Enc_Dir = 1;	
			//m->pCfg->HeadCfg.TVL.EncPerTick  = 5085;	//	5084.8094458543457034129135792358	// For 1/32 "
			m->pCfg->HeadCfg.TVL.EncPerTick  = 5088; // aby bylo 32 razy
			m->pCfg->HeadCfg.TVL.EncPerTick_SecEnc = 159; // (4000 * 4) / (1" * Pi * 32)
			m->pCfg->HeadCfg.TVL.PinsPerRot = 0;  // Dynamic Configuration	
			m->pCfg->HeadCfg.TVL.DistPerTick = 25.4 /32.0; // 1/32"

			m->pCfg->HeadCfg.TVL.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.TVL.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WF
			m->pCfg->HeadCfg.WF.PROC_Indx = PROC_WIRE_FEED;
			m->pCfg->HeadCfg.WF.VECT_A_Indx = VECT_WF;
			m->pCfg->HeadCfg.WF.VECT_B_Indx = VECT_WF_1;			
			m->pCfg->HeadCfg.WF.TML_A_Indx = TML_AX_WF;
			m->pCfg->HeadCfg.WF.TML_B_Indx = TML_AX_WF_1;

			m->pCfg->HeadCfg.WF.BtnJog_Gain = 24;
			m->pCfg->HeadCfg.WF.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// WP
			m->pCfg->HeadCfg.WP.PROC_Indx = PROC_WIRE_PULSE;
			m->pCfg->HeadCfg.WP.VECT_A_Indx = VECT_WP;
			m->pCfg->HeadCfg.WP.VECT_B_Indx = VECT_WP_1;			
			m->pCfg->HeadCfg.WP.TML_A_Indx = TML_AX_WP;
			m->pCfg->HeadCfg.WP.TML_B_Indx = TML_AX_WP_1;

			// OSC
			m->pCfg->HeadCfg.OSC.PROC_Indx = PROC_OSC;
			m->pCfg->HeadCfg.OSC.VECT_A_Indx = VECT_OSC;
			m->pCfg->HeadCfg.OSC.VECT_B_Indx = VECT_OSC;			
			m->pCfg->HeadCfg.OSC.TML_A_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.TML_B_Indx = TML_AX_OSC;
			m->pCfg->HeadCfg.OSC.Limits_Harcoded = 0;

			m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun = 0;

			m->pCfg->HeadCfg.OSC.BtnJog_Gain = 12;
			m->pCfg->HeadCfg.OSC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain1 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode1 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.WheelJog_Gain2 = 0.2;
			m->pCfg->HeadCfg.OSC.WhelJog_Mode2 = WHL_JOG_MODE_STEP;

			m->pCfg->HeadCfg.OSC.DwellDir = 1;

			// WRST
			m->pCfg->HeadCfg.WRST.PROC_Indx = PROC_WRST;
			m->pCfg->HeadCfg.WRST.VECT_A_Indx = VECT_WRST;
			m->pCfg->HeadCfg.WRST.VECT_B_Indx = VECT_WRST;			
			m->pCfg->HeadCfg.WRST.TML_A_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.TML_B_Indx = TML_AX_WRST;
			m->pCfg->HeadCfg.WRST.Limits_Harcoded = 0;		

			m->pCfg->HeadCfg.WRST.BtnJog_Gain = 24.0;
			m->pCfg->HeadCfg.WRST.BtnJog_Mode = BTN_JOG_MODE_SINGLE;		


			// AVC
			m->pCfg->HeadCfg.AVC.PROC_Indx = PROC_AVC;
			m->pCfg->HeadCfg.AVC.VECT_A_Indx = VECT_AVC;
			m->pCfg->HeadCfg.AVC.VECT_B_Indx = VECT_AVC;			
			m->pCfg->HeadCfg.AVC.TML_A_Indx = TML_AX_AVC;
			m->pCfg->HeadCfg.AVC.TML_B_Indx = TML_AX_AVC;

			m->pCfg->HeadCfg.AVC.BtnJog_Gain = 1;
			m->pCfg->HeadCfg.AVC.BtnJog_Mode = BTN_JOG_MODE_SINGLE;

			// GAS
			m->pCfg->HeadCfg.GAS.PROC_Indx = PROC_GAS;

			// COOL
			m->pCfg->HeadCfg.COOL.PROC_Indx = PROC_COOL;

			// TIG
			m->pCfg->HeadCfg.TIG.PROC_Indx = PROC_TIG_PS;

			// HW
			m->pCfg->HeadCfg.HW.PROC_Indx = PROC_HW_PS;

			// INDX
			m->pCfg->HeadCfg.INDX.PROC_Indx = PROC_INDX;
			m->pCfg->HeadCfg.INDX.VECT_A_Indx = VECT_INDX_1;
			m->pCfg->HeadCfg.INDX.VECT_B_Indx = VECT_INDX_2;			
			m->pCfg->HeadCfg.INDX.DC_A_Indx = DC_INDX_1;
			m->pCfg->HeadCfg.INDX.DC_B_Indx = DC_INDX_2;
			m->pCfg->HeadCfg.INDX.BtnJog_Gain = 1.0;

			// WB
			m->pCfg->HeadCfg.WB[WB_UD].PROC_Indx = PROC_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].PROC_Indx = PROC_WB_LR;

			m->pCfg->HeadCfg.WB[WB_UD].VECT_Indx = VECT_WB_UD;
			m->pCfg->HeadCfg.WB[WB_LR].VECT_Indx = VECT_WB_LR;

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

			/////////////////////////////////////////////////////	

			// frame size if zero always speed factor is 1.0
			//m->FrameDia = 4.5 * in_2_mm ;
			m->FrameDia = 0.0;

			switch(headType){

				case CHERRYPOINT_BP1_HEAD:	
					
					Configure_CHERRYPOINT_BPV1_HEAD(m , CHERRYPOINT_BP1_HEAD);
					DefaultCalibr_CHERRYPOINT_BPV1_HEAD(m->pDefaultCalib);
				
				break;

				case CHERRYPOINT_BP2_HEAD:	
					
					Configure_CHERRYPOINT_BPV2_HEAD(m , CHERRYPOINT_BP2_HEAD);
					DefaultCalibr_CHERRYPOINT_BPV2_HEAD(m->pDefaultCalib);
				
				break;


				case CHERRYPOINT_MT_BP2_HEAD:

					Configure_CHERRYPOINT_MT_BP2_HEAD(m , CHERRYPOINT_BP2_HEAD);
					DefaultCalibr_CHERRYPOINT_BPV2_HEAD(m->pDefaultCalib);
				
				break;
						
			}
	
			
		break;
		
		default:

			// Lamp On Off
			m->pCfg->HeadCfg.LampOnOFF.VECT_A_Indx = 0; // 0 - not used
			m->pCfg->HeadCfg.LampOnOFF.VECT_B_Indx = 0; // 0 - not used

		break;		

	}			

	PleaseUpdateHeadSetup(m);


	/*********************************************************/
	/****   Parameter assigments   ************************/
	ParametrAssignToPointers( m , 0);

	Process[PROC_TVL].ConfigReady 			= 1;
	Process[PROC_OSC].ConfigReady 			= 1;
	Process[PROC_AVC].ConfigReady 			= 1;
	Process[PROC_WIRE_FEED].ConfigReady 	= 1;
	Process[PROC_WIRE_PULSE].ConfigReady 	= 1;
	Process[PROC_TIG_PS].ConfigReady 		= 1;
	Process[PROC_HW_PS].ConfigReady 		= 1;
	Process[PROC_GAS].ConfigReady 			= 1;
	Process[PROC_COOL].ConfigReady 			= 1;
	Process[PROC_INDX].ConfigReady 			= 1;
	Process[PROC_WRST].ConfigReady 		= 1;
	Process[PROC_WB_UD].ConfigReady 		= 1;
	Process[PROC_WB_LR].ConfigReady 		= 1;



	///////   Smart Cooler in Arclink   //
#ifdef CMT_SYSTEM
	COOL_Param_Set[0].pSensInput = &ArcLink.robot.Cntrl.Fbk.coolerSens_Status;
	COOL_Param_Set[0].pOutput	= &ArcLink.robot.Cntrl.Cmd.COOLER;
#endif

#ifdef MIG_SYSTEM
		COOL_Param_Set[0].pSensInput = &ArcLink.robot.Cntrl.Fbk.coolerSens_Status;
		COOL_Param_Set[0].pOutput	= &ArcLink.robot.Cntrl.Cmd.COOLER;
#endif


	return 1;

}

DINT Configure_BPV_v2_MT(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];



	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	

		for(i = 0 ; i < TML_RLY_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(TmlRelay[i].Name , "WB_UD");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_UD];
				
					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_TVL;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_TVL;

					TmlRelay[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(TmlRelay[i].Name , "WB_LR");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_LR];

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_AVC;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_AVC;
				
					TmlRelay[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		

		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					strcpy(TML_MTR_INST[i].Name , "TVL");

					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
									
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 	
					
					//TML_MTR_INST[i]._cfg.rev_motor = 156;
					//TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;

					TML_MTR_INST[i]._cfg.rev_motor = 73.233;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.875 * 25.4 * M_PI) ;					
								
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel / 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
									
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "3925_BPV2_TVL_G.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3925"); // New TVL Pos Mode with Interrupt
	
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					///////////////////////////////
					
						
				break;			
				
				case TML_AX_OSC:			
									

					strcpy(TML_MTR_INST[i].Name , "OSC");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;

					//This is from BPV
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;

					/* It was in Super Mini
					TML_MTR_INST[i]._cfg.rev_motor = -62.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.5 * 25.4) ;
					*/

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel / 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
					

					strcpy(TML_MTR_INST[i]._cfg.programName , "3721_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3721");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;



				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.maxVel = fabsf(8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					//TML_MTR_INST[i]._cfg.HeartBeat = 2.0;
					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1723_SMH_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1723");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;


				case TML_AX_WF:
				case TML_AX_WF_1:
				

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				// This was taken from BPV WF & WP
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;
				

				case TML_AX_INDX:
				case TML_AX_INDX_1:


									
					switch(i){

						case TML_AX_INDX:
							
							strcpy(TML_MTR_INST[i].Name , "INDX"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 ;
							TML_MTR_INST[i]._cfg.rev_motor = 3.0;	

							

							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_A_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
						break;

						
						case TML_AX_INDX_1:
							
							strcpy(TML_MTR_INST[i].Name , "INDX_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0; ;
							TML_MTR_INST[i]._cfg.rev_motor = -3.0;	


							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_B_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
							
						break;
						

					}	


					strcpy(TML_MTR_INST[i]._cfg.programName , "1622_BPV2_INDX.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1622");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 16000 / (1.25 * M_PI * 25.4); // 					
									
			
					TML_MTR_INST[i]._cfg.maxVel = TML_MTR_INST[i]._cfg.units; 
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;
					
					TML_MTR_INST[i]._cfg.HeartBeat = 0.6;	
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;		
				
				

				default:

					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
					TML_MTR_INST[i].pState = 0;

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}


		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];

		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];

		
		AxisCh[TML_AX_TVL].AxisID	= 25;		
		AxisCh[TML_AX_OSC].AxisID 	= 21;	
		AxisCh[TML_AX_AVC].AxisID 	= 26;
		AxisCh[TML_AX_WRST].AxisID 	= 23;

		AxisCh[TML_AX_INDX].AxisID 	= 22;
		AxisCh[TML_AX_INDX_1].AxisID 	= 24;

		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode
					//OSC_TML_Param_Set[i].Mode = 10; // Version New Concept Path Gen in Drive

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 1; // TML drives 
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_INDX_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	
		/////////////////////////////////////////////
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					
					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 

					//WIRE_Param_Set[i].pAuxVect = &VectorStateMach[VECT_AUX_WF];	
					//WIRE_Param_Set[i].AuxVectStateNum = 1; //BPV Mode

					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;

					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


			}

		}
		////////////////////////////////////////////////////////
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 5;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	TML_MTR_INST[TML_AX_WRST].Disable = 0;	
	*/

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby

	//VectorStateMach[VECT_AVC].simul = 1;
	//VectorStateMach[VECT_OSC].simul = 1;	
	//VectorStateMach[VECT_TVL].simul = 1;	
	//VectorStateMach[VECT_INDX_1].simul = 1;
	//VectorStateMach[VECT_INDX_2].simul = 1;
	//VectorStateMach[VECT_WF_1].simul = 1;
	//VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_AUX_WF_1].simul = 1;
	VectorStateMach[VECT_AUX_WF].simul = 1;
	//VectorStateMach[VECT_WP_1].simul = 1;
	//VectorStateMach[VECT_WP].simul = 1;
	//VectorStateMach[VECT_WRST].simul = 1;

	//VectorStateMach[VECT_AVC].testMode = 1;
	//VectorStateMach[VECT_OSC].testMode = 1;	
	//VectorStateMach[VECT_TVL].testMode = 1;	
	//VectorStateMach[VECT_INDX_1].testMode = 1;
	//VectorStateMach[VECT_INDX_2].testMode = 1;
	//VectorStateMach[VECT_WF_1].testMode = 1;
	//VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_AUX_WF_1].testMode = 1;
	VectorStateMach[VECT_AUX_WF].testMode = 1;
	//VectorStateMach[VECT_WP_1].testMode = 1;
	//VectorStateMach[VECT_WP].testMode = 1;
	//VectorStateMach[VECT_WRST].testMode = 1;	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	//TML_MTR_INST[TML_AX_AVC].Disable = 1;
	//TML_MTR_INST[TML_AX_OSC].Disable = 1;
	//TML_MTR_INST[TML_AX_TVL].Disable = 1;
	//TML_MTR_INST[TML_AX_WRST].Disable = 1; 
	//TML_MTR_INST[TML_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AUX_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AUX_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AX_WP].Disable = 1;
	//TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	//TML_MTR_INST[TML_AX_INDX].Disable = 1;
	//TML_MTR_INST[TML_AX_INDX_1].Disable = 1;
	////////////////////////////////////////

	//Process[PROC_AVC].Disable = 1;
	//Process[PROC_AVC].TestMode = 1;

	//Process[PROC_INDX].Disable = 1;
	//Process[PROC_INDX].TestMode = 1;

	//Process[PROC_OSC].Disable = 1;
	//Process[PROC_OSC].TestMode = 1;

	//Process[PROC_TVL].Disable = 1;
	//Process[PROC_TVL].TestMode = 1;

	//Process[PROC_WIRE_FEED].Disable = 1;
	//Process[PROC_WIRE_FEED].TestMode = 1;

	//Process[PROC_WIRE_PULSE].Disable = 1;
	//Process[PROC_WIRE_PULSE].TestMode = 1;

	//Process[PROC_COOL].Disable = 1;
	//Process[PROC_COOL].TestMode = 1;

	//Process[PROC_GAS].Disable = 1;
	//Process[PROC_GAS].TestMode = 1;

	//Process[PROC_WRST].Disable = 1;
	//Process[PROC_WRST].TestMode = 1;
	
	////////////////////////////////////////////////////////
				
	return 1;
	
}

DINT Configure_MIG_TIG(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];



	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block

		/*
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	

		for(i = 0 ; i < TML_RLY_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(TmlRelay[i].Name , "WB_UD");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_UD];
				
					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_TVL;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_TVL;

					TmlRelay[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(TmlRelay[i].Name , "WB_LR");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_LR];

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_AVC;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_AVC;
				
					TmlRelay[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		*/
		
		KK_DoNotChangeTMLProgram = 1;
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					/*

					strcpy(TML_MTR_INST[i].Name , "TVL");

					// Corrected 29May19
					//TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
					
								
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "1725_BPV2_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1725");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
					*/

					///////////////////////////////
					/// Z MIG NG 4

					strcpy(TML_MTR_INST[i].Name , "TVL");
					// Back EMF
					//TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.loopPeriod = 0.0005 * 2.0; // Slow loop
					TML_MTR_INST[i]._cfg.units = 1024 * 4; //
					
					TML_MTR_INST[i]._cfg.rev_motor = -81.37037037037037037037037037037; 
					TML_MTR_INST[i]._cfg.rev_scale = -(9.0/10.0) /(1.875 * M_PI); //to jest  w inchach
					TML_MTR_INST[i]._cfg.rev_scale = -(9.0/10.0) /(1.875 * 25.4 * M_PI); // to jest mm	
					
										
					TML_MTR_INST[i]._cfg.maxVel = fabsf(3600.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[i];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[i];
					TML_MTR_INST[i]._cfg.absFbk = 3; //eksperyment
				
					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
											
					strcpy(TML_MTR_INST[i]._cfg.programName , "TVL_0025_200W_48V.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0025");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("514I");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
				
				
					/////////////////////////////////////////////////
					
						
				break;			
				
				case TML_AX_OSC:			
									
#if 0
					strcpy(TML_MTR_INST[i].Name , "OSC");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;

					//This is from BPV
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ; // To jest dobrze
									
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					
									
					// Version Classic
					///*
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "1721_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1721");
					//*/		

					// Version New Concept Path Gen in Drive
					/*

					TML_MTR_INST[i]._int.kVolt = 1365.0;
					
					TML_MTR_INST[i]._cfg.absFbk = 10;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "1821_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1821");					
					//*/	

					
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

#endif


					strcpy(TML_MTR_INST[i].Name , "OSC");

					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;					

					TML_MTR_INST[i]._cfg.units = 1024 * 4;
				
					TML_MTR_INST[i]._cfg.rev_motor = -75.0/19.0; //-75.0/19.0;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/ ((1.0/8.0) * 25.4) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;

					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					
									
					// Version Classic
					///*
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;

			
					/*
		
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;		
					
					//TML_MTR_INST[i]._cfg.rev_motor = 110.0; 
					//TML_MTR_INST[i]._cfg.rev_scale = 1.0/(360.0) ;

					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
				
					TML_MTR_INST[i]._cfg.maxVel = 4000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[i];
					//TML_MTR_INST[i]._cfg.absFbk = 2;
					TML_MTR_INST[i]._cfg.absFbk = 0;
				
					TML_MTR_INST[i]._cfg.HeartBeat = 1.0 ; //1.0; //0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;

					*/
					
									
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "4021_OSC_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("4021");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("F508L");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
	
		

					
	
				break;

				case TML_AX_AVC:

				#if 0
					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless

				#endif	


					strcpy(TML_MTR_INST[i].Name , "AVC");
	
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;	
					
					TML_MTR_INST[i]._cfg.maxVel = 6700.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 2.0;	
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[i];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[i];
					TML_MTR_INST[i]._cfg.absFbk = 3; 

					/*
					TML_MTR_INST[i]._cfg.kppMax = 20000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.kpp = 10000/2;
					TML_MTR_INST[i]._cfg.kip = 0;
					*/
					
					TML_MTR_INST[i]._cfg.kppMax = 0;
						
					TML_MTR_INST[i]._cfg.HeartBeat = 0.3; //1.0 ;//0.3;	

					//strcpy(TML_MTR_INST[i]._cfg.programName , "AHC_0026_50W_24V.sw");		
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0026");			
					//TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("514I");  //0x674C , 514D		
					//TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

					strcpy(TML_MTR_INST[i]._cfg.programName , "4022_AHC.sw");		
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("4022");		
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("508L");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
				
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
				
					TML_MTR_INST[i]._cfg.AnalLimitPos = 0.0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0.0;	
				
					
					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless		
		
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;


					switch(headType){

						case BPV_v2_Video:

							TML_MTR_INST[i]._cfg.units = 1024 * 4;
							TML_MTR_INST[i]._cfg.rev_motor = 3.9 * 50 ;
							TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
							TML_MTR_INST[i]._cfg.maxVel = fabsf(8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
							TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
							TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
							//TML_MTR_INST[i]._cfg.absFbk = 2;
							TML_MTR_INST[i]._cfg.absFbk = 3;
							

						break;


						default:

							TML_MTR_INST[i]._cfg.units = 1024 * 4;
							TML_MTR_INST[i]._cfg.rev_motor = 3.9 * 50 ;
							TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
							TML_MTR_INST[i]._cfg.maxVel = fabsf(8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
							TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;

						break;

					}
								
					

					//TML_MTR_INST[i]._cfg.HeartBeat = 2.0;
					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1723_SMH_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1723");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;


				case TML_AX_WF:
				case TML_AX_WF_1:
				

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				// This was taken from BPV WF & WP
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;
				

				case TML_AX_INDX:
				case TML_AX_INDX_1:


									
					switch(i){

						case TML_AX_INDX:


							/*							
							strcpy(TML_MTR_INST[i].Name , "INDX"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 ;
							TML_MTR_INST[i]._cfg.rev_motor = 3.0;							

							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_A_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							*/

							
							strcpy(TML_MTR_INST[i].Name , "INDX"); 

							// Analog Feedback from REF
							TML_MTR_INST[i]._cfg.loopPeriod = 0.0005 * 2.0; // Slow loop
										
							TML_MTR_INST[i]._cfg.units = 1024 * 4;
							//TML_MTR_INST[i]._cfg.rev_motor = 75.0;
							TML_MTR_INST[i]._cfg.rev_motor = 389376.0/1225.0;
							TML_MTR_INST[i]._cfg.rev_scale = 1.0/(M_PI * 1.6);
							TML_MTR_INST[i]._cfg.absFbk = 0;	

							TML_MTR_INST[i]._cfg.maxVel = fabsf(8740.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
							TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;

							TML_MTR_INST[i]._cfg.HeartBeat = 0.8;

							strcpy(TML_MTR_INST[i]._cfg.programName , "INDX_0023_70W_36V.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0023");
												

							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("508L");  
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
							TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
							

						break;

						
						case TML_AX_INDX_1:

							/*
							strcpy(TML_MTR_INST[i].Name , "INDX_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0; ;
							TML_MTR_INST[i]._cfg.rev_motor = -3.0;	


							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_B_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							*/

							strcpy(TML_MTR_INST[i].Name , "INDX_1"); 
	
							// Analog Feedback from REF
							TML_MTR_INST[i]._cfg.loopPeriod = 0.0005 * 2.0; // Slow loop
										
							TML_MTR_INST[i]._cfg.units = 1024 * 4;
							//TML_MTR_INST[i]._cfg.rev_motor = 75.0;
							TML_MTR_INST[i]._cfg.rev_motor = 389376.0/1225.0;
							TML_MTR_INST[i]._cfg.rev_scale = 1.0/(M_PI * 1.6);
							TML_MTR_INST[i]._cfg.absFbk = 0;	

							TML_MTR_INST[i]._cfg.maxVel = fabsf(8740.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
							TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;

							TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
							
							strcpy(TML_MTR_INST[i]._cfg.programName , "INDX_0024_70W_36V.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0024");
												

							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("508L");  
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
							TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

							
							
						break;
						

					}	


					/*
					strcpy(TML_MTR_INST[i]._cfg.programName , "1622_BPV2_INDX.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1622");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 16000 / (1.25 * M_PI * 25.4); // 					
									
			
					TML_MTR_INST[i]._cfg.maxVel = TML_MTR_INST[i]._cfg.units; 
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;
					
					TML_MTR_INST[i]._cfg.HeartBeat = 0.6;	
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
					*/
					
						
				break;		
				
				

				default:

					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
					TML_MTR_INST[i].pState = 0;

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}


		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];

		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];

		



		////////  Z MIG
		/*
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 6;
	
		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];
	
		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];
	
		
		AxisCh[TML_AX_TVL].AxisID	= 25;	
		AxisCh[TML_AX_OSC].AxisID	= 21;				
		AxisCh[TML_AX_AHC].AxisID	= 22; 
		AxisCh[TML_AX_WF].AxisID	= 26; 
		AxisCh[TML_AX_INDX].AxisID	= 23; 
		AxisCh[TML_AX_INDX_EXT].AxisID	= 24;
		*/

		////////////////////////////////////

		
		AxisCh[TML_AX_TVL].AxisID	= 25;
		AxisCh[TML_AX_OSC].AxisID	= 21;				
		AxisCh[TML_AX_AVC].AxisID	= 22; 
		AxisCh[TML_AX_INDX].AxisID 	 = 23;
		//AxisCh[TML_AX_INDX_1].AxisID = 24;

		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;

		/*
		AxisCh[TML_AX_OSC].AxisID 	= 21;	
		AxisCh[TML_AX_AVC].AxisID 	= 26;
		AxisCh[TML_AX_WRST].AxisID 	= 23;

		AxisCh[TML_AX_INDX].AxisID 	= 22;
		AxisCh[TML_AX_INDX_1].AxisID 	= 24;

		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		*/
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 4; //4 - Speed Control - MIG
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 

					AVC_Param_Set[i].maxBEMFspeed = 1000.0; //500.0;
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					
					OSC_TML_Param_Set[i].Mode = 12;  //12//1; //BPV Mode
					
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 1;
					INDEX_Param_Set[i].Mode = 3; // MIG TML drives 
					INDEX_Param_Set[i].MaxSpeed = 1.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_INDX_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;

			#ifdef MIG_SYSTEM

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					// small Jack PS
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;

					// Lincoln PS
					//HW_PS_Param_Set[i].rawCmdMax 		= 32767.0;
					//HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
					
					HW_PS_Param_Set[i].pAnal_Output 	= &Hardware[1].Anal_Outp[0]; // HotwirePS_AO
					HW_PS_Param_Set[i].pOutput			= &Hardware[1].Outp[2]; //HotwirePS_Enable

			#endif		
					
											
				
				break;	

			}	
							
		}	
	
		/////////////////////////////////////////////
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					
					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 

					//WIRE_Param_Set[i].pAuxVect = &VectorStateMach[VECT_AUX_WF];	
					//WIRE_Param_Set[i].AuxVectStateNum = 1; //BPV Mode

					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;

					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


			}

		}
		////////////////////////////////////////////////////////
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 5;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	TML_MTR_INST[TML_AX_WRST].Disable = 0;	
	*/

	//Process[PROC_TIG_PS].Disable = 1;
	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby

	//VectorStateMach[VECT_AVC].simul = 1;
	//VectorStateMach[VECT_OSC].simul = 1;	
	//VectorStateMach[VECT_TVL].simul = 1;	
	//VectorStateMach[VECT_INDX_1].simul = 1;
	//VectorStateMach[VECT_INDX_2].simul = 1;
	//VectorStateMach[VECT_WF_1].simul = 1;
	//VectorStateMach[VECT_WF].simul = 1;
	//VectorStateMach[VECT_AUX_WF_1].simul = 1;
	//VectorStateMach[VECT_AUX_WF].simul = 1;
	//VectorStateMach[VECT_WP_1].simul = 1;
	//VectorStateMach[VECT_WP].simul = 1;
	//VectorStateMach[VECT_WRST].simul = 1;

	//VectorStateMach[VECT_AVC].testMode = 1;
	//VectorStateMach[VECT_OSC].testMode = 1;	
	//VectorStateMach[VECT_TVL].testMode = 1;	
	//VectorStateMach[VECT_INDX_1].testMode = 1;
	//VectorStateMach[VECT_INDX_2].testMode = 1;
	//VectorStateMach[VECT_WF_1].testMode = 1;
	//VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_AUX_WF_1].testMode = 1;
	VectorStateMach[VECT_AUX_WF].testMode = 1;
	//VectorStateMach[VECT_WP_1].testMode = 1;
	//VectorStateMach[VECT_WP].testMode = 1;
	//VectorStateMach[VECT_WRST].testMode = 1;	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	//TML_MTR_INST[TML_AX_AVC].Disable = 1;
	//TML_MTR_INST[TML_AX_OSC].Disable = 1;
	//TML_MTR_INST[TML_AX_TVL].Disable = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1; 	
	TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AUX_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AUX_AX_WF_1].Disable = 1;	
	TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	//TML_MTR_INST[TML_AX_INDX].Disable = 1;
	TML_MTR_INST[TML_AX_INDX_1].Disable = 1;

	//TML_MTR_INST[TML_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AX_WP].Disable = 1;
	////////////////////////////////////////

	//Process[PROC_AVC].Disable = 1;
	//Process[PROC_AVC].TestMode = 1;

	//Process[PROC_INDX].Disable = 1;
	//Process[PROC_INDX].TestMode = 1;

	//Process[PROC_OSC].Disable = 1;
	//Process[PROC_OSC].TestMode = 1;

	//Process[PROC_TVL].Disable = 1;
	//Process[PROC_TVL].TestMode = 1;

	//Process[PROC_WIRE_FEED].Disable = 1;
	//Process[PROC_WIRE_FEED].TestMode = 1;

	//Process[PROC_WIRE_PULSE].Disable = 1;
	//Process[PROC_WIRE_PULSE].TestMode = 1;

	//Process[PROC_COOL].Disable = 1;
	//Process[PROC_COOL].TestMode = 1;

	//Process[PROC_GAS].Disable = 1;
	//Process[PROC_GAS].TestMode = 1;

	//Process[PROC_WRST].Disable = 1;
	//Process[PROC_WRST].TestMode = 1;
	
	////////////////////////////////////////////////////////
				
	return 1;
	
}


DINT Configure_BPV_v2(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];



	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	

		for(i = 0 ; i < TML_RLY_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(TmlRelay[i].Name , "WB_UD");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_UD];
				
					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_TVL;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_TVL;

					TmlRelay[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(TmlRelay[i].Name , "WB_LR");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_LR];

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_AVC;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_AVC;
				
					TmlRelay[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		

		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					strcpy(TML_MTR_INST[i].Name , "TVL");

					// Corrected 29May19
					//TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
					
								
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "1725_BPV2_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1725");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					///////////////////////////////
					
						
				break;			
				
				case TML_AX_OSC:			
									

					strcpy(TML_MTR_INST[i].Name , "OSC");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;

					//This is from BPV
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ; // To jest dobrze
									
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					
									
					// Version Classic
					///*
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "1721_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1721");
					//*/		

					// Version New Concept Path Gen in Drive
					/*

					TML_MTR_INST[i]._int.kVolt = 1365.0;
					
					TML_MTR_INST[i]._cfg.absFbk = 10;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "1821_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1821");					
					//*/	

					
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;


					switch(headType){

						case BPV_v2_Video:

							TML_MTR_INST[i]._cfg.units = 1024 * 4;
							TML_MTR_INST[i]._cfg.rev_motor = 3.9 * 50 ;
							TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
							TML_MTR_INST[i]._cfg.maxVel = fabsf(8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
							TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
							TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[WRST_LAST_POS];
							//TML_MTR_INST[i]._cfg.absFbk = 2;
							TML_MTR_INST[i]._cfg.absFbk = 3;
							

						break;


						default:

							TML_MTR_INST[i]._cfg.units = 1024 * 4;
							TML_MTR_INST[i]._cfg.rev_motor = 3.9 * 50 ;
							TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
							TML_MTR_INST[i]._cfg.maxVel = fabsf(8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
							TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;

						break;

					}
								
					

					//TML_MTR_INST[i]._cfg.HeartBeat = 2.0;
					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1723_SMH_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1723");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;


				case TML_AX_WF:
				case TML_AX_WF_1:
				

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				// This was taken from BPV WF & WP
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;
				

				case TML_AX_INDX:
				case TML_AX_INDX_1:


									
					switch(i){

						case TML_AX_INDX:
							
							strcpy(TML_MTR_INST[i].Name , "INDX"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 ;
							TML_MTR_INST[i]._cfg.rev_motor = 3.0;	

							

							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_A_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
						break;

						
						case TML_AX_INDX_1:
							
							strcpy(TML_MTR_INST[i].Name , "INDX_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0; ;
							TML_MTR_INST[i]._cfg.rev_motor = -3.0;	


							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_B_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
							
						break;
						

					}	


					strcpy(TML_MTR_INST[i]._cfg.programName , "1622_BPV2_INDX.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1622");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 16000 / (1.25 * M_PI * 25.4); // 					
									
			
					TML_MTR_INST[i]._cfg.maxVel = TML_MTR_INST[i]._cfg.units; 
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;
					
					TML_MTR_INST[i]._cfg.HeartBeat = 0.6;	
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;		
				
				

				default:

					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
					TML_MTR_INST[i].pState = 0;

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}


		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];

		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];

		
		AxisCh[TML_AX_TVL].AxisID	= 25;		
		AxisCh[TML_AX_OSC].AxisID 	= 21;	
		AxisCh[TML_AX_AVC].AxisID 	= 26;
		AxisCh[TML_AX_WRST].AxisID 	= 23;

		AxisCh[TML_AX_INDX].AxisID 	= 22;
		AxisCh[TML_AX_INDX_1].AxisID 	= 24;

		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;

					if(headType == BPV_v2_Video)
						WRST_TML_Param_Set[i].Mode = 9;
					else					
						WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode
					//OSC_TML_Param_Set[i].Mode = 10; // Version New Concept Path Gen in Drive

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 1; // TML drives 
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_INDX_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;

			#ifdef MIG_SYSTEM

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					// small Jack PS
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;

					// Lincoln PS
					//HW_PS_Param_Set[i].rawCmdMax 		= 32767.0;
					//HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
					
					HW_PS_Param_Set[i].pAnal_Output 	= &Hardware[1].Anal_Outp[0]; // HotwirePS_AO
					HW_PS_Param_Set[i].pOutput			= &Hardware[1].Outp[2]; //HotwirePS_Enable

			#endif		
					
											
				
				break;	

			}	
							
		}	
	
		/////////////////////////////////////////////
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					
					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 

					//WIRE_Param_Set[i].pAuxVect = &VectorStateMach[VECT_AUX_WF];	
					//WIRE_Param_Set[i].AuxVectStateNum = 1; //BPV Mode

					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;

					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


			}

		}
		////////////////////////////////////////////////////////
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 5;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	TML_MTR_INST[TML_AX_WRST].Disable = 0;	
	*/

	TML_MTR_INST[TML_AX_WRST].Disable = 1;	

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby

	//VectorStateMach[VECT_AVC].simul = 1;
	//VectorStateMach[VECT_OSC].simul = 1;	
	//VectorStateMach[VECT_TVL].simul = 1;	
	//VectorStateMach[VECT_INDX_1].simul = 1;
	//VectorStateMach[VECT_INDX_2].simul = 1;
	//VectorStateMach[VECT_WF_1].simul = 1;
	//VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_AUX_WF_1].simul = 1;
	VectorStateMach[VECT_AUX_WF].simul = 1;
	//VectorStateMach[VECT_WP_1].simul = 1;
	//VectorStateMach[VECT_WP].simul = 1;
	//VectorStateMach[VECT_WRST].simul = 1;

	//VectorStateMach[VECT_AVC].testMode = 1;
	//VectorStateMach[VECT_OSC].testMode = 1;	
	//VectorStateMach[VECT_TVL].testMode = 1;	
	//VectorStateMach[VECT_INDX_1].testMode = 1;
	//VectorStateMach[VECT_INDX_2].testMode = 1;
	//VectorStateMach[VECT_WF_1].testMode = 1;
	//VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_AUX_WF_1].testMode = 1;
	VectorStateMach[VECT_AUX_WF].testMode = 1;
	//VectorStateMach[VECT_WP_1].testMode = 1;
	//VectorStateMach[VECT_WP].testMode = 1;
	//VectorStateMach[VECT_WRST].testMode = 1;	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	//TML_MTR_INST[TML_AX_AVC].Disable = 1;
	//TML_MTR_INST[TML_AX_OSC].Disable = 1;
	//TML_MTR_INST[TML_AX_TVL].Disable = 1;
	//TML_MTR_INST[TML_AX_WRST].Disable = 1; 
	//TML_MTR_INST[TML_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AUX_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AUX_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AX_WP].Disable = 1;
	//TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	//TML_MTR_INST[TML_AX_INDX].Disable = 1;
	//TML_MTR_INST[TML_AX_INDX_1].Disable = 1;
	////////////////////////////////////////

	//Process[PROC_AVC].Disable = 1;
	//Process[PROC_AVC].TestMode = 1;

	//Process[PROC_INDX].Disable = 1;
	//Process[PROC_INDX].TestMode = 1;

	//Process[PROC_OSC].Disable = 1;
	//Process[PROC_OSC].TestMode = 1;

	//Process[PROC_TVL].Disable = 1;
	//Process[PROC_TVL].TestMode = 1;

	//Process[PROC_WIRE_FEED].Disable = 1;
	//Process[PROC_WIRE_FEED].TestMode = 1;

	//Process[PROC_WIRE_PULSE].Disable = 1;
	//Process[PROC_WIRE_PULSE].TestMode = 1;

	//Process[PROC_COOL].Disable = 1;
	//Process[PROC_COOL].TestMode = 1;

	//Process[PROC_GAS].Disable = 1;
	//Process[PROC_GAS].TestMode = 1;

	//Process[PROC_WRST].Disable = 1;
	//Process[PROC_WRST].TestMode = 1;
	
	////////////////////////////////////////////////////////
				
	return 1;
	
}

DINT Configure_BPV_v2_MT_BO(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_Aux_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_Aux_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_Aux_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_Aux_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	//TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	//TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = 0;
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = 0;
	
	

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	

		for(i = 0 ; i < TML_RLY_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(TmlRelay[i].Name , "WB_UD");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_UD];
				
					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_TVL;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_TVL;

					TmlRelay[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(TmlRelay[i].Name , "WB_LR");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_LR];

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_AVC;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_AVC;
				
					TmlRelay[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		

		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					strcpy(TML_MTR_INST[i].Name , "TVL");

					// Corrected 29May19
					//TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 	
					
					//TML_MTR_INST[i]._cfg.rev_motor = 156;
					//TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;

					TML_MTR_INST[i]._cfg.rev_motor = 73.233;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.875 * 25.4 * M_PI) ;					
								
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
									
					//strcpy(TML_MTR_INST[i]._cfg.programName , "1625_BPV2_TVL.sw");											
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1625");

					//strcpy(TML_MTR_INST[i]._cfg.programName , "1825_BPV2_TVL_G.sw");											
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1825");

					strcpy(TML_MTR_INST[i]._cfg.programName , "1925_BPV2_TVL_G.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1925");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					///////////////////////////////
					
						
				break;			
				
				case TML_AX_OSC:			
									

					strcpy(TML_MTR_INST[i].Name , "OSC");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;

					//This is from BPV
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;

					/* It was in Super Mini
					TML_MTR_INST[i]._cfg.rev_motor = -62.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.5 * 25.4) ;
					*/

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1721_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1721");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					//TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					//TML_MTR_INST[i]._cfg.rev_motor = 3.9 * 50 ;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_motor = 406 * 20;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/360.0 ;
					TML_MTR_INST[i]._cfg.maxVel = fabsf(8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.16;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1723_SMH_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1723");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;


				case TML_AX_WF:
				case TML_AX_WF_1:
				

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				// This was taken from BPV WF & WP
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;


				case TML_AUX_AX_WF:
				case TML_AUX_AX_WF_1:

									
					switch(i){

						case TML_AUX_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF_AUX"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 ;
							TML_MTR_INST[i]._cfg.rev_motor = 3.0;	

							

							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_A_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
						break;

						
						case TML_AUX_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_AUX_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0; ;
							TML_MTR_INST[i]._cfg.rev_motor = -3.0;	


							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_B_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
							
						break;
						

					}

					strcpy(TML_MTR_INST[i]._cfg.programName , "1622_BPV2_INDX.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1622");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 16000 / (1.25 * M_PI * 25.4); // 					
									
			
					TML_MTR_INST[i]._cfg.maxVel = TML_MTR_INST[i]._cfg.units; 
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;
					
					TML_MTR_INST[i]._cfg.HeartBeat = 0.6;	
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;	
				

				
				

				default:

					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
					TML_MTR_INST[i].pState = 0;

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}


		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];

		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];

		
		AxisCh[TML_AX_TVL].AxisID	= 25;		
		AxisCh[TML_AX_OSC].AxisID 	= 21;	
		AxisCh[TML_AX_AVC].AxisID 	= 26;
		AxisCh[TML_AX_WRST].AxisID 	= 23;

		/*
		AxisCh[TML_AX_INDX].AxisID 	= 22;
		AxisCh[TML_AX_INDX_1].AxisID 	= 24;
		*/
		AxisCh[TML_AUX_AX_WF].AxisID 	= 22;
		AxisCh[TML_AUX_AX_WF_1].AxisID 	= 24;

		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6; 
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}	
		

		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	
		
		////////////////////////////////////////////////////////
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					//TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].Mode = 2; //TVL_MODE_BPV_PosMode
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 5;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


		}

		for(i=0 ; i < 1 ; i++){ 


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx]; 
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					/*
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 1; // TML drives 
					INDEX_Param_Set[i].MaxSpeed = 24.0; 
					INDEX_Param_Set[i].pCalibPoints 	= &m->pCalib->Points[CALIB_INDX_CMD];
					*/
					INDEX_Param_Set[i].pPrc = 0 ;
					INDEX_Param_Set[i].pCalibPoints = 0;
					INDEX_Param_Set[i].pVect = 0; 
					
											
				break;	

			}			
				
		}

		/////////////////////////////////////////////
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 

					WIRE_Param_Set[i].pAuxVect = &VectorStateMach[VECT_AUX_WF];	
					WIRE_Param_Set[i].AuxVectStateNum = 1; //BPV Mode
					
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


			}

		}


		
	}


	

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	*/
	
	

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby

	//VectorStateMach[VECT_AVC].simul = 1;
	//VectorStateMach[VECT_OSC].simul = 1;	
	//VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	//VectorStateMach[VECT_WF_1].simul = 1;
	//VectorStateMach[VECT_WF].simul = 1;
	//VectorStateMach[VECT_AUX_WF_1].simul = 1;
	//VectorStateMach[VECT_AUX_WF].simul = 1;
	//VectorStateMach[VECT_WP_1].simul = 1;
	//VectorStateMach[VECT_WP].simul = 1;
	//VectorStateMach[VECT_WRST].simul = 1;

	//VectorStateMach[VECT_AVC].testMode = 1;
	//VectorStateMach[VECT_OSC].testMode = 1;	
	//VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	//VectorStateMach[VECT_WF_1].testMode = 1;
	//VectorStateMach[VECT_WF].testMode = 1;
	//VectorStateMach[VECT_AUX_WF_1].testMode = 1;
	//VectorStateMach[VECT_AUX_WF].testMode = 1;
	//VectorStateMach[VECT_WP_1].testMode = 1;
	//VectorStateMach[VECT_WP].testMode = 1;
	//VectorStateMach[VECT_WRST].testMode = 1;	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	//TML_MTR_INST[TML_AX_AVC].Disable = 1;
	//TML_MTR_INST[TML_AX_OSC].Disable = 1;
	//TML_MTR_INST[TML_AX_TVL].Disable = 1;
	//TML_MTR_INST[TML_AX_WRST].Disable = 1;
	//TML_MTR_INST[TML_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AUX_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AUX_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AX_WP].Disable = 1;
	//TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	TML_MTR_INST[TML_AX_INDX].Disable = 1;
	TML_MTR_INST[TML_AX_INDX_1].Disable = 1;
	////////////////////////////////////////

	//Process[PROC_AVC].Disable = 1;
	//Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	//Process[PROC_OSC].Disable = 1;
	//Process[PROC_OSC].TestMode = 1;

	//Process[PROC_TVL].Disable = 1;
	//Process[PROC_TVL].TestMode = 1;

	//Process[PROC_WIRE_FEED].Disable = 1;
	//Process[PROC_WIRE_FEED].TestMode = 1;

	//Process[PROC_WIRE_PULSE].Disable = 1;
	//Process[PROC_WIRE_PULSE].TestMode = 1;

	//Process[PROC_COOL].Disable = 1;
	//Process[PROC_COOL].TestMode = 1;

	//Process[PROC_GAS].Disable = 1;
	//Process[PROC_GAS].TestMode = 1;

	//Process[PROC_WRST].Disable = 1;
	//Process[PROC_WRST].TestMode = 1;
	
	////////////////////////////////////////////////////////
				
	return 1;
	
}

DINT Configure_BPV_v2_TT_BO_TOS(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;


	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_Aux_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_Aux_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_Aux_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_Aux_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	//TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	//TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = 0;
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = 0;
	
	

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	

		for(i = 0 ; i < TML_RLY_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(TmlRelay[i].Name , "WB_UD");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_UD];
				
					//TmlRelay[i].Cfg.TML_Vect_Indx = VECT_TVL;
					//TmlRelay[i].Cfg.TML_Indx = TML_AX_TVL;

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_OSC;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_OSC;

					TmlRelay[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(TmlRelay[i].Name , "WB_LR");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_LR];

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_AVC;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_AVC;
				
					TmlRelay[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		

		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				//case TML_AX_TVL:  strcpy(TML_MTR_INST[i].Name , "TVL");
				case TML_AX_OSC: strcpy(TML_MTR_INST[i].Name , "OSC"); 
					
					
					//TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; //					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
					
								
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					//TML_MTR_INST[i]._cfg.absFbk = 3;
					TML_MTR_INST[i]._cfg.absFbk = 0;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.16;
									
					//strcpy(TML_MTR_INST[i]._cfg.programName , "1625_BPV2_TVL.sw");											
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1625");
					strcpy(TML_MTR_INST[i]._cfg.programName , "2725_BPV2_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2725");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

										
						
				break;			
				
				//case TML_AX_OSC: strcpy(TML_MTR_INST[i].Name , "OSC");
				case TML_AX_TVL: strcpy(TML_MTR_INST[i].Name , "TVL");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;

					//This is from BPV
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;					
				

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					
					//strcpy(TML_MTR_INST[i]._cfg.programName , "1721_BPV2_OSC.sw");
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1721");

					strcpy(TML_MTR_INST[i]._cfg.programName , "2721_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2721");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					//TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					//TML_MTR_INST[i]._cfg.rev_motor = 3.9 * 50 ;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_motor = 406 * 20;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/360.0 ;
					TML_MTR_INST[i]._cfg.maxVel = fabsf(8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.16;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1723_SMH_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1723");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;


				case TML_AX_WF:
				case TML_AX_WF_1:
				

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				// This was taken from BPV WF & WP
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;


				case TML_AUX_AX_WF:
				case TML_AUX_AX_WF_1:

									
					switch(i){

						case TML_AUX_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF_AUX"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 ;
							TML_MTR_INST[i]._cfg.rev_motor = 3.0;	

							

							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_A_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
						break;

						
						case TML_AUX_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_AUX_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0; ;
							TML_MTR_INST[i]._cfg.rev_motor = -3.0;	


							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_B_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
							
						break;
						

					}

					strcpy(TML_MTR_INST[i]._cfg.programName , "1622_BPV2_INDX.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1622");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 16000 / (1.25 * M_PI * 25.4); // 					
									
			
					TML_MTR_INST[i]._cfg.maxVel = TML_MTR_INST[i]._cfg.units; 
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;
					
					TML_MTR_INST[i]._cfg.HeartBeat = 0.6;	
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;	
				

				/*
				case TML_AX_INDX:
				case TML_AX_INDX_1:


									
					switch(i){

						case TML_AX_INDX:
							
							strcpy(TML_MTR_INST[i].Name , "INDX"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 ;
							TML_MTR_INST[i]._cfg.rev_motor = 3.0;	

							

							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_A_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
						break;

						
						case TML_AX_INDX_1:
							
							strcpy(TML_MTR_INST[i].Name , "INDX_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0; ;
							TML_MTR_INST[i]._cfg.rev_motor = -3.0;	


							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_B_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
							
						break;
						

					}
					


					strcpy(TML_MTR_INST[i]._cfg.programName , "1622_BPV2_INDX.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1622");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 16000 / (1.25 * M_PI * 25.4); // 					
									
			
					TML_MTR_INST[i]._cfg.maxVel = TML_MTR_INST[i]._cfg.units; 
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;
					
					TML_MTR_INST[i]._cfg.HeartBeat = 0.6;	
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;	

				*/
				
				

				default:

					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
					TML_MTR_INST[i].pState = 0;

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}


		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];

		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];

		/* was in BPV2
		AxisCh[TML_AX_TVL].AxisID	= 25;		
		AxisCh[TML_AX_OSC].AxisID 	= 21;	
		*/
		AxisCh[TML_AX_TVL].AxisID	= 21;		
		AxisCh[TML_AX_OSC].AxisID 	= 25;
		
		AxisCh[TML_AX_AVC].AxisID 	= 26;		
		AxisCh[TML_AX_WRST].AxisID 	= 23;

		/*
		AxisCh[TML_AX_INDX].AxisID 	= 22;
		AxisCh[TML_AX_INDX_1].AxisID 	= 24;
		*/
		AxisCh[TML_AUX_AX_WF].AxisID 	= 22;
		AxisCh[TML_AUX_AX_WF_1].AxisID 	= 24;

		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6; 
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;

					
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		
		
		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 1; // TML drives 
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_INDX_CMD];
										
				break;	

			}			
				
		}
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	
		/////////////////////////////////////////////
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 

					WIRE_Param_Set[i].pAuxVect = &VectorStateMach[VECT_AUX_WF];	
					WIRE_Param_Set[i].AuxVectStateNum = 1; //BPV Mode
					
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


			}

		}
		////////////////////////////////////////////////////////
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 3;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


		}


		
	}


	

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	*/
	
	

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby

	//VectorStateMach[VECT_AVC].simul = 1;
	//VectorStateMach[VECT_OSC].simul = 1;	
	//VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	//VectorStateMach[VECT_WF_1].simul = 1;
	//VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_AUX_WF_1].simul = 1;
	VectorStateMach[VECT_AUX_WF].simul = 1;
	//VectorStateMach[VECT_WP_1].simul = 1;
	//VectorStateMach[VECT_WP].simul = 1;
	//VectorStateMach[VECT_WRST].simul = 1;

	//VectorStateMach[VECT_AVC].testMode = 1;
	//VectorStateMach[VECT_OSC].testMode = 1;	
	//VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	//VectorStateMach[VECT_WF_1].testMode = 1;
	//VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_AUX_WF_1].testMode = 1;
	VectorStateMach[VECT_AUX_WF].testMode = 1;
	//VectorStateMach[VECT_WP_1].testMode = 1;
	//VectorStateMach[VECT_WP].testMode = 1;
	//VectorStateMach[VECT_WRST].testMode = 1;	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	//TML_MTR_INST[TML_AX_AVC].Disable = 1;
	//TML_MTR_INST[TML_AX_OSC].Disable = 1;
	//TML_MTR_INST[TML_AX_TVL].Disable = 1;
	//TML_MTR_INST[TML_AX_WRST].Disable = 1;
	//TML_MTR_INST[TML_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AUX_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AUX_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AX_WP].Disable = 1;
	//TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	TML_MTR_INST[TML_AX_INDX].Disable = 1;
	TML_MTR_INST[TML_AX_INDX_1].Disable = 1;
	////////////////////////////////////////

	//Process[PROC_AVC].Disable = 1;
	//Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	//Process[PROC_OSC].Disable = 1;
	//Process[PROC_OSC].TestMode = 1;

	//Process[PROC_TVL].Disable = 1;
	//Process[PROC_TVL].TestMode = 1;

	//Process[PROC_WIRE_FEED].Disable = 1;
	//Process[PROC_WIRE_FEED].TestMode = 1;

	//Process[PROC_WIRE_PULSE].Disable = 1;
	//Process[PROC_WIRE_PULSE].TestMode = 1;

	//Process[PROC_COOL].Disable = 1;
	//Process[PROC_COOL].TestMode = 1;

	//Process[PROC_GAS].Disable = 1;
	//Process[PROC_GAS].TestMode = 1;

	//Process[PROC_WRST].Disable = 1;
	//Process[PROC_WRST].TestMode = 1;
	
	////////////////////////////////////////////////////////
				
	return 1;
	
}


DINT Configure_BPV_v2_MT_BO_TOS(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;


	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
	/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_Aux_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_Aux_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_Aux_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_Aux_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	//TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	//TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = 0;
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = 0;
	
	

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	

		for(i = 0 ; i < TML_RLY_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(TmlRelay[i].Name , "WB_UD");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_UD];
				
					//TmlRelay[i].Cfg.TML_Vect_Indx = VECT_TVL;
					//TmlRelay[i].Cfg.TML_Indx = TML_AX_TVL;

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_OSC;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_OSC;

					TmlRelay[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(TmlRelay[i].Name , "WB_LR");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_LR];

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_AVC;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_AVC;
				
					TmlRelay[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		

		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				//case TML_AX_TVL:  strcpy(TML_MTR_INST[i].Name , "TVL");
				case TML_AX_OSC: strcpy(TML_MTR_INST[i].Name , "OSC"); 
					
												
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 	
					

					TML_MTR_INST[i]._cfg.rev_motor = 73.233;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 1.875 * 25.4 * M_PI) ;					
								
												
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					//TML_MTR_INST[i]._cfg.absFbk = 3;
					TML_MTR_INST[i]._cfg.absFbk = 0;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.16;
									
					//strcpy(TML_MTR_INST[i]._cfg.programName , "1625_BPV2_TVL.sw");											
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1625");
					
					//strcpy(TML_MTR_INST[i]._cfg.programName , "2925_BPV2_TVL_G.sw");											
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2925");

					strcpy(TML_MTR_INST[i]._cfg.programName , "3925_BPV2_TVL_G.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3925"); // New TVL Pos Mode with Interrupt
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

										
						
				break;			
				
				//case TML_AX_OSC: strcpy(TML_MTR_INST[i].Name , "OSC");
				case TML_AX_TVL: strcpy(TML_MTR_INST[i].Name , "TVL");
											
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;

					//This is from BPV
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
				

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "2721_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2721");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					//TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					//TML_MTR_INST[i]._cfg.rev_motor = 3.9 * 50 ;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_motor = 406 * 20;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/360.0 ;
					TML_MTR_INST[i]._cfg.maxVel = fabsf(8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.16;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1723_SMH_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1723");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;


				case TML_AX_WF:
				case TML_AX_WF_1:
				

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				// This was taken from BPV WF & WP
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;


				case TML_AUX_AX_WF:
				case TML_AUX_AX_WF_1:

									
					switch(i){

						case TML_AUX_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF_AUX"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 ;
							TML_MTR_INST[i]._cfg.rev_motor = 3.0;	

							

							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_A_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
						break;

						
						case TML_AUX_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_AUX_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0; ;
							TML_MTR_INST[i]._cfg.rev_motor = -3.0;	


							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_B_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
							
						break;
						

					}

					strcpy(TML_MTR_INST[i]._cfg.programName , "1622_BPV2_INDX.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1622");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 16000 / (1.25 * M_PI * 25.4); // 					
									
			
					TML_MTR_INST[i]._cfg.maxVel = TML_MTR_INST[i]._cfg.units; 
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;
					
					TML_MTR_INST[i]._cfg.HeartBeat = 0.6;	
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;	
				

				
				

				default:

					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
					TML_MTR_INST[i].pState = 0;

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}


		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];

		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];

		/* was in BPV2
		AxisCh[TML_AX_TVL].AxisID	= 25;		
		AxisCh[TML_AX_OSC].AxisID 	= 21;	
		*/
		AxisCh[TML_AX_TVL].AxisID	= 21;		
		AxisCh[TML_AX_OSC].AxisID 	= 25;
		
		AxisCh[TML_AX_AVC].AxisID 	= 26;		
		AxisCh[TML_AX_WRST].AxisID 	= 23;

		
		AxisCh[TML_AUX_AX_WF].AxisID 	= 22;
		AxisCh[TML_AUX_AX_WF_1].AxisID 	= 24;

		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6; 
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		

		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}	
		
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	
		
		////////////////////////////////////////////////////////
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 3;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


		}

				
		for(i=0 ; i < 1 ; i++){ 


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx]; 
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					/*
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 1; // TML drives 
					INDEX_Param_Set[i].MaxSpeed = 24.0; 
					INDEX_Param_Set[i].pCalibPoints 	= &m->pCalib->Points[CALIB_INDX_CMD];
					*/
					INDEX_Param_Set[i].pPrc = 0 ;
					INDEX_Param_Set[i].pCalibPoints = 0;
					INDEX_Param_Set[i].pVect = 0; 
					
											
				break;	

			}			
				
		}

		/////////////////////////////////////////////
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 

					WIRE_Param_Set[i].pAuxVect = &VectorStateMach[VECT_AUX_WF];	
					WIRE_Param_Set[i].AuxVectStateNum = 1; //BPV Mode
					
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


			}

		}
		////////////////////////////////////////////////////////	


		
	}


	

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	*/
	
	

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby

	//VectorStateMach[VECT_AVC].simul = 1;
	//VectorStateMach[VECT_OSC].simul = 1;	
	//VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	//VectorStateMach[VECT_WF_1].simul = 1;
	//VectorStateMach[VECT_WF].simul = 1;
	//VectorStateMach[VECT_AUX_WF_1].simul = 1;
	//VectorStateMach[VECT_AUX_WF].simul = 1;
	//VectorStateMach[VECT_WP_1].simul = 1;
	//VectorStateMach[VECT_WP].simul = 1;
	//VectorStateMach[VECT_WRST].simul = 1;

	//VectorStateMach[VECT_AVC].testMode = 1;
	//VectorStateMach[VECT_OSC].testMode = 1;	
	//VectorStateMach[VECT_TVL].testMode = 1;	
	//VectorStateMach[VECT_INDX_1].testMode = 1;
	//VectorStateMach[VECT_INDX_2].testMode = 1;
	//VectorStateMach[VECT_WF_1].testMode = 1;
	//VectorStateMach[VECT_WF].testMode = 1;
	//VectorStateMach[VECT_AUX_WF_1].testMode = 1;
	//VectorStateMach[VECT_AUX_WF].testMode = 1;
	//VectorStateMach[VECT_WP_1].testMode = 1;
	//VectorStateMach[VECT_WP].testMode = 1;
	//VectorStateMach[VECT_WRST].testMode = 1;	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	//TML_MTR_INST[TML_AX_AVC].Disable = 1;
	//TML_MTR_INST[TML_AX_OSC].Disable = 1;
	//TML_MTR_INST[TML_AX_TVL].Disable = 1;
	//TML_MTR_INST[TML_AX_WRST].Disable = 1;
	//TML_MTR_INST[TML_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AUX_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AUX_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AX_WP].Disable = 1;
	//TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	TML_MTR_INST[TML_AX_INDX].Disable = 1;
	TML_MTR_INST[TML_AX_INDX_1].Disable = 1;
	////////////////////////////////////////

	//Process[PROC_AVC].Disable = 1;
	//Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	//Process[PROC_OSC].Disable = 1;
	//Process[PROC_OSC].TestMode = 1;

	//Process[PROC_TVL].Disable = 1;
	//Process[PROC_TVL].TestMode = 1;

	//Process[PROC_WIRE_FEED].Disable = 1;
	//Process[PROC_WIRE_FEED].TestMode = 1;

	//Process[PROC_WIRE_PULSE].Disable = 1;
	//Process[PROC_WIRE_PULSE].TestMode = 1;

	//Process[PROC_COOL].Disable = 1;
	//Process[PROC_COOL].TestMode = 1;

	//Process[PROC_GAS].Disable = 1;
	//Process[PROC_GAS].TestMode = 1;

	//Process[PROC_WRST].Disable = 1;
	//Process[PROC_WRST].TestMode = 1;
	
	////////////////////////////////////////////////////////
				
	return 1;
	
}

DINT Configure_BPV_v2_TT_BO(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
	/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_Aux_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_Aux_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_Aux_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_Aux_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	//TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	//TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = 0;
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = 0;
	



	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	

		for(i = 0 ; i < TML_RLY_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(TmlRelay[i].Name , "WB_UD");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_UD];
				
					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_TVL;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_TVL;

					TmlRelay[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(TmlRelay[i].Name , "WB_LR");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_LR];

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_AVC;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_AVC;
				
					TmlRelay[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		

		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					strcpy(TML_MTR_INST[i].Name , "TVL");

					// Corrected 29May19
					//TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
					
								
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "1725_BPV2_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1725");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					///////////////////////////////
					
						
				break;			
				
				case TML_AX_OSC:			
									

					strcpy(TML_MTR_INST[i].Name , "OSC");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;

					//This is from BPV
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ; // To jest dobrze
									
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					
									
					// Version Classic
					///*
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "1721_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1721");
					//*/		

										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.maxVel = fabsf(8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					//TML_MTR_INST[i]._cfg.HeartBeat = 2.0;
					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1723_SMH_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1723");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;


				case TML_AX_WF:
				case TML_AX_WF_1:
				

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				// This was taken from BPV WF & WP
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;


				case TML_AUX_AX_WF:
				case TML_AUX_AX_WF_1:

									
					switch(i){

						case TML_AUX_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF_AUX"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 ;
							TML_MTR_INST[i]._cfg.rev_motor = 3.0;	

							

							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_A_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
						break;

						
						case TML_AUX_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_AUX_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0; ;
							TML_MTR_INST[i]._cfg.rev_motor = -3.0;	


							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_B_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
							
						break;
						

					}

					strcpy(TML_MTR_INST[i]._cfg.programName , "1622_BPV2_INDX.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1622");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 16000 / (1.25 * M_PI * 25.4); // 					
									
			
					TML_MTR_INST[i]._cfg.maxVel = TML_MTR_INST[i]._cfg.units; 
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;
					
					TML_MTR_INST[i]._cfg.HeartBeat = 0.6;	
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;	
		
				

				default:

					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
					TML_MTR_INST[i].pState = 0;

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}


		
				
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];

		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];

		
		AxisCh[TML_AX_TVL].AxisID	= 25;		
		AxisCh[TML_AX_OSC].AxisID 	= 21;	
		AxisCh[TML_AX_AVC].AxisID 	= 26;
		AxisCh[TML_AX_WRST].AxisID 	= 23;

		/*
		AxisCh[TML_AX_INDX].AxisID 	= 22;
		AxisCh[TML_AX_INDX_1].AxisID 	= 24;
		*/
		AxisCh[TML_AUX_AX_WF].AxisID 	= 22;
		AxisCh[TML_AUX_AX_WF_1].AxisID 	= 24;

		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6; 
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}	
		

		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	
		
		////////////////////////////////////////////////////////
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 5;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


		}

		for(i=0 ; i < 1 ; i++){ 


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx]; 
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					/*
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 1; // TML drives 
					INDEX_Param_Set[i].MaxSpeed = 24.0; 
					INDEX_Param_Set[i].pCalibPoints 	= &m->pCalib->Points[CALIB_INDX_CMD];
					*/
					INDEX_Param_Set[i].pPrc = 0 ;
					INDEX_Param_Set[i].pCalibPoints = 0;
					INDEX_Param_Set[i].pVect = 0; 
					
											
				break;	

			}			
				
		}

		/////////////////////////////////////////////
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 

					WIRE_Param_Set[i].pAuxVect = &VectorStateMach[VECT_AUX_WF];	
					WIRE_Param_Set[i].AuxVectStateNum = 1; //BPV Mode
					
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


			}

		}


		
	}


	

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	*/
	
	

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby

	//VectorStateMach[VECT_AVC].simul = 1;
	//VectorStateMach[VECT_OSC].simul = 1;	
	//VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	//VectorStateMach[VECT_WF_1].simul = 1;
	//VectorStateMach[VECT_WF].simul = 1;
	//VectorStateMach[VECT_AUX_WF_1].simul = 1;
	//VectorStateMach[VECT_AUX_WF].simul = 1;
	//VectorStateMach[VECT_WP_1].simul = 1;
	//VectorStateMach[VECT_WP].simul = 1;
	//VectorStateMach[VECT_WRST].simul = 1;

	//VectorStateMach[VECT_AVC].testMode = 1;
	//VectorStateMach[VECT_OSC].testMode = 1;	
	//VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	//VectorStateMach[VECT_WF_1].testMode = 1;
	//VectorStateMach[VECT_WF].testMode = 1;
	//VectorStateMach[VECT_AUX_WF_1].testMode = 1;
	//VectorStateMach[VECT_AUX_WF].testMode = 1;
	//VectorStateMach[VECT_WP_1].testMode = 1;
	//VectorStateMach[VECT_WP].testMode = 1;
	//VectorStateMach[VECT_WRST].testMode = 1;	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	//TML_MTR_INST[TML_AX_AVC].Disable = 1;
	//TML_MTR_INST[TML_AX_OSC].Disable = 1;
	//TML_MTR_INST[TML_AX_TVL].Disable = 1;
	//TML_MTR_INST[TML_AX_WRST].Disable = 1;
	//TML_MTR_INST[TML_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AUX_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AUX_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AX_WP].Disable = 1;
	//TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	TML_MTR_INST[TML_AX_INDX].Disable = 1;
	TML_MTR_INST[TML_AX_INDX_1].Disable = 1;
	////////////////////////////////////////

	//Process[PROC_AVC].Disable = 1;
	//Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	//Process[PROC_OSC].Disable = 1;
	//Process[PROC_OSC].TestMode = 1;

	//Process[PROC_TVL].Disable = 1;
	//Process[PROC_TVL].TestMode = 1;

	//Process[PROC_WIRE_FEED].Disable = 1;
	//Process[PROC_WIRE_FEED].TestMode = 1;

	//Process[PROC_WIRE_PULSE].Disable = 1;
	//Process[PROC_WIRE_PULSE].TestMode = 1;

	//Process[PROC_COOL].Disable = 1;
	//Process[PROC_COOL].TestMode = 1;

	//Process[PROC_GAS].Disable = 1;
	//Process[PROC_GAS].TestMode = 1;

	//Process[PROC_WRST].Disable = 1;
	//Process[PROC_WRST].TestMode = 1;
	
	////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////
				
	return 1;
	
}
DINT Configure_BPV_v2_TT_BO_old(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;


	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_Aux_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_Aux_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_Aux_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_Aux_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	//TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	//TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = 0;
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = 0;
	
	

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	

		for(i = 0 ; i < TML_RLY_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(TmlRelay[i].Name , "WB_UD");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_UD];
				
					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_TVL;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_TVL;

					TmlRelay[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(TmlRelay[i].Name , "WB_LR");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_LR];

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_AVC;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_AVC;
				
					TmlRelay[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		

		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					strcpy(TML_MTR_INST[i].Name , "TVL");

					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
					
								
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "1625_BPV2_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1625");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
					
						
				break;			
				
				case TML_AX_OSC:			
									

					strcpy(TML_MTR_INST[i].Name , "OSC");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;

					//This is from BPV
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;

					/* It was in Super Mini
					TML_MTR_INST[i]._cfg.rev_motor = -62.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.5 * 25.4) ;
					*/

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1721_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1721");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					//TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					//TML_MTR_INST[i]._cfg.rev_motor = 3.9 * 50 ;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_motor = 406 * 20;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/360.0 ;
					TML_MTR_INST[i]._cfg.maxVel = fabsf(8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.16;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1723_SMH_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1723");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;


				case TML_AX_WF:
				case TML_AX_WF_1:
				

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				// This was taken from BPV WF & WP
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;


				case TML_AUX_AX_WF:
				case TML_AUX_AX_WF_1:

									
					switch(i){

						case TML_AUX_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF_AUX"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 ;
							TML_MTR_INST[i]._cfg.rev_motor = 3.0;	

							

							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_A_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
						break;

						
						case TML_AUX_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_AUX_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0; ;
							TML_MTR_INST[i]._cfg.rev_motor = -3.0;	


							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_B_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
							
						break;
						

					}

					strcpy(TML_MTR_INST[i]._cfg.programName , "1622_BPV2_INDX.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1622");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 16000 / (1.25 * M_PI * 25.4); // 					
									
			
					TML_MTR_INST[i]._cfg.maxVel = TML_MTR_INST[i]._cfg.units; 
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;
					
					TML_MTR_INST[i]._cfg.HeartBeat = 0.6;	
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;	
				

				/*
				case TML_AX_INDX:
				case TML_AX_INDX_1:


									
					switch(i){

						case TML_AX_INDX:
							
							strcpy(TML_MTR_INST[i].Name , "INDX"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 ;
							TML_MTR_INST[i]._cfg.rev_motor = 3.0;	

							

							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_A_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
						break;

						
						case TML_AX_INDX_1:
							
							strcpy(TML_MTR_INST[i].Name , "INDX_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0; ;
							TML_MTR_INST[i]._cfg.rev_motor = -3.0;	


							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_B_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
							
						break;
						

					}
					


					strcpy(TML_MTR_INST[i]._cfg.programName , "1622_BPV2_INDX.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1622");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 16000 / (1.25 * M_PI * 25.4); // 					
									
			
					TML_MTR_INST[i]._cfg.maxVel = TML_MTR_INST[i]._cfg.units; 
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;
					
					TML_MTR_INST[i]._cfg.HeartBeat = 0.6;	
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;	

				*/
				
				

				default:

					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
					TML_MTR_INST[i].pState = 0;

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}


		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];

		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];

		
		AxisCh[TML_AX_TVL].AxisID	= 25;		
		AxisCh[TML_AX_OSC].AxisID 	= 21;	
		AxisCh[TML_AX_AVC].AxisID 	= 26;
		AxisCh[TML_AX_WRST].AxisID 	= 23;

		/*
		AxisCh[TML_AX_INDX].AxisID 	= 22;
		AxisCh[TML_AX_INDX_1].AxisID 	= 24;
		*/
		AxisCh[TML_AUX_AX_WF].AxisID 	= 22;
		AxisCh[TML_AUX_AX_WF_1].AxisID 	= 24;

		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6; 
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		
		
		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 1; // TML drives 
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_INDX_CMD];
										
				break;	

			}			
				
		}
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	
		/////////////////////////////////////////////
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 

					WIRE_Param_Set[i].pAuxVect = &VectorStateMach[VECT_AUX_WF];	
					WIRE_Param_Set[i].AuxVectStateNum = 1; //BPV Mode
					
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


			}

		}
		////////////////////////////////////////////////////////
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 20;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


		}


		
	}


	

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	*/
	
	

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby

	//VectorStateMach[VECT_AVC].simul = 1;
	//VectorStateMach[VECT_OSC].simul = 1;	
	//VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	//VectorStateMach[VECT_WF_1].simul = 1;
	//VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_AUX_WF_1].simul = 1;
	VectorStateMach[VECT_AUX_WF].simul = 1;
	//VectorStateMach[VECT_WP_1].simul = 1;
	//VectorStateMach[VECT_WP].simul = 1;
	//VectorStateMach[VECT_WRST].simul = 1;

	//VectorStateMach[VECT_AVC].testMode = 1;
	//VectorStateMach[VECT_OSC].testMode = 1;	
	//VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	//VectorStateMach[VECT_WF_1].testMode = 1;
	//VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_AUX_WF_1].testMode = 1;
	VectorStateMach[VECT_AUX_WF].testMode = 1;
	//VectorStateMach[VECT_WP_1].testMode = 1;
	//VectorStateMach[VECT_WP].testMode = 1;
	//VectorStateMach[VECT_WRST].testMode = 1;	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	//TML_MTR_INST[TML_AX_AVC].Disable = 1;
	//TML_MTR_INST[TML_AX_OSC].Disable = 1;
	//TML_MTR_INST[TML_AX_TVL].Disable = 1;
	//TML_MTR_INST[TML_AX_WRST].Disable = 1;
	//TML_MTR_INST[TML_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AUX_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AUX_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AX_WP].Disable = 1;
	//TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	TML_MTR_INST[TML_AX_INDX].Disable = 1;
	TML_MTR_INST[TML_AX_INDX_1].Disable = 1;
	////////////////////////////////////////

	//Process[PROC_AVC].Disable = 1;
	//Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	//Process[PROC_OSC].Disable = 1;
	//Process[PROC_OSC].TestMode = 1;

	//Process[PROC_TVL].Disable = 1;
	//Process[PROC_TVL].TestMode = 1;

	//Process[PROC_WIRE_FEED].Disable = 1;
	//Process[PROC_WIRE_FEED].TestMode = 1;

	//Process[PROC_WIRE_PULSE].Disable = 1;
	//Process[PROC_WIRE_PULSE].TestMode = 1;

	//Process[PROC_COOL].Disable = 1;
	//Process[PROC_COOL].TestMode = 1;

	//Process[PROC_GAS].Disable = 1;
	//Process[PROC_GAS].TestMode = 1;

	//Process[PROC_WRST].Disable = 1;
	//Process[PROC_WRST].TestMode = 1;
	
	////////////////////////////////////////////////////////
				
	return 1;
	
}


DINT Configure_BPV_v2_MPBO(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_Aux_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_Aux_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_Aux_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_Aux_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];


	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	

		for(i = 0 ; i < TML_RLY_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(TmlRelay[i].Name , "WB_UD");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_UD];
				
					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_TVL;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_TVL;

					TmlRelay[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(TmlRelay[i].Name , "WB_LR");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_LR];

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_AVC;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_AVC;
				
					TmlRelay[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		

		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					strcpy(TML_MTR_INST[i].Name , "TVL");

					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
					
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 	
					
					//TML_MTR_INST[i]._cfg.rev_motor = 156;
					//TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;

					TML_MTR_INST[i]._cfg.rev_motor = 73.233;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.875 * 25.4 * M_PI) ;					
								
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel / 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
									
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "3925_BPV2_TVL_G.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3925"); // New TVL Pos Mode with Interrupt
	
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					///////////////////////////////
					
						
				break;			
				
				case TML_AX_OSC:			
									

					strcpy(TML_MTR_INST[i].Name , "OSC");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;

					//This is from BPV
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;

					/* It was in Super Mini
					TML_MTR_INST[i]._cfg.rev_motor = -62.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.5 * 25.4) ;
					*/

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel / 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
									
				
					//strcpy(TML_MTR_INST[i]._cfg.programName , "1721_BPV2_OSC.sw");
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1721");

					//strcpy(TML_MTR_INST[i]._cfg.programName , "2721_BPV2_OSC.sw");
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2721");

					strcpy(TML_MTR_INST[i]._cfg.programName , "3721_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3721");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					//TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					//TML_MTR_INST[i]._cfg.rev_motor = 3.9 * 50 ;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_motor = 406 * 20;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/360.0 ;
					TML_MTR_INST[i]._cfg.maxVel = fabsf(8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.16;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1723_SMH_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1723");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;


				case TML_AX_WF:
				case TML_AX_WF_1:
				

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
						
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				// This was taken from BPV WF & WP
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;


			
				case TML_AX_INDX:
				case TML_AX_INDX_1:


									
					switch(i){

						case TML_AX_INDX:
							
							strcpy(TML_MTR_INST[i].Name , "INDX"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 ;
							TML_MTR_INST[i]._cfg.rev_motor = 3.0;	

							

							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_A_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
						break;

						
						case TML_AX_INDX_1:
							
							strcpy(TML_MTR_INST[i].Name , "INDX_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0; ;
							TML_MTR_INST[i]._cfg.rev_motor = -3.0;	


							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_B_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
							
						break;
						

					}
					


					strcpy(TML_MTR_INST[i]._cfg.programName , "1622_BPV2_INDX.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1622");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 16000 / (1.25 * M_PI * 25.4); // 					
									
			
					TML_MTR_INST[i]._cfg.maxVel = TML_MTR_INST[i]._cfg.units; 
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;
					
					TML_MTR_INST[i]._cfg.HeartBeat = 0.6;	
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;	

							

				default:

					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
					TML_MTR_INST[i].pState = 0;

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}


		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];

		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];

		
		AxisCh[TML_AX_TVL].AxisID	= 25;		
		AxisCh[TML_AX_OSC].AxisID 	= 21;	
		AxisCh[TML_AX_AVC].AxisID 	= 26;
		AxisCh[TML_AX_WRST].AxisID 	= 23;

		
		AxisCh[TML_AX_INDX].AxisID 	= 22;
		AxisCh[TML_AX_INDX_1].AxisID 	= 24;
		
		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6; 
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		

		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		
		for(i=0 ; i < 1 ; i++){ 


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx]; 
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}
		
		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 1; // TML drives 
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_INDX_CMD];
										
				break;	

			}			
				
		}
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	
		/////////////////////////////////////////////
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 

					//WIRE_Param_Set[i].pAuxVect = &VectorStateMach[VECT_AUX_WF];	
					//WIRE_Param_Set[i].AuxVectStateNum = 1; //BPV Mode
					
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


			}

		}
		////////////////////////////////////////////////////////
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					//TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					
					TVL_ROT_Param_Set[i].Mode = 3; //New TVL Pos Mode with Interrupt					
					
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 15;  

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


		}


		
	}


	

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	*/
	
	

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby

	//VectorStateMach[VECT_AVC].simul = 1;
	//VectorStateMach[VECT_OSC].simul = 1;	
	//VectorStateMach[VECT_TVL].simul = 1;	
	//VectorStateMach[VECT_INDX_1].simul = 1;
	//VectorStateMach[VECT_INDX_2].simul = 1;
	//VectorStateMach[VECT_WF_1].simul = 1;
	//VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_AUX_WF_1].simul = 1;
	VectorStateMach[VECT_AUX_WF].simul = 1;
	//VectorStateMach[VECT_WP_1].simul = 1;
	//VectorStateMach[VECT_WP].simul = 1;
	//VectorStateMach[VECT_WRST].simul = 1;

	//VectorStateMach[VECT_AVC].testMode = 1;
	//VectorStateMach[VECT_OSC].testMode = 1;	
	//VectorStateMach[VECT_TVL].testMode = 1;	
	//VectorStateMach[VECT_INDX_1].testMode = 1;
	//VectorStateMach[VECT_INDX_2].testMode = 1;
	//VectorStateMach[VECT_WF_1].testMode = 1;
	//VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_AUX_WF_1].testMode = 1;
	VectorStateMach[VECT_AUX_WF].testMode = 1;
	//VectorStateMach[VECT_WP_1].testMode = 1;
	//VectorStateMach[VECT_WP].testMode = 1;
	//VectorStateMach[VECT_WRST].testMode = 1;	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	//TML_MTR_INST[TML_AX_AVC].Disable = 1;
	//TML_MTR_INST[TML_AX_OSC].Disable = 1;
	//TML_MTR_INST[TML_AX_TVL].Disable = 1;
	//TML_MTR_INST[TML_AX_WRST].Disable = 1;
	//TML_MTR_INST[TML_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AUX_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AUX_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AX_WP].Disable = 1;
	//TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	//TML_MTR_INST[TML_AX_INDX].Disable = 1;
	//TML_MTR_INST[TML_AX_INDX_1].Disable = 1;
	////////////////////////////////////////

	//Process[PROC_AVC].Disable = 1;
	//Process[PROC_AVC].TestMode = 1;

	//Process[PROC_INDX].Disable = 1;
	//Process[PROC_INDX].TestMode = 1;

	//Process[PROC_OSC].Disable = 1;
	//Process[PROC_OSC].TestMode = 1;

	//Process[PROC_TVL].Disable = 1;
	//Process[PROC_TVL].TestMode = 1;

	//Process[PROC_WIRE_FEED].Disable = 1;
	//Process[PROC_WIRE_FEED].TestMode = 1;

	//Process[PROC_WIRE_PULSE].Disable = 1;
	//Process[PROC_WIRE_PULSE].TestMode = 1;

	//Process[PROC_COOL].Disable = 1;
	//Process[PROC_COOL].TestMode = 1;

	//Process[PROC_GAS].Disable = 1;
	//Process[PROC_GAS].TestMode = 1;

	//Process[PROC_WRST].Disable = 1;
	//Process[PROC_WRST].TestMode = 1;
	
	////////////////////////////////////////////////////////
				
	return 1;
	
}


DINT Configure_BPV_v2_MPGH(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];



	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	

		for(i = 0 ; i < TML_RLY_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(TmlRelay[i].Name , "WB_UD");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_UD];
				
					//TmlRelay[i].Cfg.TML_Vect_Indx = VECT_TVL;
					//TmlRelay[i].Cfg.TML_Indx = TML_AX_TVL;

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_INDX_1;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_INDX;

					TmlRelay[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(TmlRelay[i].Name , "WB_LR");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_LR];

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_AVC;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_AVC;
				
					TmlRelay[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		

		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				//case TML_AX_TVL:  strcpy(TML_MTR_INST[i].Name , "TVL");
				case TML_AX_OSC: strcpy(TML_MTR_INST[i].Name , "OSC"); 
					
					
					//TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; //					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;

								
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					//TML_MTR_INST[i]._cfg.absFbk = 3;
					TML_MTR_INST[i]._cfg.absFbk = 0;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.16;
									
					//strcpy(TML_MTR_INST[i]._cfg.programName , "1625_BPV2_TVL.sw");											
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1625");
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "2725_BPV2_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2725");

					//strcpy(TML_MTR_INST[i]._cfg.programName , "2925_BPV2_TVL_G.sw");											
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2925");

					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

										
						
				break;			
				
				//case TML_AX_OSC: strcpy(TML_MTR_INST[i].Name , "OSC");
				case TML_AX_TVL: strcpy(TML_MTR_INST[i].Name , "TVL");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;

					//This is from BPV
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;					
				

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					
					//strcpy(TML_MTR_INST[i]._cfg.programName , "1721_BPV2_OSC.sw");
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1721");

					strcpy(TML_MTR_INST[i]._cfg.programName , "2721_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2721");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
					
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					
					//TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					//TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless
					
	
				break;

				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					//TML_MTR_INST[i]._cfg.rev_motor = 3.9 * 50 ;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_motor = 406 * 20;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/360.0 ;
					TML_MTR_INST[i]._cfg.maxVel = fabsf(8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.16;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1723_SMH_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1723");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;


				case TML_AX_WF:
				case TML_AX_WF_1:
				

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				// This was taken from BPV WF & WP
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;
				
				case TML_AX_INDX:			
				case TML_AX_INDX_1:


				
									
					switch(i){

						case TML_AX_INDX: strcpy(TML_MTR_INST[i].Name , "INDX"); 
												
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 ;
							TML_MTR_INST[i]._cfg.rev_motor = 3.0;	

							

							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_A_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
						break;

						
						case TML_AX_INDX_1:	strcpy(TML_MTR_INST[i].Name , "INDX_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0; ;
							TML_MTR_INST[i]._cfg.rev_motor = -3.0;	


							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_B_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
							
						break;
						

					}				

				

					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_B_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;


					strcpy(TML_MTR_INST[i]._cfg.programName , "1622_BPV2_INDX.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1622");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 16000 / (1.25 * M_PI * 25.4); // 					
									
			
					TML_MTR_INST[i]._cfg.maxVel = TML_MTR_INST[i]._cfg.units; 
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;
					
					TML_MTR_INST[i]._cfg.HeartBeat = 0.6;	
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;		

				
				

				default:

					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
					TML_MTR_INST[i].pState = 0;

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}


	
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];

		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];

		/* was in BPV2
		AxisCh[TML_AX_TVL].AxisID	= 25;		
		AxisCh[TML_AX_OSC].AxisID 	= 21;	
		*/
		AxisCh[TML_AX_TVL].AxisID	= 21;		
		AxisCh[TML_AX_OSC].AxisID 	= 25;
		
		AxisCh[TML_AX_AVC].AxisID 	= 26;		
		AxisCh[TML_AX_WRST].AxisID 	= 23;

		
		AxisCh[TML_AX_INDX].AxisID 	= 22;
		AxisCh[TML_AX_INDX_1].AxisID 	= 24;
		
		//AxisCh[TML_AUX_AX_WF].AxisID 	= 22;
		//AxisCh[TML_AUX_AX_WF_1].AxisID 	= 24;

		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6; 
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 					

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 1; // TML drives 
					INDEX_Param_Set[i].MaxSpeed = 24.0; 
					INDEX_Param_Set[i].pCalibPoints 	= &m->pCalib->Points[CALIB_INDX_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	
		/////////////////////////////////////////////
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


			}

		}
		////////////////////////////////////////////////////////
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 5;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	*/
	
	

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby

	//VectorStateMach[VECT_AVC].simul = 1;
	//VectorStateMach[VECT_OSC].simul = 1;	
	//VectorStateMach[VECT_TVL].simul = 1;	
	//VectorStateMach[VECT_INDX_1].simul = 1;
	//VectorStateMach[VECT_INDX_2].simul = 1;
	//VectorStateMach[VECT_WF_1].simul = 1;
	//VectorStateMach[VECT_WF].simul = 1;
	//VectorStateMach[VECT_WP_1].simul = 1;
	//VectorStateMach[VECT_WP].simul = 1;
	//VectorStateMach[VECT_WRST].simul = 1;

	//VectorStateMach[VECT_AVC].testMode = 1;
	//VectorStateMach[VECT_OSC].testMode = 1;	
	//VectorStateMach[VECT_TVL].testMode = 1;	
	//VectorStateMach[VECT_INDX_1].testMode = 1;
	//VectorStateMach[VECT_INDX_2].testMode = 1;
	//VectorStateMach[VECT_WF_1].testMode = 1;
	//VectorStateMach[VECT_WF].testMode = 1;
	//VectorStateMach[VECT_WP_1].testMode = 1;
	//VectorStateMach[VECT_WP].testMode = 1;
	//VectorStateMach[VECT_WRST].testMode = 1;	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	//TML_MTR_INST[TML_AX_AVC].Disable = 1;
	//TML_MTR_INST[TML_AX_OSC].Disable = 1;
	//TML_MTR_INST[TML_AX_TVL].Disable = 1;
	//TML_MTR_INST[TML_AX_WRST].Disable = 1;
	//TML_MTR_INST[TML_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AX_WP].Disable = 1;
	//TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	//TML_MTR_INST[TML_AX_INDX].Disable = 1;
	//TML_MTR_INST[TML_AX_INDX_1].Disable = 1;
	//TML_MTR_INST[TML_AX_WRST].Disable = 1;	
	////////////////////////////////////////

	//Process[PROC_AVC].Disable = 1;
	//Process[PROC_AVC].TestMode = 1;

	//Process[PROC_INDX].Disable = 1;
	//Process[PROC_INDX].TestMode = 1;

	//Process[PROC_OSC].Disable = 1;
	//Process[PROC_OSC].TestMode = 1;

	//Process[PROC_TVL].Disable = 1;
	//Process[PROC_TVL].TestMode = 1;

	//Process[PROC_WIRE_FEED].Disable = 1;
	//Process[PROC_WIRE_FEED].TestMode = 1;

	//Process[PROC_WIRE_PULSE].Disable = 1;
	//Process[PROC_WIRE_PULSE].TestMode = 1;

	//Process[PROC_COOL].Disable = 1;
	//Process[PROC_COOL].TestMode = 1;

	//Process[PROC_GAS].Disable = 1;
	//Process[PROC_GAS].TestMode = 1;

	//Process[PROC_WRST].Disable = 1;
	//Process[PROC_WRST].TestMode = 1;
	////////////////////////////////////////////////////////
				
	return 1;
	
}



DINT Configure_BPV_v2_MPGV(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.INDX.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];



	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	

		for(i = 0 ; i < TML_RLY_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(TmlRelay[i].Name , "WB_UD");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_UD];
				
					//TmlRelay[i].Cfg.TML_Vect_Indx = VECT_TVL;
					//TmlRelay[i].Cfg.TML_Indx = TML_AX_TVL;

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_INDX_1;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_INDX;

					TmlRelay[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(TmlRelay[i].Name , "WB_LR");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_LR];

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_AVC;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_AVC;
				
					TmlRelay[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		

		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_OSC: strcpy(TML_MTR_INST[i].Name , "OSC"); 
					
												
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 	
					

					TML_MTR_INST[i]._cfg.rev_motor = 73.233;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 1.875 * 25.4 * M_PI) ;					
								
												
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel / 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					//TML_MTR_INST[i]._cfg.absFbk = 3;
					TML_MTR_INST[i]._cfg.absFbk = 0;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.16;
									
					//strcpy(TML_MTR_INST[i]._cfg.programName , "1625_BPV2_TVL.sw");											
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1625");
					
					//strcpy(TML_MTR_INST[i]._cfg.programName , "2925_BPV2_TVL_G.sw");											
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2925");

					strcpy(TML_MTR_INST[i]._cfg.programName , "3925_BPV2_TVL_G.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3925"); // New TVL Pos Mode with Interrupt
	
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
					
						
				break;			
				
				//case TML_AX_OSC: strcpy(TML_MTR_INST[i].Name , "OSC");
				case TML_AX_TVL: strcpy(TML_MTR_INST[i].Name , "TVL");
											
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;

					//This is from BPV
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
				

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel / 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					
					//strcpy(TML_MTR_INST[i]._cfg.programName , "2721_BPV2_OSC.sw");
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2721");

					strcpy(TML_MTR_INST[i]._cfg.programName , "3721_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3721");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					//TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					//TML_MTR_INST[i]._cfg.rev_motor = 3.9 * 50 ;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_motor = 406 * 20;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/360.0 ;
					TML_MTR_INST[i]._cfg.maxVel = fabsf(8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					//TML_MTR_INST[i]._cfg.PVTPeriod = 0.16;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.24;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1723_SMH_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1723");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;				


				case TML_AX_WF:
				case TML_AX_WF_1:
				

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				// This was taken from BPV WF & WP
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;
				

				
				case TML_AX_INDX:			
				case TML_AX_INDX_1:


				
									
					switch(i){

						case TML_AX_INDX: strcpy(TML_MTR_INST[i].Name , "INDX"); 
												
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 ;
							TML_MTR_INST[i]._cfg.rev_motor = 3.0;	

							

							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_A_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
						break;

						
						case TML_AX_INDX_1:	strcpy(TML_MTR_INST[i].Name , "INDX_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0; ;
							TML_MTR_INST[i]._cfg.rev_motor = -3.0;	


							TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[INDX_B_LAST_POS];
							TML_MTR_INST[i]._cfg.absFbk = 2;
							
							
						break;
						

					}	
					

					strcpy(TML_MTR_INST[i]._cfg.programName , "1622_BPV2_INDX.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1622");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 16000 / (1.25 * M_PI * 25.4); // 					
									
			
					TML_MTR_INST[i]._cfg.maxVel = TML_MTR_INST[i]._cfg.units; 
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;
					
					TML_MTR_INST[i]._cfg.HeartBeat = 0.6;	
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;		

							

				default:

					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
					TML_MTR_INST[i].pState = 0;

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}


		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];

		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];

		
		//AxisCh[TML_AX_TVL].AxisID	= 25; // Was in BPV2
		AxisCh[TML_AX_TVL].AxisID	= 21; 	
				
		//AxisCh[TML_AX_OSC].AxisID 	= 21; // Was in BPV2	
		AxisCh[TML_AX_OSC].AxisID 	= 25; 
		
		AxisCh[TML_AX_AVC].AxisID 	= 26;
		AxisCh[TML_AX_WRST].AxisID 	= 23; 

		AxisCh[TML_AX_INDX].AxisID 	= 22;				
		AxisCh[TML_AX_INDX_1].AxisID = 24; 
		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		

		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		
		for(i=0 ; i < 1 ; i++){ 


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx]; 
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 1; // TML drives 
					INDEX_Param_Set[i].MaxSpeed = 24.0; 
					INDEX_Param_Set[i].pCalibPoints 	= &m->pCalib->Points[CALIB_INDX_CMD];

					
										
				break;	

			}			
				
		}

		/////////////////////////////////////////////
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 

					//WIRE_Param_Set[i].pAuxVect = &VectorStateMach[VECT_AUX_WF];	
					//WIRE_Param_Set[i].AuxVectStateNum = 1; //BPV Mode
					
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];


					

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;			


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


			}

		}
		////////////////////////////////////////////////////////

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}			

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					//TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].Mode = 2; //BPV Mode - postion mode
					
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 3;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	*/
	
	

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby

	//VectorStateMach[VECT_AVC].simul = 1;
	//VectorStateMach[VECT_OSC].simul = 1;	
	//VectorStateMach[VECT_TVL].simul = 1;	
	//VectorStateMach[VECT_INDX_1].simul = 1;
	//VectorStateMach[VECT_INDX_2].simul = 1;
	//VectorStateMach[VECT_WF_1].simul = 1;
	//VectorStateMach[VECT_WF].simul = 1;
	//VectorStateMach[VECT_WP_1].simul = 1;
	//VectorStateMach[VECT_WP].simul = 1;
	//VectorStateMach[VECT_WRST].simul = 1;

	//VectorStateMach[VECT_AVC].testMode = 1;
	//VectorStateMach[VECT_OSC].testMode = 1;	
	//VectorStateMach[VECT_TVL].testMode = 1;	
	//VectorStateMach[VECT_INDX_1].testMode = 1;
	//VectorStateMach[VECT_INDX_2].testMode = 1;
	//VectorStateMach[VECT_WF_1].testMode = 1;
	//VectorStateMach[VECT_WF].testMode = 1;
	//VectorStateMach[VECT_WP_1].testMode = 1;
	//VectorStateMach[VECT_WP].testMode = 1;
	//VectorStateMach[VECT_WRST].testMode = 1;	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	//TML_MTR_INST[TML_AX_AVC].Disable = 1;
	//TML_MTR_INST[TML_AX_OSC].Disable = 1;
	//TML_MTR_INST[TML_AX_TVL].Disable = 1;
	//TML_MTR_INST[TML_AX_WRST].Disable = 1;
	//TML_MTR_INST[TML_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AX_WP].Disable = 1;
	//TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	//TML_MTR_INST[TML_AX_INDX].Disable = 1;
	//TML_MTR_INST[TML_AX_INDX_1].Disable = 1;
	//TML_MTR_INST[TML_AX_WRST].Disable = 1;	
	////////////////////////////////////////

	//Process[PROC_AVC].Disable = 1;
	//Process[PROC_AVC].TestMode = 1;

	//Process[PROC_INDX].Disable = 1;
	//Process[PROC_INDX].TestMode = 1;

	//Process[PROC_OSC].Disable = 1;
	//Process[PROC_OSC].TestMode = 1;

	//Process[PROC_TVL].Disable = 1;
	//Process[PROC_TVL].TestMode = 1;

	//Process[PROC_WIRE_FEED].Disable = 1;
	//Process[PROC_WIRE_FEED].TestMode = 1;

	//Process[PROC_WIRE_PULSE].Disable = 1;
	//Process[PROC_WIRE_PULSE].TestMode = 1;

	//Process[PROC_COOL].Disable = 1;
	//Process[PROC_COOL].TestMode = 1;

	//Process[PROC_GAS].Disable = 1;
	//Process[PROC_GAS].TestMode = 1;

	//Process[PROC_WRST].Disable = 1;
	//Process[PROC_WRST].TestMode = 1;
	
	////////////////////////////////////////////////////////
				
	return 1;
	
}






DINT Configure_SUPER_MINI(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	//TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	//TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	

		for(i = 0 ; i < TML_RLY_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(TmlRelay[i].Name , "WB_UD");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_UD];
				
					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_TVL;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_TVL;

					TmlRelay[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(TmlRelay[i].Name , "WB_LR");
					TmlRelay[i].pState = &VectorStateMach[VECT_WB_LR];

					TmlRelay[i].Cfg.TML_Vect_Indx = VECT_AVC;
					TmlRelay[i].Cfg.TML_Indx = TML_AX_AVC;
				
					TmlRelay[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		

		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					strcpy(TML_MTR_INST[i].Name , "TVL");
					// Back EMF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = -231.0; 
					TML_MTR_INST[i]._cfg.rev_scale = (36.0/33.0) /( 1.25 * 25.4 * M_PI) ;
								
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.08;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "1525_SMH_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1525");					
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					///////////////////////////////
					/* from BPV head

					TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;

					TML_MTR_INST[i]._cfg.maxVel =  4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;


					*/

						
				break;			
				
				case TML_AX_OSC:

					strcpy(TML_MTR_INST[i].Name , "OSC");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					/*
					TML_MTR_INST[i]._cfg.rev_motor = -3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					*/
					TML_MTR_INST[i]._cfg.rev_motor = -62.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.5 * 25.4) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1521_SMH_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1521");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.maxVel = fabsf(8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 2.0;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1523_SMH_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1523");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;
				

				case TML_AX_WF:
					
					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;

						/*
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;
						*/

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 400 * 25.4/ 60.0; //// 520 ipm
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "2522_SMH_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2522");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				
				case TML_AX_WP:
				
					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						//case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.0005;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 75.0;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/19.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "1524_SMH_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1524");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;
				

				default:

					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
					TML_MTR_INST[i].pState = 0;

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 6;

		TML_mgr[0].pAxis[0] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];
		TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 25;		
		AxisCh[TML_AX_OSC].AxisID 	= 21;	
		AxisCh[TML_AX_AVC].AxisID 	= 26;
		AxisCh[TML_AX_WRST].AxisID 	= 23;
	
		AxisCh[TML_AX_WF].AxisID 	= 22;
		AxisCh[TML_AX_WP].AxisID 	= 24;
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					//INDEX_Param_Set[i].pPrc = &Process[PROC_INDX];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 0;	
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 
					
					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					//TVL_ROT_Param_Set[i].Mode = 2; //TVL_MODE_BPV_PosMode
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 5;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	TML_MTR_INST[TML_AX_WRST].Disable = 0;	
	*/

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby

	//VectorStateMach[VECT_AVC].simul = 1;
	//VectorStateMach[VECT_OSC].simul = 1;	
	//VectorStateMach[VECT_TVL].simul = 1;	
	//VectorStateMach[VECT_INDX_1].simul = 1;
	//VectorStateMach[VECT_INDX_2].simul = 1;
	//VectorStateMach[VECT_WF_1].simul = 1;
	//VectorStateMach[VECT_WF].simul = 1;
	//VectorStateMach[VECT_WP_1].simul = 1;
	//VectorStateMach[VECT_WP].simul = 1;
	//VectorStateMach[VECT_WRST].simul = 1;

	//VectorStateMach[VECT_AVC].testMode = 1;
	//VectorStateMach[VECT_OSC].testMode = 1;	
	//VectorStateMach[VECT_TVL].testMode = 1;	
	//VectorStateMach[VECT_INDX_1].testMode = 1;
	//VectorStateMach[VECT_INDX_2].testMode = 1;
	//VectorStateMach[VECT_WF_1].testMode = 1;
	//VectorStateMach[VECT_WF].testMode = 1;
	//VectorStateMach[VECT_WP_1].testMode = 1;
	//VectorStateMach[VECT_WP].testMode = 1;
	//VectorStateMach[VECT_WRST].testMode = 1;	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	//TML_MTR_INST[TML_AX_AVC].Disable = 1;
	//TML_MTR_INST[TML_AX_OSC].Disable = 1;
	//TML_MTR_INST[TML_AX_TVL].Disable = 1;
	//TML_MTR_INST[TML_AX_WRST].Disable = 1;
	//TML_MTR_INST[TML_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AX_WP].Disable = 1;
	//TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	////////////////////////////////////////

	//Process[PROC_AVC].Disable = 1;
	//Process[PROC_AVC].TestMode = 1;

	//Process[PROC_INDX].Disable = 1;
	//Process[PROC_INDX].TestMode = 1;

	//Process[PROC_OSC].Disable = 1;
	//Process[PROC_OSC].TestMode = 1;

	//Process[PROC_TVL].Disable = 1;
	//Process[PROC_TVL].TestMode = 1;

	//Process[PROC_WIRE_FEED].Disable = 1;
	//Process[PROC_WIRE_FEED].TestMode = 1;

	//Process[PROC_WIRE_PULSE].Disable = 1;
	//Process[PROC_WIRE_PULSE].TestMode = 1;

	//Process[PROC_COOL].Disable = 1;
	//Process[PROC_COOL].TestMode = 1;

	//Process[PROC_GAS].Disable = 1;
	//Process[PROC_GAS].TestMode = 1;

	//Process[PROC_WRST].Disable = 1;
	//Process[PROC_WRST].TestMode = 1;
	
	////////////////////////////////////////////////////////
				
	return 1;
	
}

DINT Configure_BPV_FACE_OSC(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////

		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
			
			switch(i){			

			
				case DC_INDX_1:
				case DC_INDX_2:

					switch(i){

						case DC_INDX_1:
							
							strcpy(DC_Mtr[i].Name , "DC INDX #1");
					
							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = -1.0;							

						break;
						
						case DC_INDX_2: 
							
							strcpy(DC_Mtr[i].Name , "DC INDX #2");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = 1.0;
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					//DC_Mtr[i].Cfg.rev_scale = 66.0 * 0.218686666; // Ratio gear box 66:1 

					DC_Mtr[i].Cfg.units =48000 / (1.25 * M_PI * 25.4); // 48000 enc ticks / 1.25 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 1; // Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 100.0;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.0;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.1; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;	//max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		

				

				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	
	
				//CalcUnits(&DC_Mtr[i]);
				DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;
	
							
		}
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					strcpy(TML_MTR_INST[i].Name , "TVL");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
								
					TML_MTR_INST[i]._cfg.maxVel =  fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.08;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "0331_BPV_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0331");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;					
	
				break;			
				
				case TML_AX_OSC:

					strcpy(TML_MTR_INST[i].Name , "OSC");

					/*
					// Wersja z Encoderem
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;					

					TML_MTR_INST[i]._cfg.units = 1024 * 4;
				
					TML_MTR_INST[i]._cfg.rev_motor = -75.0/19.0;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/ ((1.0/8.0) * 25.4) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					// Drive swap with WRST
					strcpy(TML_MTR_INST[i]._cfg.programName , "0344_BPV_WRST_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0344");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;
					*/

					strcpy(TML_MTR_INST[i]._cfg.programName , "0354_BPV_WRST_OSC_POT.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0354");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;

					/* to jest stare
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.absFbk = 0; // value fom APOS which is analog Ref
					TML_MTR_INST[i]._cfg.units = 4096.0 ;
					TML_MTR_INST[i]._cfg.rev_motor = 1.0;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 80.0;  // this comes from experiment
					//TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 56.0; // this comes from drawings
					TML_MTR_INST[i]._cfg.maxVel = 100.0; 
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					*/

					// Nowe na probe
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4;				
					TML_MTR_INST[i]._cfg.rev_motor = 75.0/19.0;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/ ((1.0/8.0) * 25.4) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					////////////////////////////

					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;	

					TML_MTR_INST[i]._cfg.actPos2_scale = 80.0/4096.0;
						
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "0323_BPV_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0323");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = -3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 2.0;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					// Drive swap with OSC					
					strcpy(TML_MTR_INST[i]._cfg.programName , "0322_BPV_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0322");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;
				

				case TML_AX_WF:
				case TML_AX_WF_1:

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;
				

				default:

					//strcpy(TML_MTR_INST[i].Name , "Spare ");
					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13; //8;

		TML_mgr[0].pAxis[0] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];
		TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		//AxisCh[TML_AX_OSC].AxisID 	= 2;	
		AxisCh[TML_AX_WRST].AxisID 	= 2;
		AxisCh[TML_AX_AVC].AxisID 	= 3;
		//AxisCh[TML_AX_WRST].AxisID 	= 4;
		AxisCh[TML_AX_OSC].AxisID 	= 4;
		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");

					/** Wersja z Encoder jako feedback					
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;

					*/
										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					OSC_TML_Param_Set[i].Mode = 2; // New BEMF
					OSC_TML_Param_Set[i].PosFbkIndx = 2;

					////  New Oscillation concept - BEMF
					//OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
					OSC_TML_Param_Set[i].mm2ticks = 4096.0/80.0;
					//OSC_TML_Param_Set[i].SpeedFactor = 410;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;

					OSC_TML_Param_Set[i].SpeedFactor = 10.0;

					/////////////////////////
					/////   Hardcoded Limits 
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}
					
					////////////////////////////////////////////////		
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					//INDEX_Param_Set[i].pPrc = &Process[PROC_INDX];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 0;	
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 20;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	*/
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	TML_MTR_INST[TML_AX_WRST].Disable = 0;		

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby
	/*
	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;

	VectorStateMach[VECT_AVC].testMode = 1;
	VectorStateMach[VECT_OSC].testMode = 1;	
	VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	VectorStateMach[VECT_WF_1].testMode = 1;
	VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_WP_1].testMode = 1;
	VectorStateMach[VECT_WP].testMode = 1;

	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1;
	TML_MTR_INST[TML_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AX_WP].Disable = 1;
	TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	////////////////////////////////////////

	Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;

	Process[PROC_TVL].Disable = 1;
	Process[PROC_TVL].TestMode = 1;

	Process[PROC_WIRE_FEED].Disable = 1;
	Process[PROC_WIRE_FEED].TestMode = 1;

	Process[PROC_WIRE_PULSE].Disable = 1;
	Process[PROC_WIRE_PULSE].TestMode = 1;

	Process[PROC_COOL].Disable = 1;
	Process[PROC_COOL].TestMode = 1;

	Process[PROC_GAS].Disable = 1;
	Process[PROC_GAS].TestMode = 1;
	*/
	////////////////////////////////////////////////////////
				
	return 1;
	
}

DINT Configure_BPV_FACE_OSC_ENC(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////

		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
			
			switch(i){			

			
				case DC_INDX_1:
				case DC_INDX_2:

					switch(i){

						case DC_INDX_1:
							
							strcpy(DC_Mtr[i].Name , "DC INDX #1");
					
							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = -1.0;							

						break;
						
						case DC_INDX_2: 
							
							strcpy(DC_Mtr[i].Name , "DC INDX #2");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = 1.0;
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					//DC_Mtr[i].Cfg.rev_scale = 66.0 * 0.218686666; // Ratio gear box 66:1 

					DC_Mtr[i].Cfg.units =48000 / (1.25 * M_PI * 25.4); // 48000 enc ticks / 1.25 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 1; // Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 100.0;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.0;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.1; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;	//max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		

				

				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	
	
				//CalcUnits(&DC_Mtr[i]);
				DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;
	
							
		}
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					strcpy(TML_MTR_INST[i].Name , "TVL");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
								
					TML_MTR_INST[i]._cfg.maxVel =  fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.08;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "0331_BPV_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0331");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;					
	
				break;			
				
				case TML_AX_OSC:

					strcpy(TML_MTR_INST[i].Name , "OSC");

					
					// Wersja z Encoderem
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;					

					TML_MTR_INST[i]._cfg.units = 1024 * 4;
				
					TML_MTR_INST[i]._cfg.rev_motor = -75.0/19.0;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/ ((1.0/8.0) * 25.4) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					//TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					// Drive swap with WRST
					/*
					strcpy(TML_MTR_INST[i]._cfg.programName , "0344_BPV_WRST_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0344");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;
					*/
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "0354_BPV_WRST_OSC_POT.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0354");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;

					
					// Nowe na probe
					/*
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4;				
					TML_MTR_INST[i]._cfg.rev_motor = 75.0/19.0;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/ ((1.0/8.0) * 25.4) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					////////////////////////////

					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;	

					TML_MTR_INST[i]._cfg.actPos2_scale = 80.0/4096.0;
					*/	
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "0323_BPV_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0323");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = -3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 2.0;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					// Drive swap with OSC					
					strcpy(TML_MTR_INST[i]._cfg.programName , "0322_BPV_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0322");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;
				

				case TML_AX_WF:
				case TML_AX_WF_1:

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;
				

				default:

					//strcpy(TML_MTR_INST[i].Name , "Spare ");
					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];
		TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		//AxisCh[TML_AX_OSC].AxisID 	= 2;	
		AxisCh[TML_AX_WRST].AxisID 	= 2;
		AxisCh[TML_AX_AVC].AxisID 	= 3;
		//AxisCh[TML_AX_WRST].AxisID 	= 4;
		AxisCh[TML_AX_OSC].AxisID 	= 4;
		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");

					/** Wersja z Encoder jako feedback	*/				
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;

					///////////////////////////////////
					/*					
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					OSC_TML_Param_Set[i].Mode = 2; // New BEMF
					OSC_TML_Param_Set[i].PosFbkIndx = 2;

					////  New Oscillation concept - BEMF
					//OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
					OSC_TML_Param_Set[i].mm2ticks = 4096.0/80.0;
					//OSC_TML_Param_Set[i].SpeedFactor = 410;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;

					OSC_TML_Param_Set[i].SpeedFactor = 10.0;
					*/
					//////////////////////////////////////////////////////////////

					/////////////////////////
					/////   Hardcoded Limits 
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}
					
					////////////////////////////////////////////////		
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					//INDEX_Param_Set[i].pPrc = &Process[PROC_INDX];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 0;	
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 20;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	*/
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	TML_MTR_INST[TML_AX_WRST].Disable = 0;		

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby
	/*
	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;

	VectorStateMach[VECT_AVC].testMode = 1;
	VectorStateMach[VECT_OSC].testMode = 1;	
	VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	VectorStateMach[VECT_WF_1].testMode = 1;
	VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_WP_1].testMode = 1;
	VectorStateMach[VECT_WP].testMode = 1;

	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1;
	TML_MTR_INST[TML_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AX_WP].Disable = 1;
	TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	////////////////////////////////////////

	Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;

	Process[PROC_TVL].Disable = 1;
	Process[PROC_TVL].TestMode = 1;

	Process[PROC_WIRE_FEED].Disable = 1;
	Process[PROC_WIRE_FEED].TestMode = 1;

	Process[PROC_WIRE_PULSE].Disable = 1;
	Process[PROC_WIRE_PULSE].TestMode = 1;

	Process[PROC_COOL].Disable = 1;
	Process[PROC_COOL].TestMode = 1;

	Process[PROC_GAS].Disable = 1;
	Process[PROC_GAS].TestMode = 1;
	*/
	////////////////////////////////////////////////////////
				
	return 1;
	
}


DINT Configure_CHERRYPOINT_MT_BP2_HEAD(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////

		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
			
			switch(i){			

			
				case DC_INDX_1:
				case DC_INDX_2:

					switch(i){

						case DC_INDX_1:
							
							strcpy(DC_Mtr[i].Name , "DC INDX #1");
					
							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = -1.0;							

						break;
						
						case DC_INDX_2: 
							
							strcpy(DC_Mtr[i].Name , "DC INDX #2");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = 1.0;
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					//DC_Mtr[i].Cfg.rev_scale = 66.0 * 0.218686666; // Ratio gear box 66:1 

					DC_Mtr[i].Cfg.units =48000 / (1.25 * M_PI * 25.4); // 48000 enc ticks / 1.25 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 1; // Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 100.0;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.0;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.1; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;	//max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		

				

				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	
	
				//CalcUnits(&DC_Mtr[i]);
				DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;
	
							
		}
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					strcpy(TML_MTR_INST[i].Name , "TVL");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
					
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 	
					
					//TML_MTR_INST[i]._cfg.rev_motor = 156;
					//TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;

					TML_MTR_INST[i]._cfg.rev_motor = 73.233;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.875 * 25.4 * M_PI) ;					
								
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel / 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
									
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "3925_BPV2_TVL_G.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3925"); // New TVL Pos Mode with Interrupt
	
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					///////////////////////////////
					
					
	
				break;			
				
				case TML_AX_OSC:

					strcpy(TML_MTR_INST[i].Name , "OSC");
					
					// Wersja z Encoderem
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;					

					TML_MTR_INST[i]._cfg.units = 1024 * 4;
				
					TML_MTR_INST[i]._cfg.rev_motor = -75.0/19.0;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/ ((1.0/8.0) * 25.4) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 0;

					//TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;									
					
					/*
					strcpy(TML_MTR_INST[i]._cfg.programName , "0354_BPV_WRST_OSC_POT.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0354");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;
					*/

					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "2023_BPV2_OSC_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2023");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;	

					//TML_MTR_INST[i]._cfg.actPos2_scale = 80.0/4096.0;
					// Po zmianach Davida
					TML_MTR_INST[i]._cfg.actPos2_scale = 70.0/4006.0;
			
	
				break;

				case TML_AX_AVC:

					// Wziete z BPV_v2
					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless
					
					
				break;


				case TML_AX_WRST:

					// Wziete z BPV_v2
					strcpy(TML_MTR_INST[i].Name , "WRST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;

					//This is from BPV
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ; // To jest dobrze
									
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					
									
					// Version Classic
					///*
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "1721_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1721");
					
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					
					
	
				break;
				

				case TML_AX_WF:
				case TML_AX_WF_1:


					// Wziete z BPV_v2
					
					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; //					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					

					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0;	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;

					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										

					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

			
					
						
				break;

				
				case TML_AX_WP:
				case TML_AX_WP_1:

					// Wziete z BPV_v2

					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;


					
						
				break;
				

				default:

					//strcpy(TML_MTR_INST[i].Name , "Spare ");
					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}
		
		/* Z BPV
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 8;

		TML_mgr[0].pAxis[0] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];
		TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		//AxisCh[TML_AX_OSC].AxisID 	= 2;	
		AxisCh[TML_AX_WRST].AxisID 	= 2;
		AxisCh[TML_AX_AVC].AxisID 	= 3;
		//AxisCh[TML_AX_WRST].AxisID 	= 4;
		AxisCh[TML_AX_OSC].AxisID 	= 4;
		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		*/


		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];

		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];

		
		AxisCh[TML_AX_TVL].AxisID	= 25;		
		AxisCh[TML_AX_OSC].AxisID 	= 23; //21;	
		AxisCh[TML_AX_AVC].AxisID 	= 26;
		AxisCh[TML_AX_WRST].AxisID 	= 21; //23;

		AxisCh[TML_AX_INDX].AxisID 	= 22;
		AxisCh[TML_AX_INDX_1].AxisID 	= 24;

		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					/* Version for Not POT
					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");

					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					*/

					//////////////////////////////////////
					/////////////////////////////////////
					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					OSC_TML_Param_Set[i].Mode = 3; 
					OSC_TML_Param_Set[i].PosFbkIndx = 2;

					
					//OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
					OSC_TML_Param_Set[i].mm2ticks = 4096.0/80.0;
					//OSC_TML_Param_Set[i].SpeedFactor = 410;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;

					OSC_TML_Param_Set[i].SpeedFactor = 10.0;

					/////////////////////////
					/////   Hardcoded Limits 
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}				
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					//INDEX_Param_Set[i].pPrc = &Process[PROC_INDX];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 0;	
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					//TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 

					TVL_ROT_Param_Set[i].Mode = 3; //New TVL Pos Mode with Interrupt
					
					
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 15;  

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;

			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	
	Process[PROC_OSC].Disable = 0;
	Process[PROC_OSC].TestMode = 0;
	VectorStateMach[VECT_OSC].simul = 0;
	TML_MTR_INST[TML_AX_OSC].Disable = 0;
	
	/*
	Process[PROC_WRST].Disable = 1;
	Process[PROC_WRST].TestMode = 1;
	VectorStateMach[VECT_WRST].simul = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1;
	*/

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby
	/*
	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;

	VectorStateMach[VECT_AVC].testMode = 1;
	VectorStateMach[VECT_OSC].testMode = 1;	
	VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	VectorStateMach[VECT_WF_1].testMode = 1;
	VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_WP_1].testMode = 1;
	VectorStateMach[VECT_WP].testMode = 1;

	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1;
	TML_MTR_INST[TML_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AX_WP].Disable = 1;
	TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	////////////////////////////////////////

	Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;

	Process[PROC_TVL].Disable = 1;
	Process[PROC_TVL].TestMode = 1;

	Process[PROC_WIRE_FEED].Disable = 1;
	Process[PROC_WIRE_FEED].TestMode = 1;

	Process[PROC_WIRE_PULSE].Disable = 1;
	Process[PROC_WIRE_PULSE].TestMode = 1;

	Process[PROC_COOL].Disable = 1;
	Process[PROC_COOL].TestMode = 1;

	Process[PROC_GAS].Disable = 1;
	Process[PROC_GAS].TestMode = 1;
	*/
	////////////////////////////////////////////////////////
				
	return 1;
	
}


DINT Configure_CHERRYPOINT_BPV2_HEAD(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////

		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
			
			switch(i){			

			
				case DC_INDX_1:
				case DC_INDX_2:

					switch(i){

						case DC_INDX_1:
							
							strcpy(DC_Mtr[i].Name , "DC INDX #1");
					
							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = -1.0;							

						break;
						
						case DC_INDX_2: 
							
							strcpy(DC_Mtr[i].Name , "DC INDX #2");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = 1.0;
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					//DC_Mtr[i].Cfg.rev_scale = 66.0 * 0.218686666; // Ratio gear box 66:1 

					DC_Mtr[i].Cfg.units =48000 / (1.25 * M_PI * 25.4); // 48000 enc ticks / 1.25 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 1; // Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 100.0;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.0;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.1; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;	//max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		

				

				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	
	
				//CalcUnits(&DC_Mtr[i]);
				DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;
	
							
		}
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					// Wziete z BPV_v2

					strcpy(TML_MTR_INST[i].Name , "TVL");

					// Corrected 29May19
					//TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
					
								
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "1725_BPV2_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1725");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					///////////////////////////////

					/*

					strcpy(TML_MTR_INST[i].Name , "TVL");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
								
					TML_MTR_INST[i]._cfg.maxVel =  fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.08;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "0331_BPV_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0331");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;	
					*/
	
				break;			
				
				case TML_AX_OSC:

					strcpy(TML_MTR_INST[i].Name , "OSC");

					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;					

					TML_MTR_INST[i]._cfg.units = 1024 * 4;
				
					TML_MTR_INST[i]._cfg.rev_motor = -75.0/19.0;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/ ((1.0/8.0) * 25.4) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;

					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					
									
					// Version Classic
					///*
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;

					/*
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 0;

					//TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					*/
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "2023_BPV2_OSC_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2023");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					
					//TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					//TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;	

					//TML_MTR_INST[i]._cfg.actPos2_scale = 70.0/4006.0;

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;	

					TML_MTR_INST[i]._cfg.actPos2_scale = 0.0;
						
				
	
				break;

				case TML_AX_AVC:

					// Wziete z BPV_v2
					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless
					
					/*
					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "0323_BPV_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0323");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/
	
				break;


				case TML_AX_WRST:

					// Wziete z BPV_v2
					strcpy(TML_MTR_INST[i].Name , "WRST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;

					//This is from BPV
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ; // To jest dobrze
									
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					
									
					// Version Classic
					///*
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "1721_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1721");
					
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					
					
					/*
					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = -3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 2.0;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					// Drive swap with OSC					
					strcpy(TML_MTR_INST[i]._cfg.programName , "0322_BPV_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0322");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;
					*/
				
	
				break;
				

				case TML_AX_WF:
				case TML_AX_WF_1:


					// Wziete z BPV_v2
					
					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; //					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					

					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0;	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;

					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										

					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

			
					/*
					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
					*/
						
				break;

				
				case TML_AX_WP:
				case TML_AX_WP_1:

					// Wziete z BPV_v2

					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;


					/*
					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					*/

						
				break;
				

				default:

					//strcpy(TML_MTR_INST[i].Name , "Spare ");
					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}
		
		/* Z BPV
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 8;

		TML_mgr[0].pAxis[0] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];
		TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		//AxisCh[TML_AX_OSC].AxisID 	= 2;	
		AxisCh[TML_AX_WRST].AxisID 	= 2;
		AxisCh[TML_AX_AVC].AxisID 	= 3;
		//AxisCh[TML_AX_WRST].AxisID 	= 4;
		AxisCh[TML_AX_OSC].AxisID 	= 4;
		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		*/


		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];

		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];

		
		AxisCh[TML_AX_TVL].AxisID	= 25;		
		AxisCh[TML_AX_OSC].AxisID 	= 23; //21;	
		AxisCh[TML_AX_AVC].AxisID 	= 26;
		AxisCh[TML_AX_WRST].AxisID 	= 21; //23;

		AxisCh[TML_AX_INDX].AxisID 	= 22;
		AxisCh[TML_AX_INDX_1].AxisID 	= 24;

		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");

					/* Tak bylo we Flange										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					OSC_TML_Param_Set[i].Mode = 3; // Exp BEMF
					OSC_TML_Param_Set[i].PosFbkIndx = 2;

					////  New Oscillation concept - BEMF
					//OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
					OSC_TML_Param_Set[i].mm2ticks = 4096.0/80.0;
					//OSC_TML_Param_Set[i].SpeedFactor = 410;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;

					OSC_TML_Param_Set[i].SpeedFactor = 10.0;
					*/
					////////////

					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					

					//////////////

					/////////////////////////
					/////   Hardcoded Limits 
					/*
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}
					*/
					////////////////////////////////////////////////		
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					//INDEX_Param_Set[i].pPrc = &Process[PROC_INDX];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 0;	
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 20;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	
	Process[PROC_OSC].Disable = 0;
	Process[PROC_OSC].TestMode = 0;
	VectorStateMach[VECT_OSC].simul = 0;
	TML_MTR_INST[TML_AX_OSC].Disable = 0;
	
	/*
	Process[PROC_WRST].Disable = 1;
	Process[PROC_WRST].TestMode = 1;
	VectorStateMach[VECT_WRST].simul = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1;
	*/

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby
	/*
	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;

	VectorStateMach[VECT_AVC].testMode = 1;
	VectorStateMach[VECT_OSC].testMode = 1;	
	VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	VectorStateMach[VECT_WF_1].testMode = 1;
	VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_WP_1].testMode = 1;
	VectorStateMach[VECT_WP].testMode = 1;

	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1;
	TML_MTR_INST[TML_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AX_WP].Disable = 1;
	TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	////////////////////////////////////////

	Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;

	Process[PROC_TVL].Disable = 1;
	Process[PROC_TVL].TestMode = 1;

	Process[PROC_WIRE_FEED].Disable = 1;
	Process[PROC_WIRE_FEED].TestMode = 1;

	Process[PROC_WIRE_PULSE].Disable = 1;
	Process[PROC_WIRE_PULSE].TestMode = 1;

	Process[PROC_COOL].Disable = 1;
	Process[PROC_COOL].TestMode = 1;

	Process[PROC_GAS].Disable = 1;
	Process[PROC_GAS].TestMode = 1;
	*/
	////////////////////////////////////////////////////////
				
	return 1;
	
}

DINT Configure_BPV2_FACE_OSC_EXP(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////

		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
			
			switch(i){			

			
				case DC_INDX_1:
				case DC_INDX_2:

					switch(i){

						case DC_INDX_1:
							
							strcpy(DC_Mtr[i].Name , "DC INDX #1");
					
							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = -1.0;							

						break;
						
						case DC_INDX_2: 
							
							strcpy(DC_Mtr[i].Name , "DC INDX #2");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = 1.0;
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					//DC_Mtr[i].Cfg.rev_scale = 66.0 * 0.218686666; // Ratio gear box 66:1 

					DC_Mtr[i].Cfg.units =48000 / (1.25 * M_PI * 25.4); // 48000 enc ticks / 1.25 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 1; // Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 100.0;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.0;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.1; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;	//max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		

				

				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	
	
				//CalcUnits(&DC_Mtr[i]);
				DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;
	
							
		}
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					// Wziete z BPV_v2

					strcpy(TML_MTR_INST[i].Name , "TVL");

					// Corrected 29May19
					//TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
					
								
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "1725_BPV2_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1725");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					///////////////////////////////

					/*

					strcpy(TML_MTR_INST[i].Name , "TVL");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
								
					TML_MTR_INST[i]._cfg.maxVel =  fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.08;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "0331_BPV_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0331");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;	
					*/
	
				break;			
				
				case TML_AX_OSC:

					strcpy(TML_MTR_INST[i].Name , "OSC");

					
					// Wersja z Encoderem
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;					

					TML_MTR_INST[i]._cfg.units = 1024 * 4;
				
					TML_MTR_INST[i]._cfg.rev_motor = -75.0/19.0;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/ ((1.0/8.0) * 25.4) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 0;

					//TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;									
					
					/*
					strcpy(TML_MTR_INST[i]._cfg.programName , "0354_BPV_WRST_OSC_POT.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0354");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;
					*/

					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "2023_BPV2_OSC_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2023");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;	

					//TML_MTR_INST[i]._cfg.actPos2_scale = 80.0/4096.0;
					// Po zmianach Davida
					TML_MTR_INST[i]._cfg.actPos2_scale = 70.0/4006.0;
						
				
	
				break;

				case TML_AX_AVC:

					// Wziete z BPV_v2
					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "1526_SMH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1526");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;

					TML_MTR_INST[i]._cfg.MtrType = 1 ; // 3phase brusshless
					
					/*
					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "0323_BPV_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0323");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/
	
				break;


				case TML_AX_WRST:

					// Wziete z BPV_v2
					strcpy(TML_MTR_INST[i].Name , "WRST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;

					//This is from BPV
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ; // To jest dobrze
									
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					
									
					// Version Classic
					///*
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "1721_BPV2_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1721");
					
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					
					
					/*
					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = -3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 2.0;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					// Drive swap with OSC					
					strcpy(TML_MTR_INST[i]._cfg.programName , "0322_BPV_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0322");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;
					*/
				
	
				break;
				

				case TML_AX_WF:
				case TML_AX_WF_1:


					// Wziete z BPV_v2
					
					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; //					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					

					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0;	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;

					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										

					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

			
					/*
					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
					*/
						
				break;

				
				case TML_AX_WP:
				case TML_AX_WP_1:

					// Wziete z BPV_v2

					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;


					/*
					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					*/

						
				break;
				

				default:

					//strcpy(TML_MTR_INST[i].Name , "Spare ");
					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}
		
		/* Z BPV
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 8;

		TML_mgr[0].pAxis[0] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];
		TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		//AxisCh[TML_AX_OSC].AxisID 	= 2;	
		AxisCh[TML_AX_WRST].AxisID 	= 2;
		AxisCh[TML_AX_AVC].AxisID 	= 3;
		//AxisCh[TML_AX_WRST].AxisID 	= 4;
		AxisCh[TML_AX_OSC].AxisID 	= 4;
		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		*/


		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = 0;
		TML_mgr[0].pAxis[1] = &AxisCh[0];

		TML_mgr[0].pTML[0] = 0;
		TML_mgr[0].pTML[1] = &TML_MTR_INST[0];

		
		AxisCh[TML_AX_TVL].AxisID	= 25;		
		AxisCh[TML_AX_OSC].AxisID 	= 23; //21;	
		AxisCh[TML_AX_AVC].AxisID 	= 26;
		AxisCh[TML_AX_WRST].AxisID 	= 21; //23;

		AxisCh[TML_AX_INDX].AxisID 	= 22;
		AxisCh[TML_AX_INDX_1].AxisID 	= 24;

		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					OSC_TML_Param_Set[i].Mode = 3; // Exp BEMF
					OSC_TML_Param_Set[i].PosFbkIndx = 2;

					////  New Oscillation concept - BEMF
					//OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
					OSC_TML_Param_Set[i].mm2ticks = 4096.0/80.0;
					//OSC_TML_Param_Set[i].SpeedFactor = 410;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;

					OSC_TML_Param_Set[i].SpeedFactor = 10.0;

					/////////////////////////
					/////   Hardcoded Limits 
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}
					
					////////////////////////////////////////////////		
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					//INDEX_Param_Set[i].pPrc = &Process[PROC_INDX];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 0;	
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 20;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	
	Process[PROC_OSC].Disable = 0;
	Process[PROC_OSC].TestMode = 0;
	VectorStateMach[VECT_OSC].simul = 0;
	TML_MTR_INST[TML_AX_OSC].Disable = 0;
	
	/*
	Process[PROC_WRST].Disable = 1;
	Process[PROC_WRST].TestMode = 1;
	VectorStateMach[VECT_WRST].simul = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1;
	*/

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby
	/*
	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;

	VectorStateMach[VECT_AVC].testMode = 1;
	VectorStateMach[VECT_OSC].testMode = 1;	
	VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	VectorStateMach[VECT_WF_1].testMode = 1;
	VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_WP_1].testMode = 1;
	VectorStateMach[VECT_WP].testMode = 1;

	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1;
	TML_MTR_INST[TML_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AX_WP].Disable = 1;
	TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	////////////////////////////////////////

	Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;

	Process[PROC_TVL].Disable = 1;
	Process[PROC_TVL].TestMode = 1;

	Process[PROC_WIRE_FEED].Disable = 1;
	Process[PROC_WIRE_FEED].TestMode = 1;

	Process[PROC_WIRE_PULSE].Disable = 1;
	Process[PROC_WIRE_PULSE].TestMode = 1;

	Process[PROC_COOL].Disable = 1;
	Process[PROC_COOL].TestMode = 1;

	Process[PROC_GAS].Disable = 1;
	Process[PROC_GAS].TestMode = 1;
	*/
	////////////////////////////////////////////////////////
				
	return 1;
	
}


DINT Configure_BPV_FACE_OSC_EXP(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////

		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
			
			switch(i){			

			
				case DC_INDX_1:
				case DC_INDX_2:

					switch(i){

						case DC_INDX_1:
							
							strcpy(DC_Mtr[i].Name , "DC INDX #1");
					
							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = -1.0;							

						break;
						
						case DC_INDX_2: 
							
							strcpy(DC_Mtr[i].Name , "DC INDX #2");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = 1.0;
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					//DC_Mtr[i].Cfg.rev_scale = 66.0 * 0.218686666; // Ratio gear box 66:1 

					DC_Mtr[i].Cfg.units =48000 / (1.25 * M_PI * 25.4); // 48000 enc ticks / 1.25 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 1; // Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 100.0;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.0;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.1; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;	//max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		

				

				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	
	
				//CalcUnits(&DC_Mtr[i]);
				DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;
	
							
		}
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					strcpy(TML_MTR_INST[i].Name , "TVL");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
								
					TML_MTR_INST[i]._cfg.maxVel =  fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.08;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "0331_BPV_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0331");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;					
	
				break;			
				
				case TML_AX_OSC:

					strcpy(TML_MTR_INST[i].Name , "OSC");

					
					// Wersja z Encoderem
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;					

					TML_MTR_INST[i]._cfg.units = 1024 * 4;
				
					TML_MTR_INST[i]._cfg.rev_motor = -75.0/19.0;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/ ((1.0/8.0) * 25.4) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 0;

					//TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;									
					

					strcpy(TML_MTR_INST[i]._cfg.programName , "0354_BPV_WRST_OSC_POT.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0354");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;

					
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;	

					TML_MTR_INST[i]._cfg.actPos2_scale = 80.0/4096.0;
						
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "0323_BPV_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0323");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = -3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 2.0;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					// Drive swap with OSC					
					strcpy(TML_MTR_INST[i]._cfg.programName , "0322_BPV_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0322");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;
				

				case TML_AX_WF:
				case TML_AX_WF_1:

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;
				

				default:

					//strcpy(TML_MTR_INST[i].Name , "Spare ");
					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13; //8;

		TML_mgr[0].pAxis[0] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];
		TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		//AxisCh[TML_AX_OSC].AxisID 	= 2;	
		AxisCh[TML_AX_WRST].AxisID 	= 2;
		AxisCh[TML_AX_AVC].AxisID 	= 3;
		//AxisCh[TML_AX_WRST].AxisID 	= 4;
		AxisCh[TML_AX_OSC].AxisID 	= 4;
		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					OSC_TML_Param_Set[i].Mode = 3; // Exp BEMF
					OSC_TML_Param_Set[i].PosFbkIndx = 2;

					////  New Oscillation concept - BEMF
					//OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
					OSC_TML_Param_Set[i].mm2ticks = 4096.0/80.0;
					//OSC_TML_Param_Set[i].SpeedFactor = 410;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;

					OSC_TML_Param_Set[i].SpeedFactor = 10.0;

					/////////////////////////
					/////   Hardcoded Limits 
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}
					
					////////////////////////////////////////////////		
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					//INDEX_Param_Set[i].pPrc = &Process[PROC_INDX];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 0;	
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 20;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	*/
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	TML_MTR_INST[TML_AX_WRST].Disable = 0;		

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby
	/*
	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;

	VectorStateMach[VECT_AVC].testMode = 1;
	VectorStateMach[VECT_OSC].testMode = 1;	
	VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	VectorStateMach[VECT_WF_1].testMode = 1;
	VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_WP_1].testMode = 1;
	VectorStateMach[VECT_WP].testMode = 1;

	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1;
	TML_MTR_INST[TML_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AX_WP].Disable = 1;
	TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	////////////////////////////////////////

	Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;

	Process[PROC_TVL].Disable = 1;
	Process[PROC_TVL].TestMode = 1;

	Process[PROC_WIRE_FEED].Disable = 1;
	Process[PROC_WIRE_FEED].TestMode = 1;

	Process[PROC_WIRE_PULSE].Disable = 1;
	Process[PROC_WIRE_PULSE].TestMode = 1;

	Process[PROC_COOL].Disable = 1;
	Process[PROC_COOL].TestMode = 1;

	Process[PROC_GAS].Disable = 1;
	Process[PROC_GAS].TestMode = 1;
	*/
	////////////////////////////////////////////////////////
				
	return 1;
	
}

DINT Configure_M_94(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	
	
	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}

		/////////////////////////////////////////////////////////////////////////////////

		for(i = 0 ; i < GEN_MTR_NUM; i++){
			
			switch(i){			

			
				case DC_INDX_1:
				case DC_INDX_2:

					switch(i){

						case DC_INDX_1:
							
							strcpy(DC_Mtr[i].Name , "DC INDX #1");
					
							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = -1.0;							

						break;
						
						case DC_INDX_2: 
							
							strcpy(DC_Mtr[i].Name , "DC INDX #2");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = 1.0;
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					//DC_Mtr[i].Cfg.rev_scale = 66.0 * 0.218686666; // Ratio gear box 66:1 

					DC_Mtr[i].Cfg.units =48000 / (1.25 * M_PI * 25.4); // 48000 enc ticks / 1.25 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 1; // Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 100.0;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.0;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.1; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;	//max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		

				

				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	
	
				//CalcUnits(&DC_Mtr[i]);
				DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;
	
							
		}
		
		/////////////////////////////////////////////////////////////////////////////////
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){


				case TML_AX_TVL:

					strcpy(TML_MTR_INST[i].Name , "TVL");
											
					// Back EMF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;	


					if(ProjectConfig == project_US_Orbital){
						strcpy(TML_MTR_INST[i]._cfg.programName , "1511_TVL_M_94_US.sw");	
						TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1511");
						TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
						TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

					}
					else{
						strcpy(TML_MTR_INST[i]._cfg.programName , "0511_TVL_M_94.sw");
						TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0511");
						TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
					}									
				
					TML_MTR_INST[i]._cfg.units =  1000; //  to jest tyle ile z max speed TML EREF
					TML_MTR_INST[i]._cfg.rev_scale = -2925.0;
					TML_MTR_INST[i]._cfg.rev_motor = 1 ;
					TML_MTR_INST[i]._cfg.maxVel =  9.0; // mm/s
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;	
					TML_MTR_INST[i]._cfg.absFbk = 0; // non absolute value feedback , remember last value before drive reset

					
				break;

				
				case TML_AX_OSC:

					strcpy(TML_MTR_INST[i].Name , "OSC");

					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.absFbk = 0; // value fom APOS which is analog Ref
					TML_MTR_INST[i]._cfg.units = 4096.0 ;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 80.0;  // this comes from experiment
					//TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 56.0; // this comes from drawings
					TML_MTR_INST[i]._cfg.maxVel = 100.0; 
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;


					if(ProjectConfig == project_US_Orbital){
						strcpy(TML_MTR_INST[i]._cfg.programName , "1512_OSC_M_94_US.sw");
						TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1512");	
						TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
						TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

					}
					else{
						strcpy(TML_MTR_INST[i]._cfg.programName , "0512_OSC_M_94.sw");
						TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0512");	
						TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
					}	
		
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
				

			
				break;		


				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4095;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10.0; //1//6000 rpm
					TML_MTR_INST[i]._cfg.maxAcc = 100000.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.absFbk = 0; // absolute value feedback

					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					if(ProjectConfig == project_US_Orbital){
						strcpy(TML_MTR_INST[i]._cfg.programName , "1513_AVC_M_94_US.sw");	
						TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1513");
						TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
						TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

					}
					else{
						strcpy(TML_MTR_INST[i]._cfg.programName , "0513_AVC_M_94.sw");
						TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0513");
						TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
					}	
										
					//TML_MTR_INST[i]._cfg.sftLimitPos = 1000.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = -1000.0;	
	
				break;
				


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = -3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					//TML_MTR_INST[i]._cfg.HeartBeat = 2.0;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					
					if(ProjectConfig == project_US_Orbital){
						strcpy(TML_MTR_INST[i]._cfg.programName , "1514_WRST_M_94_US.sw");	
						TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1514");
						TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
						TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

					}
					else{
						strcpy(TML_MTR_INST[i]._cfg.programName , "0514_WRST_M_94.sw");
						TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0514");
						TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
					}				
								
	
				break;
							

				default:

					//strcpy(TML_MTR_INST[i].Name , "Spare ");
					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}
		
		
		
		TML_mgr[0].hrdw[0].AxisNum = 13; //4; 
		TML_mgr[0].hrdw[1].AxisNum = 0;

		TML_mgr[0].pAxis[0] = &AxisCh[0];
		TML_mgr[0].pAxis[1] = 0;
		//TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = 0;
		//TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		AxisCh[TML_AX_OSC].AxisID 	= 2;		
		AxisCh[TML_AX_AVC].AxisID 	= 3;
		AxisCh[TML_AX_WRST].AxisID 	= 4;
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					//INDEX_Param_Set[i].pPrc = &Process[PROC_INDX];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 0;	
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 20;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	*/
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	TML_MTR_INST[TML_AX_WRST].Disable = 0;		

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby
	/*
	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;

	VectorStateMach[VECT_AVC].testMode = 1;
	VectorStateMach[VECT_OSC].testMode = 1;	
	VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	VectorStateMach[VECT_WF_1].testMode = 1;
	VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_WP_1].testMode = 1;
	VectorStateMach[VECT_WP].testMode = 1;

	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1;
	TML_MTR_INST[TML_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AX_WP].Disable = 1;
	TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	////////////////////////////////////////

	Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;

	Process[PROC_TVL].Disable = 1;
	Process[PROC_TVL].TestMode = 1;

	Process[PROC_WIRE_FEED].Disable = 1;
	Process[PROC_WIRE_FEED].TestMode = 1;

	Process[PROC_WIRE_PULSE].Disable = 1;
	Process[PROC_WIRE_PULSE].TestMode = 1;

	Process[PROC_COOL].Disable = 1;
	Process[PROC_COOL].TestMode = 1;

	Process[PROC_GAS].Disable = 1;
	Process[PROC_GAS].TestMode = 1;
	*/
	////////////////////////////////////////////////////////
				
	return 1;
	
}

DINT Configure_CLAMSHELL_HEAD(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////

		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
			
			switch(i){			

			
				case DC_INDX_1:
				case DC_INDX_2:

					switch(i){

						case DC_INDX_1:
							
							strcpy(DC_Mtr[i].Name , "DC INDX #1");
					
							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = -1.0;							

						break;
						
						case DC_INDX_2: 
							
							strcpy(DC_Mtr[i].Name , "DC INDX #2");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = 1.0;
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					//DC_Mtr[i].Cfg.rev_scale = 66.0 * 0.218686666; // Ratio gear box 66:1 

					DC_Mtr[i].Cfg.units =48000 / (1.25 * M_PI * 25.4); // 48000 enc ticks / 1.25 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 1; // Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 100.0;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.0;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.1; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;	//max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		

				

				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	
	
				//CalcUnits(&DC_Mtr[i]);
				DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;
	
							
		}
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:			

					strcpy(TML_MTR_INST[i].Name , "TVL");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 546 * 2; // because loopPeriod is 0.0005
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 2.3 * 25.4 * M_PI) ;
								
					TML_MTR_INST[i]._cfg.maxVel =  4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.08;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "3301_CLMSH_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3301");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
	
				break;			
				
				case TML_AX_OSC:

					strcpy(TML_MTR_INST[i].Name , "OSC");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					//TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_motor = 62;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/ (0.5 * 25.4) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "3302_CLMSH_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3302");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;

				case TML_AX_AVC:
				case TML_AX_AVC2:	

					if(i == TML_AX_AVC)
						strcpy(TML_MTR_INST[i].Name , "AVC");
					else
						strcpy(TML_MTR_INST[i].Name , "AVC_2");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "3303_CLMSH_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3303");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;
					
				break;


				// WRIST
				case TML_AX_WF_1: //TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");

 
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								 
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					//TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_motor = 16 * 50;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/ (360.0) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 0;
					//TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.02;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;

					strcpy(TML_MTR_INST[i]._cfg.programName , "3307_CLMSH_WRST.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3307");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
											
					
	
				break;
				

				case TML_AX_WF:
					
					strcpy(TML_MTR_INST[i].Name , "WF"); 
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
					TML_MTR_INST[i]._cfg.rev_motor = 35.0;	// jest 39:1 ale trzeba pamietac o groove na rolce
							
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "3305_CLMSH_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3305");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				
				case TML_AX_WP:

					strcpy(TML_MTR_INST[i].Name , "WP");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;

					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 3.9;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/2.0; 

					/*
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					*/

					
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "3306_CLMSH_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3306");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;
				

				default:

					//strcpy(TML_MTR_INST[i].Name , "Spare ");
					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 7;

		TML_mgr[0].pAxis[0] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];
		TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];
		//TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[1].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		AxisCh[TML_AX_OSC].AxisID 	= 2;	
		AxisCh[TML_AX_AVC].AxisID 	= 3;
		AxisCh[TML_AX_AVC2].AxisID 	= 4;	
		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		
		AxisCh[m->pCfg->HeadCfg.WRST.TML_A_Indx].AxisID 	= 7;

		

		//AxisCh[TML_AX_WF_1].AxisID 	= 7;
		//AxisCh[TML_AX_WP_1].AxisID 	= 8;
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
					strcpy(VectorStateMach[VECT_AVC2].Name , "AVC_2");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 2;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].Mode = 3; //BPV Mode w/ twp torches
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 10; // ClamShell Head  mode with Wrist

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					//GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					//GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];

					GAS_Param_Set[i].Mode = 1;// Arclik Gas Sol
					
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					//INDEX_Param_Set[i].pPrc = &Process[PROC_INDX];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 0;	
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					//COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					//COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
												
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];

					// small Jack PS
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;

					// Lincoln PS
					//HW_PS_Param_Set[i].rawCmdMax 		= 32767.0;
					//HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
					
					HW_PS_Param_Set[i].pAnal_Output 	= &Hardware[1].Anal_Outp[0]; // HotwirePS_AO
					HW_PS_Param_Set[i].pOutput			= &Hardware[1].Outp[2]; //HotwirePS_Enable
					
				
				break;	

			}	
							
		}	
	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; 
					WIRE_Param_Set[i].Mode = 3; //BPV Mode with Feedback Selection
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 3; //BPV Mode with Feedback Selection
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

	}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 20;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	
	
	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby

	/*	
	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_AVC2].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;
	VectorStateMach[VECT_WRST].simul = 1;

	VectorStateMach[VECT_AVC].testMode = 1;
	VectorStateMach[VECT_AVC2].testMode = 1;
	VectorStateMach[VECT_OSC].testMode = 1;	
	VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	VectorStateMach[VECT_WF_1].testMode = 1;
	VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_WP_1].testMode = 1;
	VectorStateMach[VECT_WP].testMode = 1;
	VectorStateMach[VECT_WRST].testMode = 1;
	*/
	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	
	//TML_MTR_INST[TML_AX_AVC].Disable = 1;
	//TML_MTR_INST[TML_AX_AVC2].Disable = 1;
	//TML_MTR_INST[TML_AX_OSC].Disable = 1;
	//TML_MTR_INST[TML_AX_TVL].Disable = 1;
	//TML_MTR_INST[TML_AX_WRST].Disable = 1;
	//TML_MTR_INST[TML_AX_WF].Disable = 1;
	//TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	//TML_MTR_INST[TML_AX_WP].Disable = 1;
	//TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	
	////////////////////////////////////////

	
	//Process[PROC_AVC].Disable = 1;
	//Process[PROC_AVC].TestMode = 1;

	//Process[PROC_INDX].Disable = 1;
	//Process[PROC_INDX].TestMode = 1;

	//Process[PROC_OSC].Disable = 1;
	//Process[PROC_OSC].TestMode = 1;

	//Process[PROC_WRST].Disable = 1;
	//Process[PROC_WRST].TestMode = 1;

	//Process[PROC_TVL].Disable = 1;
	//Process[PROC_TVL].TestMode = 1;

	//Process[PROC_WIRE_FEED].Disable = 1;
	//Process[PROC_WIRE_FEED].TestMode = 1;

	//Process[PROC_WIRE_PULSE].Disable = 1;
	//Process[PROC_WIRE_PULSE].TestMode = 1;

	//Process[PROC_COOL].Disable = 1;
	//Process[PROC_COOL].TestMode = 1;

	//Process[PROC_GAS].Disable = 1;
	//Process[PROC_GAS].TestMode = 1;
	
	////////////////////////////////////////////////////////
				
	return 1;
	
}

DINT Configure_CHERRYPOINT_BPV1_HEAD(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////

		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
			
			switch(i){			

			
				case DC_INDX_1:
				case DC_INDX_2:

					switch(i){

						case DC_INDX_1:
							
							strcpy(DC_Mtr[i].Name , "DC INDX #1");
					
							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = -1.0;							

						break;
						
						case DC_INDX_2: 
							
							strcpy(DC_Mtr[i].Name , "DC INDX #2");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = 1.0;
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					//DC_Mtr[i].Cfg.rev_scale = 66.0 * 0.218686666; // Ratio gear box 66:1 

					DC_Mtr[i].Cfg.units =48000 / (1.25 * M_PI * 25.4); // 48000 enc ticks / 1.25 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 1; // Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 100.0;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.0;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.1; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;	//max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		

				

				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	
	
				//CalcUnits(&DC_Mtr[i]);
				DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;
	
							
		}
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:

					strcpy(TML_MTR_INST[i].Name , "TVL");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
								
					TML_MTR_INST[i]._cfg.maxVel =  fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.08;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "0331_BPV_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0331");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;					
	
				break;			
				
				case TML_AX_OSC:

				
					strcpy(TML_MTR_INST[i].Name , "OSC");

					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;					

					TML_MTR_INST[i]._cfg.units = 1024 * 4;
				
					TML_MTR_INST[i]._cfg.rev_motor = -75.0/19.0;
					//TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/ ((1.0/8.0) * 25.4) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;

					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[OSC_LAST_POS];
					
									
					// Version Classic
					///*
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;

					
					
					//strcpy(TML_MTR_INST[i]._cfg.programName , "2023_BPV2_OSC_WRST.sw");
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2023");

					strcpy(TML_MTR_INST[i]._cfg.programName , "0344_BPV_WRST_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0344");					
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					
					//TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					//TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;	

					//TML_MTR_INST[i]._cfg.actPos2_scale = 70.0/4006.0;

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;	

					TML_MTR_INST[i]._cfg.actPos2_scale = 0.0;				
						
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "0323_BPV_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0323");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = -3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 2.0;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					// Drive swap with OSC					
					strcpy(TML_MTR_INST[i]._cfg.programName , "0322_BPV_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0322");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;
				

				case TML_AX_WF:
				case TML_AX_WF_1:

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;
				

				default:

					//strcpy(TML_MTR_INST[i].Name , "Spare ");
					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];
		TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		//AxisCh[TML_AX_OSC].AxisID 	= 2;	
		AxisCh[TML_AX_WRST].AxisID 	= 2;
		AxisCh[TML_AX_AVC].AxisID 	= 3;
		//AxisCh[TML_AX_WRST].AxisID 	= 4;
		AxisCh[TML_AX_OSC].AxisID 	= 4;
		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
										
					/* Tak bylo we Flange										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					OSC_TML_Param_Set[i].Mode = 3; // Exp BEMF
					OSC_TML_Param_Set[i].PosFbkIndx = 2;

					////  New Oscillation concept - BEMF
					//OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
					OSC_TML_Param_Set[i].mm2ticks = 4096.0/80.0;
					//OSC_TML_Param_Set[i].SpeedFactor = 410;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;

					OSC_TML_Param_Set[i].SpeedFactor = 10.0;
					*/
					////////////

					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					////////////////////////////////////////////////		
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					//INDEX_Param_Set[i].pPrc = &Process[PROC_INDX];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 0;	
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 20;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	*/
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	TML_MTR_INST[TML_AX_WRST].Disable = 0;		

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby
	/*
	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;

	VectorStateMach[VECT_AVC].testMode = 1;
	VectorStateMach[VECT_OSC].testMode = 1;	
	VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	VectorStateMach[VECT_WF_1].testMode = 1;
	VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_WP_1].testMode = 1;
	VectorStateMach[VECT_WP].testMode = 1;

	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1;
	TML_MTR_INST[TML_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AX_WP].Disable = 1;
	TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	////////////////////////////////////////

	Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;

	Process[PROC_TVL].Disable = 1;
	Process[PROC_TVL].TestMode = 1;

	Process[PROC_WIRE_FEED].Disable = 1;
	Process[PROC_WIRE_FEED].TestMode = 1;

	Process[PROC_WIRE_PULSE].Disable = 1;
	Process[PROC_WIRE_PULSE].TestMode = 1;

	Process[PROC_COOL].Disable = 1;
	Process[PROC_COOL].TestMode = 1;

	Process[PROC_GAS].Disable = 1;
	Process[PROC_GAS].TestMode = 1;
	*/
	////////////////////////////////////////////////////////
				
	return 1;
	
}

DINT Configure_BPV_F_HEAD(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////

		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
			
			switch(i){			

			
				case DC_INDX_1:
				case DC_INDX_2:

					switch(i){

						case DC_INDX_1:
							
							strcpy(DC_Mtr[i].Name , "DC INDX #1");
					
							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = -1.0;							

						break;
						
						case DC_INDX_2: 
							
							strcpy(DC_Mtr[i].Name , "DC INDX #2");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = 1.0;
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					//DC_Mtr[i].Cfg.rev_scale = 66.0 * 0.218686666; // Ratio gear box 66:1 

					DC_Mtr[i].Cfg.units =48000 / (1.25 * M_PI * 25.4); // 48000 enc ticks / 1.25 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 1; // Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 100.0;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.0;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.1; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;	//max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		

				

				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	
	
				//CalcUnits(&DC_Mtr[i]);
				DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;
	
							
		}
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:			

					strcpy(TML_MTR_INST[i].Name , "TVL");
					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
								
					TML_MTR_INST[i]._cfg.maxVel =  4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.08;
									
					strcpy(TML_MTR_INST[i]._cfg.programName , "0331_BPV_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0331");
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
	
				break;			
				
				case TML_AX_OSC:

					strcpy(TML_MTR_INST[i].Name , "OSC");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					//TML_MTR_INST[i]._cfg.rev_motor = -3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "0322_BPV_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0322");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;

				case TML_AX_AVC:
				case TML_AX_AVC2:


					if(i == TML_AX_AVC)
						strcpy(TML_MTR_INST[i].Name , "AVC");
					else
						strcpy(TML_MTR_INST[i].Name , "AVC_2");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "0323_BPV_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0323");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = -3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					//TML_MTR_INST[i]._cfg.HeartBeat = 2.0;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					// U_BEND_HP_PINS
					//strcpy(TML_MTR_INST[i]._cfg.programName , "0334_BPV_WRST.sw");
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0334");

					//strcpy(TML_MTR_INST[i]._cfg.programName , "0344_BPV_WRST_OSC.sw");
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0344");

					strcpy(TML_MTR_INST[i]._cfg.programName , "0354_BPV_WRST_OSC_POT.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0354");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					//TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;
				

				case TML_AX_WF:
				case TML_AX_WF_1:

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;
				

				default:

					//strcpy(TML_MTR_INST[i].Name , "Spare ");
					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13;

		TML_mgr[0].pAxis[0] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];
		TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		AxisCh[TML_AX_OSC].AxisID 	= 2;	
		//AxisCh[TML_AX_WRST].AxisID 	= 2;
		AxisCh[TML_AX_AVC].AxisID 	= 3;
		AxisCh[TML_AX_WRST].AxisID 	= 4;
		//AxisCh[TML_AX_OSC].AxisID 	= 4;
		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					//INDEX_Param_Set[i].pPrc = &Process[PROC_INDX];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 0;	
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

	}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 20;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	*/
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	TML_MTR_INST[TML_AX_WRST].Disable = 0;		
	
	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby
	/*
	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;

	VectorStateMach[VECT_AVC].testMode = 1;
	VectorStateMach[VECT_OSC].testMode = 1;	
	VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	VectorStateMach[VECT_WF_1].testMode = 1;
	VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_WP_1].testMode = 1;
	VectorStateMach[VECT_WP].testMode = 1;
	
	
	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1;
	TML_MTR_INST[TML_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AX_WP].Disable = 1;
	TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	////////////////////////////////////////

	Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;

	Process[PROC_TVL].Disable = 1;
	Process[PROC_TVL].TestMode = 1;

	Process[PROC_WIRE_FEED].Disable = 1;
	Process[PROC_WIRE_FEED].TestMode = 1;

	Process[PROC_WIRE_PULSE].Disable = 1;
	Process[PROC_WIRE_PULSE].TestMode = 1;

	Process[PROC_COOL].Disable = 1;
	Process[PROC_COOL].TestMode = 1;

	Process[PROC_GAS].Disable = 1;
	Process[PROC_GAS].TestMode = 1;
	*/

	// To tylko do proby PAMIETAC WYMAZAC 
	/*
	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AX_WP].Disable = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1;

	Process[PROC_AVC].Disable = 1;	
	*/
	////////////////////////////////////////////////////////
				
	return 1;
	
}

DINT Configure_BPV_V1_MT(MASTER_typ * m, UINT headType){	
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	


	
/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WP.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_B_Indx];

	
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.INDX.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx];

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
			/***********************************/

		
		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////

		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
			
			switch(i){			

			
				case DC_INDX_1:
				case DC_INDX_2:

					switch(i){

						case DC_INDX_1:
							
							strcpy(DC_Mtr[i].Name , "DC INDX #1");
					
							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = -1.0;							

						break;
						
						case DC_INDX_2: 
							
							strcpy(DC_Mtr[i].Name , "DC INDX #2");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							//DC_Mtr[i].Cfg.enc_dir = 1.0;
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					//DC_Mtr[i].Cfg.rev_scale = 66.0 * 0.218686666; // Ratio gear box 66:1 

					DC_Mtr[i].Cfg.units =48000 / (1.25 * M_PI * 25.4); // 48000 enc ticks / 1.25 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 1; // Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 100.0;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.0;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.1; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;	//max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		

				

				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	
	
				//CalcUnits(&DC_Mtr[i]);
				DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;
	
							
		}
		
		for(i = 0 ; i < TML_SERVO_NUM ; i++){
	
			switch(i){

				case TML_AX_TVL:			

					strcpy(TML_MTR_INST[i].Name , "TVL");

					
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 
					TML_MTR_INST[i]._cfg.rev_motor = 73.233;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.875 * 25.4 * M_PI) ;	


					/*
					TML_MTR_INST[i]._cfg.loopPeriod = 0.0005; // Slow loop
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					TML_MTR_INST[i]._cfg.rev_motor = 156;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;
					*/
								
					TML_MTR_INST[i]._cfg.maxVel =  4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.08;

					/*
					strcpy(TML_MTR_INST[i]._cfg.programName , "0331_BPV_TVL.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0331");
					*/
					 
					strcpy(TML_MTR_INST[i]._cfg.programName , "0431_BPV_TVL_MT.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0431");

					
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					////////////////////////////////////////////////////////

					// To jest motor z MIG Track
					/*
					strcpy(TML_MTR_INST[i].Name , "TVL");

					TML_MTR_INST[i]._cfg.loopPeriod = 0.001; // Slow loop
									
					// It was in BPV
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 	
					
					//TML_MTR_INST[i]._cfg.rev_motor = 156;
					//TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.25 * 25.4 * M_PI) ;

					TML_MTR_INST[i]._cfg.rev_motor = 73.233;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 1.875 * 25.4 * M_PI) ;					
								
					TML_MTR_INST[i]._cfg.maxVel = fabsf(4500.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale);
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel / 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.pAbsLastPos = &OLD_MTR_POS[TVL_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 3;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.2;
									
					
					strcpy(TML_MTR_INST[i]._cfg.programName , "3925_BPV2_TVL_G.sw");											
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("3925"); // New TVL Pos Mode with Interrupt
	

					
					
	
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
					*/
					///////////////////////////////
					
	
				break;			
				
				case TML_AX_OSC:

					strcpy(TML_MTR_INST[i].Name , "OSC");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					//TML_MTR_INST[i]._cfg.rev_motor = -3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_motor = (-75.0/19.0) * 50.0;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;

					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[OSC_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					// U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "0322_BPV_OSC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0322");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;

				case TML_AX_AVC:

					strcpy(TML_MTR_INST[i].Name , "AVC");
							
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 4096;
					TML_MTR_INST[i]._cfg.rev_motor = 1;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;					
					TML_MTR_INST[i]._cfg.maxVel = 1500.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0;	
					//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
					//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
					TML_MTR_INST[i]._cfg.kppMax = 32000;
					TML_MTR_INST[i]._cfg.kipMax = 1000;
					TML_MTR_INST[i]._cfg.absFbk = 0; 

					TML_MTR_INST[i]._cfg.HeartBeat = 0.8;
																	
					TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

					//U_BEND_HP_PINS
					strcpy(TML_MTR_INST[i]._cfg.programName , "0323_BPV_AVC.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0323");							
					
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674C , 514D
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	

					/*
					TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;
					*/

					TML_MTR_INST[i]._cfg.AnalLimitPos = 0;
					TML_MTR_INST[i]._cfg.AnalLimitNeg = 0;
					
	
				break;


				case TML_AX_WRST:

					strcpy(TML_MTR_INST[i].Name , "WRIST");
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 1024 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = -3.9 * 50 ;
					TML_MTR_INST[i]._cfg.rev_scale = -1.0/ (0.625 * 25.4 *M_PI) ;
					TML_MTR_INST[i]._cfg.maxVel = 8000.0/60.0/TML_MTR_INST[i]._cfg.rev_motor/ TML_MTR_INST[i]._cfg.rev_scale;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 10.0 ;
					TML_MTR_INST[i]._cfg.absLastPos = OLD_MTR_POS[WRST_LAST_POS];
					TML_MTR_INST[i]._cfg.absFbk = 2;

					//TML_MTR_INST[i]._cfg.HeartBeat = 2.0;
					TML_MTR_INST[i]._cfg.PVTPeriod = 0.08;
									
					// U_BEND_HP_PINS
					//strcpy(TML_MTR_INST[i]._cfg.programName , "0334_BPV_WRST.sw");
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0334");

					//strcpy(TML_MTR_INST[i]._cfg.programName , "0344_BPV_WRST_OSC.sw");
					//TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0344");

					strcpy(TML_MTR_INST[i]._cfg.programName , "0354_BPV_WRST_OSC_POT.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0354");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
					//TML_MTR_INST[i]._cfg.NotAutoDownload = 1;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 0;

					//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];					
					//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];
					
					//TML_MTR_INST[i]._cfg.sftLimitPos = 0.0;
					//TML_MTR_INST[i]._cfg.sftLimitNeg = 0.0;	
				
	
				break;
				

				case TML_AX_WF:
				case TML_AX_WF_1:

					switch(i){

						case TML_AX_WF:
							
							strcpy(TML_MTR_INST[i].Name , "WF"); 
							TML_MTR_INST[i]._cfg.rev_scale = 1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = 35.0;
							
						break;
						
						case TML_AX_WF_1:
							
							strcpy(TML_MTR_INST[i].Name , "WF_1"); 
							TML_MTR_INST[i]._cfg.rev_scale = -1.0 /( 0.75 * 25.4 * M_PI) ;
							TML_MTR_INST[i]._cfg.rev_motor = -35.0;
							
						break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
					TML_MTR_INST[i]._cfg.units = 1024 * 4; // 					
					//TML_MTR_INST[i]._cfg.rev_motor = 35;					
			
					TML_MTR_INST[i]._cfg.maxVel = 520 * 25.4/ 60.0; //// 520 ipm
					//TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 100.0;
					TML_MTR_INST[i]._cfg.maxAcc = TML_MTR_INST[i]._cfg.maxVel * 4.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0325_BPV_WF.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0325");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;

				
				case TML_AX_WP:
				case TML_AX_WP_1:


					switch(i){

						case TML_AX_WP: strcpy(TML_MTR_INST[i].Name , "WP"); break;
						case TML_AX_WP_1: strcpy(TML_MTR_INST[i].Name , "WP_1"); break;

					}					
											
					// Analog Feedback from REF
					TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
								
					TML_MTR_INST[i]._cfg.units = 500 * 4;
					TML_MTR_INST[i]._cfg.rev_motor = 24;
					TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
					TML_MTR_INST[i]._cfg.maxVel = 10000.0; //
					TML_MTR_INST[i]._cfg.maxAcc = 100.0;
					TML_MTR_INST[i]._cfg.absFbk = 0; 	

					TML_MTR_INST[i]._cfg.HeartBeat = 0.4;
				
					strcpy(TML_MTR_INST[i]._cfg.programName , "0326_BPV_WP.sw");
					TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0326");
										
				
					TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  
					TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
					TML_MTR_INST[i]._cfg.NotAutoDownload = 1;

						
				break;
				

				default:

					//strcpy(TML_MTR_INST[i].Name , "Spare ");
					xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );

				break;	
	
			}	
	
		TML_MTR_INST[i].xCMD = TML_RESTART;
	
		
	}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 0; 
		TML_mgr[0].hrdw[1].AxisNum = 13; //8;

		TML_mgr[0].pAxis[0] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];
		TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		AxisCh[TML_AX_OSC].AxisID 	= 2;	
		//AxisCh[TML_AX_WRST].AxisID 	= 2;
		AxisCh[TML_AX_AVC].AxisID 	= 3;
		AxisCh[TML_AX_WRST].AxisID 	= 4;
		//AxisCh[TML_AX_OSC].AxisID 	= 4;
		
		AxisCh[TML_AX_WF].AxisID 	= 5;
		AxisCh[TML_AX_WP].AxisID 	= 6;
		AxisCh[TML_AX_WF_1].AxisID 	= 7;
		AxisCh[TML_AX_WP_1].AxisID 	= 8;
		/**************************************/
		/****   Process   ************************/

		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

					//PS_Param_Set[i].Mode 			= 1; // Arclink connection

				break;	

			}

		}
		///////////////////////////////////////////////////////


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 1; //BPV Mode 
					AVC_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_AVC]._cfg.maxVel; 
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}

		
		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0:
					

					strcpy(Process[m->pCfg->HeadCfg.WRST.PROC_Indx].Name , "WRST");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx].Name , "WRST");
														
					WRST_TML_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WRST.PROC_Indx];	
					WRST_TML_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WRST.VECT_A_Indx];
					WRST_TML_Param_Set[i].VectStateNum = 1;
					WRST_TML_Param_Set[i].pTML = &TML_MTR_INST[m->pCfg->HeadCfg.WRST.TML_A_Indx] ;
					WRST_TML_Param_Set[i].Mode = 0;  

					WRST_TML_Param_Set[i].GlbDirection = 1.0;

					WRST_TML_Param_Set[i].MaxAmpl = 0.0;				
						


				break;

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
														
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;
					OSC_TML_Param_Set[i].Mode = 1; //BPV Mode 

					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;
					
					
				break;	
				

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					//INDEX_Param_Set[i].pPrc = &Process[PROC_INDX];
					INDEX_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx];
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_A_Indx].Name , "INDX A");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.INDX.VECT_B_Indx].Name , "INDX B");
					INDEX_Param_Set[i].VectStateNum = 2;
					INDEX_Param_Set[i].Mode = 0;	
					INDEX_Param_Set[i].MaxSpeed = 24.0;	
					INDEX_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
										
				break;	

			}			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	
	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1; //BPV Mode 
					WIRE_Param_Set[i].Mode = 1;
					WIRE_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_WF]._cfg.maxVel; 

					WIRE_Param_Set[i].pSynchMode = &WFSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWF;
	
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
					WIRE_Param_Set[i].Mode = 1; //BPV Mode 
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;

					WIRE_Param_Set[i].pSynchMode = &WPSynchMode;	
					WIRE_Param_Set[i].pSynchClock = &SynchClckToWP;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

	}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					
					TVL_ROT_Param_Set[i].Mode = 1; //BPV Mode 
					TVL_ROT_Param_Set[i].MaxSpeedJog = TML_MTR_INST[TML_AX_TVL]._cfg.maxVel;
						
					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					// TVL in Torq Mode
					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 20;

					TVL_ROT_Param_Set[i].pSynchMode = &TVLSynchMode;
					TVL_ROT_Param_Set[i].pSynchClock = &SynchClckToTVL;
			
			
			break;


	}


		
	}

	////////////////////////////////////////////
	/*
	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;
	VectorStateMach[VECT_OSC].simul = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	*/
	
	Process[PROC_WRST].Disable = 0;
	Process[PROC_WRST].TestMode = 0;
	VectorStateMach[VECT_WRST].simul = 0;
	TML_MTR_INST[TML_AX_WRST].Disable = 0;		

	////////////////////////////////////////////////////////////
	/// To jest Tylko do proby
	/*
	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_INDX_1].simul = 1;
	VectorStateMach[VECT_INDX_2].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;

	VectorStateMach[VECT_AVC].testMode = 1;
	VectorStateMach[VECT_OSC].testMode = 1;	
	VectorStateMach[VECT_TVL].testMode = 1;	
	VectorStateMach[VECT_INDX_1].testMode = 1;
	VectorStateMach[VECT_INDX_2].testMode = 1;
	VectorStateMach[VECT_WF_1].testMode = 1;
	VectorStateMach[VECT_WF].testMode = 1;
	VectorStateMach[VECT_WP_1].testMode = 1;
	VectorStateMach[VECT_WP].testMode = 1;

	
	
	// To tylko trzeba uncomment gdy jest bez torch ale reszta dziala
	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;
	TML_MTR_INST[TML_AX_WRST].Disable = 1;
	TML_MTR_INST[TML_AX_WF].Disable = 1;
	TML_MTR_INST[TML_AX_WF_1].Disable = 1;
	TML_MTR_INST[TML_AX_WP].Disable = 1;
	TML_MTR_INST[TML_AX_WP_1].Disable = 1;
	////////////////////////////////////////

	Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;

	Process[PROC_INDX].Disable = 1;
	Process[PROC_INDX].TestMode = 1;

	Process[PROC_OSC].Disable = 1;
	Process[PROC_OSC].TestMode = 1;

	Process[PROC_TVL].Disable = 1;
	Process[PROC_TVL].TestMode = 1;

	Process[PROC_WIRE_FEED].Disable = 1;
	Process[PROC_WIRE_FEED].TestMode = 1;

	Process[PROC_WIRE_PULSE].Disable = 1;
	Process[PROC_WIRE_PULSE].TestMode = 1;

	Process[PROC_COOL].Disable = 1;
	Process[PROC_COOL].TestMode = 1;

	Process[PROC_GAS].Disable = 1;
	Process[PROC_GAS].TestMode = 1;
	*/
	////////////////////////////////////////////////////////
				
	return 1;
	
}
DINT Configure_F_HEAD_HP_ENC_BEMF(MASTER_typ * m , UINT headType){
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	
	
	
	/*********************************************/
	/***   Hardware and Vectors *********************/

	//TML_MTR_INST[TML_AX_AVC].pState = &VectorStateMach[VECT_AVC];
	//TML_MTR_INST[TML_AX_OSC].pState = &VectorStateMach[VECT_OSC];	
	//TML_MTR_INST[TML_AX_TVL].pState = &VectorStateMach[VECT_TVL];	
	
	//DC_Mtr[DC_AX_WF].pState = &VectorStateMach[VECT_WF];
	//DC_Mtr[DC_AX_WP].pState = &VectorStateMach[VECT_WP];
	//DC_Mtr[DC_AX_WF_1].pState = &VectorStateMach[VECT_WF_1];
	//DC_Mtr[DC_AX_WP_1].pState = &VectorStateMach[VECT_WP_1];

	
	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
		
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];	

	DC_Mtr[m->pCfg->HeadCfg.WF.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WP.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WF.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WP.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	
/*

	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
		
	DC_Mtr[DC_AX_WF].Disable = 1;
	DC_Mtr[DC_AX_WP].Disable = 1;
	DC_Mtr[DC_AX_WF_1].Disable = 1;
	DC_Mtr[DC_AX_WP_1].Disable = 1;

	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;

	//Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;
*/

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");


		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}

		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
		
			switch(i){

			
				case DC_AX_WF:
				case DC_AX_WF_1:

					switch(i){

						case DC_AX_WF:
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#1");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							

							

						break;
						
						case DC_AX_WF_1: 
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#2");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 59.847340050885561192713356451475; // 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 66.0;	// Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;

				case DC_AX_WP:					
				case DC_AX_WP_1:

					switch(i){

						case DC_AX_WP:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#1");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							
							

						break;	
						
						case DC_AX_WP_1:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#2");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
														
							
							
						break;	

					}					

					//oryginalnie jest 2000 pulsow na obrot potem ratio on gear 4.8 : 1
					DC_Mtr[i].Cfg.units = 2000; 
					DC_Mtr[i].Cfg.rev_scale = 4.8;// ratio on gear 4.8 	
										
										
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %
					
					
				break;


				default:

					//strcpy(DC_Mtr[i].Name , "Spare ");
					xsprintf(DC_Mtr[i].Name, "Spare %d", i );

				break;	
	
		
			}	

			//CalcUnits(&DC_Mtr[i]);
			DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;

						
		}


		/***********************************/
		
			for(i = 0 ; i < TML_SERVO_NUM ; i++){
		
				switch(i){
		
				
					// tml->_int.kPos = (tml->_cfg.units * tml->_cfg.rev_scale) / tml->_cfg.rev_motor;
					case TML_AX_AVC:

						strcpy(TML_MTR_INST[i].Name , "AVC");
								
						// Analog Feedback from REF
						TML_MTR_INST[i]._cfg.units = 4095;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
						TML_MTR_INST[i]._cfg.maxVel = 200.0; // rpm
						TML_MTR_INST[i]._cfg.maxAcc = 100000.0;	
						//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.absFbk = 0; // absolute value feedback

						TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1323_AVC_FH_ENC_US_BEMF.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1323");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
							TML_MTR_INST[i]._cfg.loopPeriod = 0.01; // real BEMF - experimental value
				
						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0223_AVC_FH_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0223");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
							TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						}	
											
						//TML_MTR_INST[i]._cfg.sftLimitPos = 1000.0;
						//TML_MTR_INST[i]._cfg.sftLimitNeg = -1000.0;	
		
					break;
					
					case TML_AX_OSC:

						strcpy(TML_MTR_INST[i].Name , "OSC");

						
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.absFbk = 0; // value fom APOS which is analog Ref
						TML_MTR_INST[i]._cfg.units = 4096.0 ;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 80.0;  // this comes from experiment
						//TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 56.0; // this comes from drawings
						TML_MTR_INST[i]._cfg.maxVel = 100.0; 
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;


						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1322_OSC_FH_ENC_US_BEMF.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1322");	
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
							

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0222_OSC_FH_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0222");	
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}	
			
						TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
						TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;

						////////////////////////////////////////////////					

				
					break;

					case TML_AX_TVL:

						strcpy(TML_MTR_INST[i].Name , "TVL");
												
						// Back EMF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;	


						if(ProjectConfig == project_US_Orbital){


							strcpy(TML_MTR_INST[i]._cfg.programName , "1231_TVL_FH_ENC_US.sw"); 
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1231");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

							TML_MTR_INST[i]._cfg.units =  1000; //	to jest tyle ile z max speed TML EREF


							/* gotowe
							strcpy(TML_MTR_INST[i]._cfg.programName , "1331_TVL_FH_ENC_US_BEMF.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1331");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
							TML_MTR_INST[i]._cfg.units =  70;
							*/

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0231_TVL_FH_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0231");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C

							TML_MTR_INST[i]._cfg.units =  1000; //  to jest tyle ile z max speed TML EREF
						}									
								
						TML_MTR_INST[i]._cfg.rev_scale = -2925.0;
						TML_MTR_INST[i]._cfg.rev_motor = 1 ;
						TML_MTR_INST[i]._cfg.maxVel =  9.0; // mm/s
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;	
						TML_MTR_INST[i]._cfg.absFbk = 0; // non absolute value feedback , remember last value before drive reset

						
					break;

					default:

						xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
						TML_MTR_INST[i].pState = 0;

					break;	
		
				}	
		
			TML_MTR_INST[i].xCMD = TML_RESTART;
		
			
		}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 3; 
		TML_mgr[0].hrdw[1].AxisNum = 0;

		TML_mgr[0].pAxis[0] = &AxisCh[0];
		TML_mgr[0].pAxis[1] = 0;
		//TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = 0;
		//TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		AxisCh[TML_AX_OSC].AxisID 	= 2;		
		AxisCh[TML_AX_AVC].AxisID 	= 3;		

		/**************************************/
		/****   Process   ************************/
	
		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;
				

				break;	

			}

		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					

					AVC_Param_Set[i].MaxSpeedJog = 24.0;

					if(ProjectConfig == project_US_Orbital){
						AVC_Param_Set[i].maxBEMFspeed = 200.0;
						AVC_Param_Set[i].Mode = 2; // Real BEMF Speed control
					}
					else{

						AVC_Param_Set[i].Mode = 0;

					}
					
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					OSC_TML_Param_Set[i].Mode = 0;
					
					////  New Oscillation concept - BEMF		
					//OSC_TML_Param_Set[i].mm2ticks = 80.0; 
					//OSC_TML_Param_Set[i].SpeedFactor = 500;

					OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 

					if(ProjectConfig == project_US_Orbital)
						OSC_TML_Param_Set[i].SpeedFactor = 70; // Real BEMF
					else
						OSC_TML_Param_Set[i].SpeedFactor = 500;

									
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;

					/////////////////////////
					/////   Hardcoded Limits 
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}					
					
				break;	

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					//GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1;
					WIRE_Param_Set[i].Mode = 0;  // classic

					
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
								
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


			}

		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Disable = 1;
					
				break;	

			}			
				
		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					

					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;
					TVL_ROT_Param_Set[i].MaxSpeedJog = 24.0;
	
					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 3;
			
			
				break;

			}
		
		}
	



	return 1;
	
}


DINT Configure_F_HEAD_HP_ENCODER(MASTER_typ * m , UINT headType){
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	
	
	
	/*********************************************/
	/***   Hardware and Vectors *********************/

	//TML_MTR_INST[TML_AX_AVC].pState = &VectorStateMach[VECT_AVC];
	//TML_MTR_INST[TML_AX_OSC].pState = &VectorStateMach[VECT_OSC];	
	//TML_MTR_INST[TML_AX_TVL].pState = &VectorStateMach[VECT_TVL];	
	
	//DC_Mtr[DC_AX_WF].pState = &VectorStateMach[VECT_WF];
	//DC_Mtr[DC_AX_WP].pState = &VectorStateMach[VECT_WP];
	//DC_Mtr[DC_AX_WF_1].pState = &VectorStateMach[VECT_WF_1];
	//DC_Mtr[DC_AX_WP_1].pState = &VectorStateMach[VECT_WP_1];

	
	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
		
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];	

	DC_Mtr[m->pCfg->HeadCfg.WF.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WP.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WF.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WP.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

	
/*

	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
		
	DC_Mtr[DC_AX_WF].Disable = 1;
	DC_Mtr[DC_AX_WP].Disable = 1;
	DC_Mtr[DC_AX_WF_1].Disable = 1;
	DC_Mtr[DC_AX_WP_1].Disable = 1;

	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;

	//Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;
*/

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");


		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}

		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
		
			switch(i){

			
				case DC_AX_WF:
				case DC_AX_WF_1:

					switch(i){

						case DC_AX_WF:
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#1");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							

							

						break;
						
						case DC_AX_WF_1: 
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#2");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 59.847340050885561192713356451475; // 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 66.0;	// Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;

				case DC_AX_WP:					
				case DC_AX_WP_1:

					switch(i){

						case DC_AX_WP:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#1");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							
							

						break;	
						
						case DC_AX_WP_1:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#2");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
														
							
							
						break;	

					}					

					//oryginalnie jest 2000 pulsow na obrot potem ratio on gear 4.8 : 1
					DC_Mtr[i].Cfg.units = 2000; 
					DC_Mtr[i].Cfg.rev_scale = 4.8;// ratio on gear 4.8 	
										
										
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %
					
					
				break;


				default:

					//strcpy(DC_Mtr[i].Name , "Spare ");
					xsprintf(DC_Mtr[i].Name, "Spare %d", i );

				break;	
	
		
			}	

			//CalcUnits(&DC_Mtr[i]);
			DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;

						
		}


		/***********************************/
		
			for(i = 0 ; i < TML_SERVO_NUM ; i++){
		
				switch(i){
		
				
					// tml->_int.kPos = (tml->_cfg.units * tml->_cfg.rev_scale) / tml->_cfg.rev_motor;
					case TML_AX_AVC:

						strcpy(TML_MTR_INST[i].Name , "AVC");
								
						// Analog Feedback from REF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.units = 4095;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
						TML_MTR_INST[i]._cfg.maxVel = 10.0; //1//6000 rpm
						TML_MTR_INST[i]._cfg.maxAcc = 100000.0;	
						//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.absFbk = 0; // absolute value feedback

						TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1223_AVC_FH_ENC_US.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1223");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0223_AVC_FH_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0223");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}	
											
						//TML_MTR_INST[i]._cfg.sftLimitPos = 1000.0;
						//TML_MTR_INST[i]._cfg.sftLimitNeg = -1000.0;	
		
					break;
					
					case TML_AX_OSC:

						strcpy(TML_MTR_INST[i].Name , "OSC");

						
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.absFbk = 0; // value fom APOS which is analog Ref
						TML_MTR_INST[i]._cfg.units = 4096.0 ;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 80.0;  // this comes from experiment
						//TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 56.0; // this comes from drawings
						TML_MTR_INST[i]._cfg.maxVel = 100.0; 
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;


						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1222_OSC_FH_ENC_US.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1222");	
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0222_OSC_FH_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0222");	
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}	
			
						TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
						TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;

						////////////////////////////////////////////////					

				
					break;

					case TML_AX_TVL:

						strcpy(TML_MTR_INST[i].Name , "TVL");
												
						// Back EMF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;	


						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1231_TVL_FH_ENC_US.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1231");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0231_TVL_FH_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0231");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}									
					
						TML_MTR_INST[i]._cfg.units =  1000; //  to jest tyle ile z max speed TML EREF
						TML_MTR_INST[i]._cfg.rev_scale = -2925.0;
						TML_MTR_INST[i]._cfg.rev_motor = 1 ;
						TML_MTR_INST[i]._cfg.maxVel =  9.0; // mm/s
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;	
						TML_MTR_INST[i]._cfg.absFbk = 0; // non absolute value feedback , remember last value before drive reset

						
					break;

					default:

						xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
						TML_MTR_INST[i].pState = 0;

					break;	
		
				}	
		
			TML_MTR_INST[i].xCMD = TML_RESTART;
		
			
		}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 3; 
		TML_mgr[0].hrdw[1].AxisNum = 0;

		TML_mgr[0].pAxis[0] = &AxisCh[0];
		TML_mgr[0].pAxis[1] = 0;
		//TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = 0;
		//TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		AxisCh[TML_AX_OSC].AxisID 	= 2;		
		AxisCh[TML_AX_AVC].AxisID 	= 3;		

		/**************************************/
		/****   Process   ************************/
	
		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;
				

				break;	

			}

		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 0;

					AVC_Param_Set[i].MaxSpeedJog = 24.0;
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					OSC_TML_Param_Set[i].Mode = 0;
					
					////  New Oscillation concept - BEMF		
					//OSC_TML_Param_Set[i].mm2ticks = 80.0; 
					//OSC_TML_Param_Set[i].SpeedFactor = 500;

					OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
			 		OSC_TML_Param_Set[i].SpeedFactor = 500;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;

					/////////////////////////
					/////   Hardcoded Limits 
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}					
					
				break;	

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					//GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1;
					WIRE_Param_Set[i].Mode = 0;  // classic

					
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
								
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


			}

		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Disable = 1;
					
				break;	

			}			
				
		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					

					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;
					TVL_ROT_Param_Set[i].MaxSpeedJog = 24.0;
	
					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 3;
			
			
			break;

			}
		
		}
	



	return 1;
	
}

DINT Configure_RUBIX(MASTER_typ * m,UINT headType){
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;


	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	
	
	
	/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

	
	VectorStateMach[VECT_AVC].simul = 0;
	VectorStateMach[VECT_OSC].simul = 0;	
	VectorStateMach[VECT_TVL].simul = 0;
	VectorStateMach[VECT_WF].simul = 0;

	TML_MTR_INST[TML_AX_AVC].Disable = 0;
	TML_MTR_INST[TML_AX_OSC].Disable = 0;
	TML_MTR_INST[TML_AX_TVL].Disable = 0;
	TML_MTR_INST[TML_AX_WF].Disable = 0;

	//Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;

/*
	Process[PROC_TVL].Disable = 0;
	Process[PROC_OSC].Disable = 0;
	Process[PROC_AVC].Disable = 0;
	Process[PROC_WIRE_FEED].Disable = 0;
	Process[PROC_WIRE_PULSE].Disable = 0;

	VectorStateMach[VECT_AVC].simul = 0;
	VectorStateMach[VECT_OSC].simul = 0;	
	VectorStateMach[VECT_TVL].simul = 0;	
	
	DC_Mtr[DC_AX_WF].Disable = 0;
	DC_Mtr[DC_AX_WP].Disable = 0;
	DC_Mtr[DC_AX_WF_1].Disable = 1;
	DC_Mtr[DC_AX_WP_1].Disable = 1;

	TML_MTR_INST[TML_AX_AVC].Disable = 0;
	TML_MTR_INST[TML_AX_OSC].Disable = 0;
	TML_MTR_INST[TML_AX_TVL].Disable = 0;
*/

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");

		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////
		
		for(i = 0 ; i < GEN_MTR_NUM; i++)


		/***********************************/
		
			for(i = 0 ; i < TML_SERVO_NUM ; i++){
		
				switch(i){
		
				
					// tml->_int.kPos = (tml->_cfg.units * tml->_cfg.rev_scale) / tml->_cfg.rev_motor;
					case TML_AX_AVC:					
						

						strcpy(TML_MTR_INST[i].Name , "AVC");
								
						// Analog Feedback from REF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.units = 4095;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
						TML_MTR_INST[i]._cfg.maxVel = 10.0; //1//6000 rpm
						TML_MTR_INST[i]._cfg.maxAcc = 100000.0;	
						//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.absFbk = 0; // absolute value feedback
													
						TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "2103_AVC_RUBIX.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2103");	
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						/*
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0423_AVC_FH_MINI_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0423");	
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}
						*/
					
						//TML_MTR_INST[i]._cfg.sftLimitPos = 1000.0;
						//TML_MTR_INST[i]._cfg.sftLimitNeg = -1000.0;	
		
					break;
					
					case TML_AX_OSC:

						strcpy(TML_MTR_INST[i].Name , "OSC");


						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "2102_OSC_RUBIX.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2102");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						/*
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0412_OSC_FH_MINI_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0412");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}
						*/

						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.absFbk = 0; // value fom APOS which is analog Ref
						TML_MTR_INST[i]._cfg.units = 4096.0 ;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 80.0;  // this comes from experiment
						//TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 56.0; // this comes from drawings
						TML_MTR_INST[i]._cfg.maxVel = 100.0; 
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;

						TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
						TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;								
												
						
					break;

					case TML_AX_TVL:				
						

						strcpy(TML_MTR_INST[i].Name , "TVL");
					
						/// Deferent TML programs
						// Back EMF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;	

						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "2101_TVL_RUBIX.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2101");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						/*
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0411_TVL_FH_MINI_ENC.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0411");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}				
						*/
									
						TML_MTR_INST[i]._cfg.units =  1000; //  to jest tyle ile z max speed TML EREF
						TML_MTR_INST[i]._cfg.rev_scale = -6000.0;
						TML_MTR_INST[i]._cfg.rev_motor = 1.0 ;
						TML_MTR_INST[i]._cfg.maxVel =  10.0; // mm/s
						TML_MTR_INST[i]._cfg.maxAcc = 7.0;
						TML_MTR_INST[i]._cfg.absFbk = 0; // non absolute value feedback , remember last value before drive reset


		
					break;

					case TML_AX_WF:							

						strcpy(TML_MTR_INST[i].Name , "WF");
					
						/// Deferent TML programs
						// Back EMF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;	

						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "2104_WF_RUBIX.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2104");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							/*
							strcpy(TML_MTR_INST[i]._cfg.programName , "0411_TVL_FH_MINI_ENC.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0411");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
							*/
						}
									
						TML_MTR_INST[i]._cfg.units =  1000; //  to jest tyle ile z max speed TML EREF
						//TML_MTR_INST[i]._cfg.rev_scale = -1920.0;
						TML_MTR_INST[i]._cfg.rev_scale = -300.0;
						TML_MTR_INST[i]._cfg.rev_motor = 1.0 ;
						TML_MTR_INST[i]._cfg.maxVel =  20000.0/300.0; 
						TML_MTR_INST[i]._cfg.maxAcc = 10.0;
						TML_MTR_INST[i]._cfg.absFbk = 0; // non absolute value feedback , remember last value before drive reset


		
					break;

					default:

						xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
						TML_MTR_INST[i].pState = 0;

					break;	
		
				}	
		
			TML_MTR_INST[i].xCMD = TML_RESTART;
		
			
		}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 5; 
		TML_mgr[0].hrdw[1].AxisNum = 0;

		TML_mgr[0].pAxis[0] = &AxisCh[0];
		TML_mgr[0].pAxis[1] = 0;
		//TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = 0;
		//TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		AxisCh[TML_AX_OSC].AxisID 	= 2;		
		AxisCh[TML_AX_AVC].AxisID 	= 3;
		AxisCh[TML_AX_WF].AxisID 	= 4;

		/**************************************/
		/****   Process   ************************/
	
		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

				break;	

			}

		}
			
		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
										
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 0;

					AVC_Param_Set[i].MaxSpeedJog = 24.0;					
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					//OSC_TML_Param_Set[i].Mode = 0;
					OSC_TML_Param_Set[i].Mode = 11;

					////  New Oscillation concept - BEMF
					OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
			 		OSC_TML_Param_Set[i].SpeedFactor = 410;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;


					/////////////////////////
					/////   Hardcoded Limits 
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}
					
					////////////////////////////////////////////////		
					
					
				break;	

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					//GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");


					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
					WIRE_Param_Set[i].VectStateNum = 1;
					WIRE_Param_Set[i].Mode = 2;  // Only BEMF

					
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
								
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
					WIRE_Param_Set[i].VectStateNum = 1;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					

					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].MaxSpeedJog = 24.0;				

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 3;

							
			
				break;


			}		
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Disable = 1;
					
				break;	

			}			
				
		}
		
				
	return 1;
	
}

DINT Configure_F_HEAD_MINI_STND(MASTER_typ * m,UINT headType){
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;


	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	
	
	
	/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.WF.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];	


/*

	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
		m->pCfg->HeadCfg.WF.VECT_A_Indx]
	DC_Mtr[DC_AX_WF].Disable = 1;
	DC_Mtr[DC_AX_WP].Disable = 1;
	DC_Mtr[DC_AX_WF_1].Disable = 1;
	DC_Mtr[DC_AX_WP_1].Disable = 1;

	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;

	//Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;
*/
	Process[PROC_TVL].Disable = 0;
	Process[PROC_OSC].Disable = 0;
	Process[PROC_AVC].Disable = 0;
	Process[PROC_WIRE_FEED].Disable = 0;
	Process[PROC_WIRE_PULSE].Disable = 0;

	VectorStateMach[VECT_AVC].simul = 0;
	VectorStateMach[VECT_OSC].simul = 0;	
	VectorStateMach[VECT_TVL].simul = 0;	
	
	DC_Mtr[DC_AX_WF].Disable = 0;
	DC_Mtr[DC_AX_WP].Disable = 0;
	DC_Mtr[DC_AX_WF_1].Disable = 1;
	DC_Mtr[DC_AX_WP_1].Disable = 1;

	TML_MTR_INST[TML_AX_AVC].Disable = 0;
	TML_MTR_INST[TML_AX_OSC].Disable = 0;
	TML_MTR_INST[TML_AX_TVL].Disable = 0;


	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");

		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////


		/***********************************/
		
			for(i = 0 ; i < TML_SERVO_NUM ; i++){
		
				switch(i){
		
				
					// tml->_int.kPos = (tml->_cfg.units * tml->_cfg.rev_scale) / tml->_cfg.rev_motor;
					case TML_AX_AVC:					
						

						strcpy(TML_MTR_INST[i].Name , "AVC");
								
						// Analog Feedback from REF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.units = 4095;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
						TML_MTR_INST[i]._cfg.maxVel = 10.0; //1//6000 rpm
						TML_MTR_INST[i]._cfg.maxAcc = 100000.0;	
						//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.absFbk = 0; // absolute value feedback
													
						TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1423_AVC_FH_MINI_ENC_US.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1423");	
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0423_AVC_FH_MINI_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0423");	
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}				
					
						//TML_MTR_INST[i]._cfg.sftLimitPos = 1000.0;
						//TML_MTR_INST[i]._cfg.sftLimitNeg = -1000.0;	
		
					break;
					
					case TML_AX_OSC:

						strcpy(TML_MTR_INST[i].Name , "OSC");


						if(ProjectConfig == project_US_Orbital){

							// New Osc Mode - 11
							strcpy(TML_MTR_INST[i]._cfg.programName , "2412_OSC_FH_MINI_ENC_US.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2412");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0412_OSC_FH_MINI_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0412");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}				

						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.absFbk = 0; // value fom APOS which is analog Ref
						TML_MTR_INST[i]._cfg.units = 4096.0 ;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 80.0;  // this comes from experiment
						//TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 56.0; // this comes from drawings
						TML_MTR_INST[i]._cfg.maxVel = 100.0; 
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;

						TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
						TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;								
												
						
					break;

					case TML_AX_TVL:				
						

						strcpy(TML_MTR_INST[i].Name , "TVL");
					
						/// Deferent TML programs
						// Back EMF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;	

						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1411_TVL_FH_MINI_ENC_US.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1411");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0411_TVL_FH_MINI_ENC.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0411");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}				

									
						TML_MTR_INST[i]._cfg.units =  1000; //  to jest tyle ile z max speed TML EREF
						TML_MTR_INST[i]._cfg.rev_scale = -1920.0;
						TML_MTR_INST[i]._cfg.rev_motor = 1.0 ;
						TML_MTR_INST[i]._cfg.maxVel =  10.0; // mm/s
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;
						TML_MTR_INST[i]._cfg.absFbk = 0; // non absolute value feedback , remember last value before drive reset


		
					break;

					case TML_AX_WF:							

						strcpy(TML_MTR_INST[i].Name , "WF");
					
						/// Deferent TML programs
						// Back EMF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;	

						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "2104_WF_RUBIX.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2104");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							/*
							strcpy(TML_MTR_INST[i]._cfg.programName , "0411_TVL_FH_MINI_ENC.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0411");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
							*/
						}
									
						TML_MTR_INST[i]._cfg.units =  1000; //  to jest tyle ile z max speed TML EREF
						//TML_MTR_INST[i]._cfg.rev_scale = -1920.0;
						TML_MTR_INST[i]._cfg.rev_scale = -300.0;
						TML_MTR_INST[i]._cfg.rev_motor = 1.0 ;
						TML_MTR_INST[i]._cfg.maxVel =  20000.0/300.0; 
						TML_MTR_INST[i]._cfg.maxAcc = 10.0;
						TML_MTR_INST[i]._cfg.absFbk = 0; // non absolute value feedback , remember last value before drive reset


		
					break;

					default:

						xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
						TML_MTR_INST[i].pState = 0;

					break;	
		
				}	
		
			TML_MTR_INST[i].xCMD = TML_RESTART;
		
			
		}
		
		TML_mgr[0].hrdw[0].AxisNum = 5; 
		TML_mgr[0].hrdw[1].AxisNum = 0;

		TML_mgr[0].pAxis[0] = &AxisCh[0];
		TML_mgr[0].pAxis[1] = 0;
		//TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = 0;
		//TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		AxisCh[TML_AX_OSC].AxisID 	= 2;		
		AxisCh[TML_AX_AVC].AxisID 	= 3;
		AxisCh[TML_AX_WF].AxisID 	= 4;

		/**************************************/
		/****   Process   ************************/
	
		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

				break;	

			}

		}
			
		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
										
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 0;

					AVC_Param_Set[i].MaxSpeedJog = 24.0;					
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					OSC_TML_Param_Set[i].Mode = 11;

					////  New Oscillation concept - BEMF
					OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
			 		OSC_TML_Param_Set[i].SpeedFactor = 410;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;


					/////////////////////////
					/////   Hardcoded Limits 
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}
					
					////////////////////////////////////////////////		
					
					
				break;	

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					//GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	

		for(i=0 ; i < 2; i++){

			switch(i){
		
				case 0:

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");


					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
					WIRE_Param_Set[i].VectStateNum = 1;
					WIRE_Param_Set[i].Mode = 2;  // Only BEMF

					
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
								
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
					WIRE_Param_Set[i].VectStateNum = 1;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	
		
		
			}

		}
		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					

					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].MaxSpeedJog = 24.0;				

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 3;

							
			
				break;


			}		
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Disable = 1;
					
				break;	

			}			
				
		}
		
				
	return 1;
	
}





DINT Configure_F_HEAD_MINI_OMEGA(MASTER_typ * m,UINT headType){
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;


	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	
	
	
	/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	DC_Mtr[m->pCfg->HeadCfg.WF.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WP.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WF.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WP.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];


/*

	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
		m->pCfg->HeadCfg.WF.VECT_A_Indx]
	DC_Mtr[DC_AX_WF].Disable = 1;
	DC_Mtr[DC_AX_WP].Disable = 1;
	DC_Mtr[DC_AX_WF_1].Disable = 1;
	DC_Mtr[DC_AX_WP_1].Disable = 1;

	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;

	//Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;
*/
	Process[PROC_TVL].Disable = 0;
	Process[PROC_OSC].Disable = 0;
	Process[PROC_AVC].Disable = 0;
	Process[PROC_WIRE_FEED].Disable = 0;
	Process[PROC_WIRE_PULSE].Disable = 0;

	VectorStateMach[VECT_AVC].simul = 0;
	VectorStateMach[VECT_OSC].simul = 0;	
	VectorStateMach[VECT_TVL].simul = 0;	
	
	DC_Mtr[DC_AX_WF].Disable = 0;
	DC_Mtr[DC_AX_WP].Disable = 0;
	DC_Mtr[DC_AX_WF_1].Disable = 1;
	DC_Mtr[DC_AX_WP_1].Disable = 1;

	TML_MTR_INST[TML_AX_AVC].Disable = 0;
	TML_MTR_INST[TML_AX_OSC].Disable = 0;
	TML_MTR_INST[TML_AX_TVL].Disable = 0;


	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");

		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////


		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
		
			switch(i){			

			
				case DC_AX_WF:
				case DC_AX_WF_1:

					switch(i){

						case DC_AX_WF:
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#1");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							

							

						break;
						
						case DC_AX_WF_1: 
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#2");

							//DC_Mtr[i].Cfg.mtr_dir = -1.0;
							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 59.847340050885561192713356451475; // 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 66.0;	// Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		
				

				case DC_AX_WP:					
				case DC_AX_WP_1:

					switch(i){

						case DC_AX_WP:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#1");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							
							

						break;	
						
						case DC_AX_WP_1:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#2");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
													
							
							
						break;	

					}					

					//oryginalnie jest 2000 pulsow na obrot potem ratio on gear 4.8 : 1
					DC_Mtr[i].Cfg.units = 2000; 
					DC_Mtr[i].Cfg.rev_scale = 4.8;// ratio on gear 4.8 	
										
										
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %
					
					
				break;


				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	

			//CalcUnits(&DC_Mtr[i]);
			DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;

						
		}


		/***********************************/
		
			for(i = 0 ; i < TML_SERVO_NUM ; i++){
		
				switch(i){
		
				
					// tml->_int.kPos = (tml->_cfg.units * tml->_cfg.rev_scale) / tml->_cfg.rev_motor;
					case TML_AX_AVC:					
						

						strcpy(TML_MTR_INST[i].Name , "AVC");
								
						// Analog Feedback from REF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.units = 4095;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
						TML_MTR_INST[i]._cfg.maxVel = 10.0; //1//6000 rpm
						TML_MTR_INST[i]._cfg.maxAcc = 100000.0;	
						//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.absFbk = 0; // absolute value feedback
													
						TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

						if(ProjectConfig == project_US_Orbital){
						
							strcpy(TML_MTR_INST[i]._cfg.programName , "1423_AVC_FH_MINI_ENC_US.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1423");	
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;						
							

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0423_AVC_FH_MINI_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0423");	
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}				
					
						//TML_MTR_INST[i]._cfg.sftLimitPos = 1000.0;
						//TML_MTR_INST[i]._cfg.sftLimitNeg = -1000.0;	
		
					break;
					
					case TML_AX_OSC:

						strcpy(TML_MTR_INST[i].Name , "OSC");


						if(ProjectConfig == project_US_Orbital){

							/*
							strcpy(TML_MTR_INST[i]._cfg.programName , "1412_OSC_FH_MINI_ENC_US.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1412");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
							*/
							
							// New Osc Mode -  11;
							strcpy(TML_MTR_INST[i]._cfg.programName , "2412_OSC_FH_MINI_ENC_US.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2412");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0412_OSC_FH_MINI_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0412");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}				

						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.absFbk = 0; // value fom APOS which is analog Ref
						TML_MTR_INST[i]._cfg.units = 4096.0 ;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 80.0;  // this comes from experiment
						//TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 56.0; // this comes from drawings
						TML_MTR_INST[i]._cfg.maxVel = 100.0; 
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;

						TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
						TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;								
												
						
					break;

					case TML_AX_TVL:				
						

						strcpy(TML_MTR_INST[i].Name , "TVL");
					
						/// Deferent TML programs
						// Back EMF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;	

						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "2411_TVL_FH_MINI_OMEGA_US.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2411");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0411_TVL_FH_MINI_ENC.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0411");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}				

									
						TML_MTR_INST[i]._cfg.units =  1000; //  to jest tyle ile z max speed TML EREF
						//TML_MTR_INST[i]._cfg.rev_scale = -1920.0;
						TML_MTR_INST[i]._cfg.rev_scale =4000.0;
						TML_MTR_INST[i]._cfg.rev_motor = 1.0 ;
						TML_MTR_INST[i]._cfg.maxVel =  3.7; // mm/s
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;
						TML_MTR_INST[i]._cfg.absFbk = 0; // non absolute value feedback , remember last value before drive reset


		
					break;

					default:

						xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
						TML_MTR_INST[i].pState = 0;

					break;	
		
				}	
		
			TML_MTR_INST[i].xCMD = TML_RESTART;
		
			
		}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 3; 
		TML_mgr[0].hrdw[1].AxisNum = 0;

		TML_mgr[0].pAxis[0] = &AxisCh[0];
		TML_mgr[0].pAxis[1] = 0;
		//TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = 0;
		//TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		AxisCh[TML_AX_OSC].AxisID 	= 2;		
		AxisCh[TML_AX_AVC].AxisID 	= 3;		

		/**************************************/
		/****   Process   ************************/
	
		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

				break;	

			}

		}
			
		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
										
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 0;

					AVC_Param_Set[i].MaxSpeedJog = 24.0;					
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					//OSC_TML_Param_Set[i].Mode = 0;
					OSC_TML_Param_Set[i].Mode = 11; // New Osc Mode -

					////  New Oscillation concept - BEMF
					OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
			 		OSC_TML_Param_Set[i].SpeedFactor = 410;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;


					/////////////////////////
					/////   Hardcoded Limits 
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}
					
					////////////////////////////////////////////////		
					
					
				break;	

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					//GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;

					Process[PROC_HW_PS].Disable = 1;
											
				
				break;	

			}	
							
		}	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");


					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
					WIRE_Param_Set[i].VectStateNum = 1;
					WIRE_Param_Set[i].Mode = 0;  // classic

					
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
								
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
					WIRE_Param_Set[i].VectStateNum = 1;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];

					Process[PROC_WIRE_PULSE].Disable = 1;
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					

					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].MaxSpeedJog = 24.0;				

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 3;

							
			
				break;


			}		
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Disable = 1;
					
				break;	

			}			
				
		}
		
				
	return 1;
	
}



DINT Configure_F_HEAD_HP_MINI_ENC(MASTER_typ * m,UINT headType){
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;


	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	
	
	
	/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	DC_Mtr[m->pCfg->HeadCfg.WF.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WP.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WF.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WP.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];


/*

	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
		m->pCfg->HeadCfg.WF.VECT_A_Indx]
	DC_Mtr[DC_AX_WF].Disable = 1;
	DC_Mtr[DC_AX_WP].Disable = 1;
	DC_Mtr[DC_AX_WF_1].Disable = 1;
	DC_Mtr[DC_AX_WP_1].Disable = 1;

	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;

	//Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;
*/
	Process[PROC_TVL].Disable = 0;
	Process[PROC_OSC].Disable = 0;
	Process[PROC_AVC].Disable = 0;
	Process[PROC_WIRE_FEED].Disable = 0;
	Process[PROC_WIRE_PULSE].Disable = 0;

	VectorStateMach[VECT_AVC].simul = 0;
	VectorStateMach[VECT_OSC].simul = 0;	
	VectorStateMach[VECT_TVL].simul = 0;	
	
	DC_Mtr[DC_AX_WF].Disable = 0;
	DC_Mtr[DC_AX_WP].Disable = 0;
	DC_Mtr[DC_AX_WF_1].Disable = 1;
	DC_Mtr[DC_AX_WP_1].Disable = 1;

	TML_MTR_INST[TML_AX_AVC].Disable = 0;
	TML_MTR_INST[TML_AX_OSC].Disable = 0;
	TML_MTR_INST[TML_AX_TVL].Disable = 0;


	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");

		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////


		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
		
			switch(i){			

			
				case DC_AX_WF:
				case DC_AX_WF_1:

					switch(i){

						case DC_AX_WF:
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#1");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							

							

						break;
						
						case DC_AX_WF_1: 
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#2");

							//DC_Mtr[i].Cfg.mtr_dir = -1.0;
							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 59.847340050885561192713356451475; // 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 66.0;	// Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		
				

				case DC_AX_WP:					
				case DC_AX_WP_1:

					switch(i){

						case DC_AX_WP:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#1");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							
							

						break;	
						
						case DC_AX_WP_1:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#2");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
													
							
							
						break;	

					}					

					//oryginalnie jest 2000 pulsow na obrot potem ratio on gear 4.8 : 1
					DC_Mtr[i].Cfg.units = 2000; 
					DC_Mtr[i].Cfg.rev_scale = 4.8;// ratio on gear 4.8 	
										
										
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %
					
					
				break;


				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	

			//CalcUnits(&DC_Mtr[i]);
			DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;

						
		}


		/***********************************/
		
			for(i = 0 ; i < TML_SERVO_NUM ; i++){
		
				switch(i){
		
				
					// tml->_int.kPos = (tml->_cfg.units * tml->_cfg.rev_scale) / tml->_cfg.rev_motor;
					case TML_AX_AVC:					
						

						strcpy(TML_MTR_INST[i].Name , "AVC");
								
						// Analog Feedback from REF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.units = 4095;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
						TML_MTR_INST[i]._cfg.maxVel = 10.0; //1//6000 rpm
						TML_MTR_INST[i]._cfg.maxAcc = 100000.0;	
						//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.absFbk = 0; // absolute value feedback
													
						TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1423_AVC_FH_MINI_ENC_US.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1423");	
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0423_AVC_FH_MINI_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0423");	
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}				
					
						//TML_MTR_INST[i]._cfg.sftLimitPos = 1000.0;
						//TML_MTR_INST[i]._cfg.sftLimitNeg = -1000.0;	
		
					break;
					
					case TML_AX_OSC:

						strcpy(TML_MTR_INST[i].Name , "OSC");


						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1412_OSC_FH_MINI_ENC_US.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1412");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0412_OSC_FH_MINI_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0412");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}				

						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.absFbk = 0; // value fom APOS which is analog Ref
						TML_MTR_INST[i]._cfg.units = 4096.0 ;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 80.0;  // this comes from experiment
						//TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 56.0; // this comes from drawings
						TML_MTR_INST[i]._cfg.maxVel = 100.0; 
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;

						TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
						TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;								
												
						
					break;

					case TML_AX_TVL:				
						

						strcpy(TML_MTR_INST[i].Name , "TVL");
					
						/// Deferent TML programs
						// Back EMF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;	

						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1411_TVL_FH_MINI_ENC_US.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1411");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0411_TVL_FH_MINI_ENC.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0411");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}				

									
						TML_MTR_INST[i]._cfg.units =  1000; //  to jest tyle ile z max speed TML EREF
						TML_MTR_INST[i]._cfg.rev_scale = -1920.0;
						TML_MTR_INST[i]._cfg.rev_motor = 1.0 ;
						TML_MTR_INST[i]._cfg.maxVel =  10.0; // mm/s
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;
						TML_MTR_INST[i]._cfg.absFbk = 0; // non absolute value feedback , remember last value before drive reset


		
					break;

					default:

						xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
						TML_MTR_INST[i].pState = 0;

					break;	
		
				}	
		
			TML_MTR_INST[i].xCMD = TML_RESTART;
		
			
		}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 3; 
		TML_mgr[0].hrdw[1].AxisNum = 0;

		TML_mgr[0].pAxis[0] = &AxisCh[0];
		TML_mgr[0].pAxis[1] = 0;
		//TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = 0;
		//TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		AxisCh[TML_AX_OSC].AxisID 	= 2;		
		AxisCh[TML_AX_AVC].AxisID 	= 3;		

		/**************************************/
		/****   Process   ************************/
	
		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

				break;	

			}

		}
			
		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
										
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 0;

					AVC_Param_Set[i].MaxSpeedJog = 24.0;					
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					OSC_TML_Param_Set[i].Mode = 0;

					////  New Oscillation concept - BEMF
					OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
			 		OSC_TML_Param_Set[i].SpeedFactor = 410;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;


					/////////////////////////
					/////   Hardcoded Limits 
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}
					
					////////////////////////////////////////////////		
					
					
				break;	

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					//GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");


					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
					WIRE_Param_Set[i].VectStateNum = 1;
					WIRE_Param_Set[i].Mode = 0;  // classic

					
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
								
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
					WIRE_Param_Set[i].VectStateNum = 1;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					

					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].MaxSpeedJog = 24.0;				

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 3;

							
			
				break;


			}		
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Disable = 1;
					
				break;	

			}			
				
		}
		
				
	return 1;
	
}

DINT Configure_D_HEAD_HP(MASTER_typ * m,UINT headType){
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;


	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	
	
	
	/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	DC_Mtr[m->pCfg->HeadCfg.WF.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WP.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WF.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WP.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];


/*

	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
		m->pCfg->HeadCfg.WF.VECT_A_Indx]
	DC_Mtr[DC_AX_WF].Disable = 1;
	DC_Mtr[DC_AX_WP].Disable = 1;
	DC_Mtr[DC_AX_WF_1].Disable = 1;
	DC_Mtr[DC_AX_WP_1].Disable = 1;

	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;

	//Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;
*/
	Process[PROC_TVL].Disable = 0;
	Process[PROC_OSC].Disable = 0;
	Process[PROC_AVC].Disable = 0;
	Process[PROC_WIRE_FEED].Disable = 0;
	Process[PROC_WIRE_PULSE].Disable = 0;

	VectorStateMach[VECT_AVC].simul = 0;
	VectorStateMach[VECT_OSC].simul = 0;	
	VectorStateMach[VECT_TVL].simul = 0;	
	
	DC_Mtr[DC_AX_WF].Disable = 0;
	DC_Mtr[DC_AX_WP].Disable = 0;
	DC_Mtr[DC_AX_WF_1].Disable = 1;
	DC_Mtr[DC_AX_WP_1].Disable = 1;

	TML_MTR_INST[TML_AX_AVC].Disable = 0;
	TML_MTR_INST[TML_AX_OSC].Disable = 0;
	TML_MTR_INST[TML_AX_TVL].Disable = 0;


	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");

		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////


		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
		
			switch(i){			

			
				case DC_AX_WF:
				case DC_AX_WF_1:

					switch(i){

						case DC_AX_WF:
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#1");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							

							

						break;
						
						case DC_AX_WF_1: 
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#2");

							//DC_Mtr[i].Cfg.mtr_dir = -1.0;
							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 59.847340050885561192713356451475; // 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 66.0;	// Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		
				

				case DC_AX_WP:					
				case DC_AX_WP_1:

					switch(i){

						case DC_AX_WP:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#1");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							
							

						break;	
						
						case DC_AX_WP_1:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#2");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
													
							
							
						break;	

					}					

					//oryginalnie jest 2000 pulsow na obrot potem ratio on gear 4.8 : 1
					DC_Mtr[i].Cfg.units = 2000; 
					DC_Mtr[i].Cfg.rev_scale = 4.8;// ratio on gear 4.8 	
										
										
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %
					
					
				break;


				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	

			//CalcUnits(&DC_Mtr[i]);
			DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;

						
		}


		/***********************************/
		
			for(i = 0 ; i < TML_SERVO_NUM ; i++){
		
				switch(i){
		
				
					// tml->_int.kPos = (tml->_cfg.units * tml->_cfg.rev_scale) / tml->_cfg.rev_motor;
					case TML_AX_AVC:					
						

						strcpy(TML_MTR_INST[i].Name , "AVC");
								
						// Analog Feedback from REF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.units = 4095;
						TML_MTR_INST[i]._cfg.rev_motor = -1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
						TML_MTR_INST[i]._cfg.maxVel = 10.0; //1//6000 rpm
						TML_MTR_INST[i]._cfg.maxAcc = 100000.0;	
						//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.absFbk = 0; // absolute value feedback
													
						TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

						if(ProjectConfig == project_US_Orbital){
						
							strcpy(TML_MTR_INST[i]._cfg.programName , "1423_AVC_FH_MINI_ENC_US.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1423");	
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;						
							

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0423_AVC_FH_MINI_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0423");	
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}				
					
						//TML_MTR_INST[i]._cfg.sftLimitPos = 1000.0;
						//TML_MTR_INST[i]._cfg.sftLimitNeg = -1000.0;	
		
					break;
					
					case TML_AX_OSC:

						strcpy(TML_MTR_INST[i].Name , "OSC");


						if(ProjectConfig == project_US_Orbital){

							/*
							strcpy(TML_MTR_INST[i]._cfg.programName , "1412_OSC_FH_MINI_ENC_US.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1412");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
							*/
							
							// New Osc Mode -  11;
							strcpy(TML_MTR_INST[i]._cfg.programName , "2512_OSC_D_HEAD_US.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2512");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0412_OSC_FH_MINI_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0412");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}				

						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.absFbk = 0; // value fom APOS which is analog Ref
						TML_MTR_INST[i]._cfg.units = 4096.0 ;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 0.0375;  // this comes from experiment
						//TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 56.0; // this comes from drawings
						TML_MTR_INST[i]._cfg.maxVel = 100.0; 
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;

						TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
						TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;								
												
						
					break;

					case TML_AX_TVL:				
						

						strcpy(TML_MTR_INST[i].Name , "TVL");
					
						/// Deferent TML programs
						// Back EMF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;	

						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "2511_TVL_D_HEAD_US.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("2511");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0411_TVL_FH_MINI_ENC.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0411");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
						}				

									
						TML_MTR_INST[i]._cfg.units =  1000; //  to jest tyle ile z max speed TML EREF
						//TML_MTR_INST[i]._cfg.rev_scale = -1920.0;
						TML_MTR_INST[i]._cfg.rev_scale =4000.0;
						TML_MTR_INST[i]._cfg.rev_motor = 1.0 ;
						TML_MTR_INST[i]._cfg.maxVel =  4; // mm/s
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;
						TML_MTR_INST[i]._cfg.absFbk = 0; // non absolute value feedback , remember last value before drive reset


		
					break;

					default:

						xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
						TML_MTR_INST[i].pState = 0;

					break;	
		
				}	
		
			TML_MTR_INST[i].xCMD = TML_RESTART;
		
			
		}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 3; 
		TML_mgr[0].hrdw[1].AxisNum = 0;

		TML_mgr[0].pAxis[0] = &AxisCh[0];
		TML_mgr[0].pAxis[1] = 0;
		//TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = 0;
		//TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		AxisCh[TML_AX_OSC].AxisID 	= 2;		
		AxisCh[TML_AX_AVC].AxisID 	= 3;		

		/**************************************/
		/****   Process   ************************/
	
		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					
				
					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;

				break;	

			}

		}
			
		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
										
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 0;

					AVC_Param_Set[i].MaxSpeedJog = 24.0;					
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					//OSC_TML_Param_Set[i].Mode = 0;
					OSC_TML_Param_Set[i].Mode = 11; // New Osc Mode -

					////  New Oscillation concept - BEMF
					OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
			 		OSC_TML_Param_Set[i].SpeedFactor = 410;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;


					/////////////////////////
					/////   Hardcoded Limits 
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}
					
					////////////////////////////////////////////////		
					
					
				break;	

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					//GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;

					Process[PROC_HW_PS].Disable = 1;
											
				
				break;	

			}	
							
		}	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");


					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
					WIRE_Param_Set[i].VectStateNum = 1;
					WIRE_Param_Set[i].Mode = 0;  // classic

					
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
								
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
					WIRE_Param_Set[i].VectStateNum = 1;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];

					Process[PROC_WIRE_PULSE].Disable = 0;
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					

					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].MaxSpeedJog = 24.0;				

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 3;

							
			
				break;


			}		
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Disable = 1;
					
				break;	

			}			
				
		}
		
				
	return 1;
	
}

DINT Configure_U_BEND_HP_PINS(MASTER_typ * m,UINT headType){
return 1;
};

#if 0
DINT Configure_U_BEND_HP_PINS(MASTER_typ * m,UINT headType){
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;



	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	
	
	
	/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[TML_AX_AVC].pState = &VectorStateMach[VECT_AVC];
	TML_MTR_INST[TML_AX_OSC].pState = &VectorStateMach[VECT_OSC];	
	TML_MTR_INST[TML_AX_TVL].pState = &VectorStateMach[VECT_TVL];	
	
	DC_Mtr[DC_AX_WF].pState = &VectorStateMach[VECT_WF];
	DC_Mtr[DC_AX_WP].pState = &VectorStateMach[VECT_WP];
	DC_Mtr[DC_AX_WF_1].pState = &VectorStateMach[VECT_WF_1];
	DC_Mtr[DC_AX_WP_1].pState = &VectorStateMach[VECT_WP_1];


#ifdef TEST_ONLY_PLC_ANDROID

	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
		
	DC_Mtr[DC_AX_WF].Disable = 1;
	DC_Mtr[DC_AX_WP].Disable = 1;
	DC_Mtr[DC_AX_WF_1].Disable = 1;
	DC_Mtr[DC_AX_WP_1].Disable = 1;

	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;

	//Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;
#endif

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");
		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
		
			switch(i){

			
				case DC_AX_WF:
				case DC_AX_WF_1:

					switch(i){

						case DC_AX_WF:
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#1");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
							DC_Mtr[i].Cfg.enc_dir = 1.0;
							

							

						break;
						
						case DC_AX_WF_1: 
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#2");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
							DC_Mtr[i].Cfg.enc_dir = 1.0;
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 59.847340050885561192713356451475; // 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 66.0;	// Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;
				

				case DC_AX_WP:					
				case DC_AX_WP_1:

					switch(i){

						case DC_AX_WP:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#1");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
							DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							

						break;	
						
						case DC_AX_WP_1:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#2");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;
							DC_Mtr[i].Cfg.enc_dir = 1.0;							
							
							
						break;	

					}					

					//oryginalnie jest 2000 pulsow na obrot potem ratio on gear 4.8 : 1
					DC_Mtr[i].Cfg.units = 2000; 
					DC_Mtr[i].Cfg.rev_scale = 4.8;// ratio on gear 4.8 	
										
										
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %
					
					
				break;


				default:

					strcpy(DC_Mtr[i].Name , "Spare ");

				break;	
	
		
			}	

			//CalcUnits(&DC_Mtr[i]);
			DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;

						
		}


		/***********************************/
		
			for(i = 0 ; i < TML_SERVO_NUM ; i++){
		
				switch(i){
		
				
					// tml->_int.kPos = (tml->_cfg.units * tml->_cfg.rev_scale) / tml->_cfg.rev_motor;
					case TML_AX_AVC:

						strcpy(TML_MTR_INST[i].Name , "AVC");
								
						// Analog Feedback from REF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.units = 4095;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
						TML_MTR_INST[i]._cfg.maxVel = 1.0; //1//6000 rpm
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;	
						//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.absFbk = 0; // absolute value feedback
													
						TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

						//U_BEND_HP_PINS
						strcpy(TML_MTR_INST[i]._cfg.programName , "0013_AVC_U_BEND_HP_PINS.sw");
						TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0013");							
						
						TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C

						//TML_MTR_INST[i]._cfg.sftLimitPos = 1000.0;
						//TML_MTR_INST[i]._cfg.sftLimitNeg = -1000.0;	
		
					break;
					
					case TML_AX_OSC:

						strcpy(TML_MTR_INST[i].Name , "OSC");
												
						// Analog Feedback from REF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
									
						TML_MTR_INST[i]._cfg.units = 80;
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0;
						TML_MTR_INST[i]._cfg.maxVel = 100.0; //1//6000 rpm
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;
						TML_MTR_INST[i]._cfg.absFbk = 0; // absolute value feedback
						
						// U_BEND_HP_PINS
						strcpy(TML_MTR_INST[i]._cfg.programName , "0012_OSC_U_BEND_HP_PINS.sw");
						TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0012");
											
					
						TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B

						//TML_MTR_INST[i]._cfg.sftLimitPos = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];
						
						//TML_MTR_INST[i]._cfg.sftLimitNeg = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];		
					
		
					break;

					case TML_AX_TVL:


						strcpy(TML_MTR_INST[i].Name , "TVL");
						// Back EMF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.units = 1000 * 60; // unit rps/sec
						TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 10.2;
						TML_MTR_INST[i]._cfg.maxVel =  3.0; // mm/s
						TML_MTR_INST[i]._cfg.maxAcc = 20.0;
						TML_MTR_INST[i]._cfg.absFbk = 0; // non absolute value feedback , remember last value before drive reset

						//* U_BEND_HP_PINS					
						strcpy(TML_MTR_INST[i]._cfg.programName , "0011_TVL_U_BEND_HP_PINS.sw");											
						TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0011");
						
						TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674B
		
					break;

					default:

						xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
						TML_MTR_INST[i].pState = 0;

					break;	
		
				}	
		
			TML_MTR_INST[i].xCMD = TML_RESTART;
		
			
		}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 3; 
		TML_mgr[0].hrdw[1].AxisNum = 0;

		TML_mgr[0].pAxis[0] = &AxisCh[0];
		TML_mgr[0].pAxis[1] = 0;
		//TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = 0;
		//TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		AxisCh[TML_AX_OSC].AxisID 	= 2;		
		AxisCh[TML_AX_AVC].AxisID 	= 3;		

		/**************************************/
		/****   Process   ************************/
	
		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];					

					/*
					// This is only when we use two analog aoutputs to reach 15V
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					PS_Param_Set[i].rawCmdMax			= 26170; // //
					PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					*/

					// Only one analog output - 10V -> 345 Amps	
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					PS_Param_Set[i].rawCmdMax 			= 32767.0;
					//PS_Param_Set[i].AmpCMD_Max		= 345.0;
					PS_Param_Set[i].AmpCMD_Max			= 500.0; // new firmware				
				

				break;	

			}

		}


		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
					
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	
					
					
				break;	

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					//GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");
									
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WF];
					WIRE_Param_Set[i].VectStateNum = 1;

					
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
								
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[VECT_WP];
					WIRE_Param_Set[i].VectStateNum = 1;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					

					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];
			
			
				break;


			}
			
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Disable = 1;
					
				break;	

			}			
				
		}

	// One oscillator
	//m->OscNum = 1;

	//m->directTVL = -1;
				
	return 1;
	
}
#endif

DINT Configure_U_BEND_HP_ENC(MASTER_typ * m,UINT headType){
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;


	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	
	
	
	/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	DC_Mtr[m->pCfg->HeadCfg.WF.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WP.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WF.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WP.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];


#ifdef SYSTEM_SIMULATION

	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
	
	DC_Mtr[DC_AX_WF].Disable = 1;
	DC_Mtr[DC_AX_WP].Disable = 1;
	DC_Mtr[DC_AX_WF_1].Disable = 1;
	DC_Mtr[DC_AX_WP_1].Disable = 1;

	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;

	//Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;

	
#else


	Process[PROC_TVL].Disable = 0;
	Process[PROC_OSC].Disable = 0;
	Process[PROC_AVC].Disable = 0;
	Process[PROC_WIRE_FEED].Disable = 0;
	Process[PROC_WIRE_PULSE].Disable = 0;

	VectorStateMach[VECT_AVC].simul = 0;
	VectorStateMach[VECT_OSC].simul = 0;	
	VectorStateMach[VECT_TVL].simul = 0;	

	VectorStateMach[VECT_WF].simul 		= 0;
	VectorStateMach[VECT_WF_1].simul 	= 0;
	VectorStateMach[VECT_WP].simul 		= 0;
	VectorStateMach[VECT_WP_1].simul 	= 0;
	
	DC_Mtr[DC_AX_WF].Disable = 0;
	DC_Mtr[DC_AX_WP].Disable = 0;
	DC_Mtr[DC_AX_WF_1].Disable = 0;
	DC_Mtr[DC_AX_WP_1].Disable = 0;

	TML_MTR_INST[TML_AX_AVC].Disable = 0;
	TML_MTR_INST[TML_AX_OSC].Disable = 0;
	TML_MTR_INST[TML_AX_TVL].Disable = 0;
	
#endif

	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");

		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////


		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
		
			switch(i){			

			
				case DC_AX_WF:
				case DC_AX_WF_1:

					switch(i){

						case DC_AX_WF:
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#1");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							

							

						break;
						
						case DC_AX_WF_1: 
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#2");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 59.847340050885561192713356451475; // 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 66.0;	// Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		
				

				case DC_AX_WP:					
				case DC_AX_WP_1:

					switch(i){

						case DC_AX_WP:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#1");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							

						break;	
						
						case DC_AX_WP_1:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#2");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							
						break;	

					}					

					//oryginalnie jest 2000 pulsow na obrot potem ratio on gear 4.8 : 1
					DC_Mtr[i].Cfg.units = 2000; 
					DC_Mtr[i].Cfg.rev_scale = 4.8;// ratio on gear 4.8 	
										
										
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %
					
					
				break;


				default:

					//strcpy(DC_Mtr[i].Name , "Spare ");
					xsprintf(DC_Mtr[i].Name, "Spare %d", i );

				break;	
	
		
			}	

			//CalcUnits(&DC_Mtr[i]);
			DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;

						
		}


		/***********************************/
		
			for(i = 0 ; i < TML_SERVO_NUM ; i++){
		
				switch(i){
		
				
					// tml->_int.kPos = (tml->_cfg.units * tml->_cfg.rev_scale) / tml->_cfg.rev_motor;
					case TML_AX_AVC:					
						

						strcpy(TML_MTR_INST[i].Name , "AVC");
								
						// Analog Feedback from REF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.units = 4095;
						//TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
						TML_MTR_INST[i]._cfg.maxVel = 10.0; //1//6000 rpm
						TML_MTR_INST[i]._cfg.maxAcc = 100000.0;	
						//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
						//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
						//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.absFbk = 0; // absolute value feedback
													
						TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1023_AVC_U_BEND_ENC_US.sw");								
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1023");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
							TML_MTR_INST[i]._cfg.rev_motor = -1.0;							
							TML_MTR_INST[i]._cfg.kppMax = -32000; // KPP bylo Stauration of proportional gain
							TML_MTR_INST[i]._cfg.kipMax = -200; // KPP bylo Stauration of proportional gain

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0023_AVC_U_BEND_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0023");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C	
							TML_MTR_INST[i]._cfg.rev_motor = 1.0;							
							TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
							TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
						}	

						//TML_MTR_INST[i]._cfg.sftLimitPos = 1000.0;
						//TML_MTR_INST[i]._cfg.sftLimitNeg = -1000.0;	
		
					break;
					
					case TML_AX_OSC:

						strcpy(TML_MTR_INST[i].Name , "OSC");


						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1022_OSC_U_BEND_ENC_US.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1022");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B							
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
							TML_MTR_INST[i]._cfg.rev_motor = -1.0;
							
						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0022_OSC_U_BEND_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0022");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
							TML_MTR_INST[i]._cfg.rev_motor = 1.0;
														
						}	

						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.absFbk = 0; // value fom APOS which is analog Ref
						TML_MTR_INST[i]._cfg.units = 4096.0 ;
						//TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 80.0;  // this comes from experiment
						//TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 56.0; // this comes from drawings
						TML_MTR_INST[i]._cfg.maxVel = 100.0; 
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;

						TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
						TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;								
												
						
					break;

					case TML_AX_TVL:				
						

						strcpy(TML_MTR_INST[i].Name , "TVL");
					
						/// Deferent TML programs
						// Back EMF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;		

						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1021_TVL_U_BEND_ENC_US.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1021");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
							TML_MTR_INST[i]._cfg.rev_motor = -1.0;
							TML_MTR_INST[i]._cfg.rev_scale = -1920.0;

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0021_TVL_U_BEND_ENC.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0021");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
							TML_MTR_INST[i]._cfg.rev_motor = -1.0;
							TML_MTR_INST[i]._cfg.rev_scale = -1920.0;
						}	
										
						TML_MTR_INST[i]._cfg.units =  1000; //  to jest tyle ile z max speed TML EREF
						//TML_MTR_INST[i]._cfg.rev_scale = -1920.0;
						//TML_MTR_INST[i]._cfg.rev_motor = 1.0 ;
						TML_MTR_INST[i]._cfg.maxVel =  10.0; // mm/s
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;
						TML_MTR_INST[i]._cfg.absFbk = 0; // non absolute value feedback , remember last value before drive reset

					break;

					default:

						//xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
						xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );

					break;	
		
				}	
		
			TML_MTR_INST[i].xCMD = TML_RESTART;
		
			
		}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 3; 
		TML_mgr[0].hrdw[1].AxisNum = 0;

		TML_mgr[0].pAxis[0] = &AxisCh[0];
		TML_mgr[0].pAxis[1] = 0;
		//TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = 0;
		//TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		AxisCh[TML_AX_OSC].AxisID 	= 2;		
		AxisCh[TML_AX_AVC].AxisID 	= 3;		

		/**************************************/
		/****   Process   ************************/
	
		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					

					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;
				

				break;	

			}

		}
			
		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
										
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 0;

					AVC_Param_Set[i].MaxSpeedJog = 24.0;					
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					OSC_TML_Param_Set[i].Mode = 0;

					////  New Oscillation concept - BEMF
					OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
			 		OSC_TML_Param_Set[i].SpeedFactor = 410;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;

					/////////////////////////
					/////   Hardcoded Limits 
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}
					
					////////////////////////////////////////////////		
					
					
				break;	

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					//GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");


					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
					WIRE_Param_Set[i].VectStateNum = 1;
					WIRE_Param_Set[i].Mode = 0;  // classic

					
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
								
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
					WIRE_Param_Set[i].VectStateNum = 1;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					

					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;

					TVL_ROT_Param_Set[i].MaxSpeedJog = 24.0;				

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 3;

							
			
				break;


			}		
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Disable = 1;
					
				break;	

			}			
				
		}		
				
	return 1;
	
}

DINT Configure_U_BEND_HP_ENC_BEMF(MASTER_typ * m,UINT headType){
int i;

CurCfg_typ *curCfg;
Cfg_typ *cfg;
CurCalib_typ *curCalib , *defaultCalib;


	if(!m)
		return;

	
	curCfg = (CurCfg_typ*)m->pCurCfg;
	cfg = (Cfg_typ*)m->pCfg;

	curCalib = m->pCalib;
	defaultCalib = m->pDefaultCalib;

	if(!curCfg || !cfg || !curCalib  || !defaultCalib)
		return;	
	
	
	/*********************************************/
	/***   Hardware and Vectors *********************/

	TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx];
	
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];
	TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];
	
	DC_Mtr[m->pCfg->HeadCfg.WF.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WP.DC_A_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WF.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];
	DC_Mtr[m->pCfg->HeadCfg.WP.DC_B_Indx ].pState = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];


/*

	VectorStateMach[VECT_AVC].simul = 1;
	VectorStateMach[VECT_OSC].simul = 1;	
	VectorStateMach[VECT_TVL].simul = 1;	
	VectorStateMach[VECT_WF].simul = 1;
	VectorStateMach[VECT_WP].simul = 1;
	VectorStateMach[VECT_WF_1].simul = 1;
	VectorStateMach[VECT_WP_1].simul = 1;
		m->pCfg->HeadCfg.WF.VECT_A_Indx]
	DC_Mtr[DC_AX_WF].Disable = 1;
	DC_Mtr[DC_AX_WP].Disable = 1;
	DC_Mtr[DC_AX_WF_1].Disable = 1;
	DC_Mtr[DC_AX_WP_1].Disable = 1;

	TML_MTR_INST[TML_AX_AVC].Disable = 1;
	TML_MTR_INST[TML_AX_OSC].Disable = 1;
	TML_MTR_INST[TML_AX_TVL].Disable = 1;

	//Process[PROC_AVC].Disable = 1;
	Process[PROC_AVC].TestMode = 1;
*/
	Process[PROC_TVL].Disable = 0;
	Process[PROC_OSC].Disable = 0;
	Process[PROC_AVC].Disable = 0;
	Process[PROC_WIRE_FEED].Disable = 0;
	Process[PROC_WIRE_PULSE].Disable = 0;

	VectorStateMach[VECT_AVC].simul = 0;
	VectorStateMach[VECT_OSC].simul = 0;	
	VectorStateMach[VECT_TVL].simul = 0;	

	VectorStateMach[VECT_WF].simul 		= 0;
	VectorStateMach[VECT_WF_1].simul 	= 0;
	VectorStateMach[VECT_WP].simul 		= 0;
	VectorStateMach[VECT_WP_1].simul 	= 0;
	
	DC_Mtr[DC_AX_WF].Disable = 0;
	DC_Mtr[DC_AX_WP].Disable = 0;
	DC_Mtr[DC_AX_WF_1].Disable = 0;
	DC_Mtr[DC_AX_WP_1].Disable = 0;

	TML_MTR_INST[TML_AX_AVC].Disable = 0;
	TML_MTR_INST[TML_AX_OSC].Disable = 0;
	TML_MTR_INST[TML_AX_TVL].Disable = 0;


	/*********************************************************/
	/****   Phisical hardware configuration   ************************/

		for(i = 0 ; i < PROCESS_NUM; i++)
			strcpy(Process[i].Name , "spare");

		for(i = 0 ; i < VECTORS_NUM; i++)
			strcpy(VectorStateMach[i].Name , "spare");

		//////////////////////////////////////////////////////////////////////////////////
		// Wire Block
		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_UD");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_UD");
				
					WR_BLK_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.WB[i].PROC_Indx];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	

				case 1:
					strcpy(Process[m->pCfg->HeadCfg.WB[i].PROC_Indx].Name , "WB_LR");
					strcpy(VectorStateMach[m->pCfg->HeadCfg.WB[i].VECT_Indx].Name , "WB_LR");
				
					WR_BLK_Param_Set[i].pPrc = &Process[PROC_WB_LR];
					WR_BLK_Param_Set[i].pVect = &VectorStateMach[VECT_WB_LR];
					WR_BLK_Param_Set[i].VectStateNum = 1;	

					WR_BLK_Param_Set[i].MaxSpeedJog = 24.0;

					Gen_one = 1.0;
					WR_BLK_Param_Set[i].pJogSpeed = &Gen_one;
					
				break;	


			}
			
		}	


		for(i = 0 ; i < DC2DIRMTR_NUM; i++){

			switch(i){

			
				case DC_WB_UD:
					
					strcpy(DC2DirMtr[i].Name , "WB_UD");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_UD];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[12];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[13];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[14];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[15];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;
					
				break;

				
				case DC_WB_LR:
					
					strcpy(DC2DirMtr[i].Name , "WB_LR");
					DC2DirMtr[i].pState = &VectorStateMach[VECT_WB_LR];
				
					DC2DirMtr[i].Cfg.pQ1_output = &Hardware[1].Outp[16];
					DC2DirMtr[i].Cfg.pQ2_output = &Hardware[1].Outp[17];
					DC2DirMtr[i].Cfg.pQ3_output = &Hardware[1].Outp[18];
					DC2DirMtr[i].Cfg.pQ4_output = &Hardware[1].Outp[19];

					DC2DirMtr[i].Cfg.MtrDir = 1.0;

				break;

			}	


		}
		/////////////////////////////////////////////////////////////////////////////////


		
		for(i = 0 ; i < GEN_MTR_NUM; i++){
		
			switch(i){			

			
				case DC_AX_WF:
				case DC_AX_WF_1:

					switch(i){

						case DC_AX_WF:
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#1");

							DC_Mtr[i].Cfg.mtr_dir = -1.0;
						
							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							

							

						break;
						
						case DC_AX_WF_1: 
							
							strcpy(DC_Mtr[i].Name , "DC WFeed#2");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							

						break;	

					}

					

					//DC_Mtr[i].Cfg.units = 59.847340050885561192713356451475; // 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.units = 2000 / 59.847340050885561192713356451475; // 2000 enc ticks / 0.75 " dia * 25.4 * PI
					DC_Mtr[i].Cfg.rev_scale = 66.0;	// Ratio gear box 66:1 
					
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %				
					
						
				
				break;		
				

				case DC_AX_WP:					
				case DC_AX_WP_1:

					switch(i){

						case DC_AX_WP:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#1");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							

						break;	
						
						case DC_AX_WP_1:
							
							strcpy(DC_Mtr[i].Name , "DC WPulse#2");

							DC_Mtr[i].Cfg.mtr_dir = 1.0;

							if(ProjectConfig == project_US_Orbital) // US Orbital has B and /B swapped
								DC_Mtr[i].Cfg.enc_dir = -1.0;
							else
								DC_Mtr[i].Cfg.enc_dir = 1.0;
							
							
						break;	

					}					

					//oryginalnie jest 2000 pulsow na obrot potem ratio on gear 4.8 : 1
					DC_Mtr[i].Cfg.units = 2000; 
					DC_Mtr[i].Cfg.rev_scale = 4.8;// ratio on gear 4.8 	
										
										
					/* Parameters for PID controller */
					// To nowe
					DC_Mtr[i].msc.PIDParameters.Kp= 1.0;//0.4; //proportional gain / was 0.6
					//DC_Mtr[i].msc.PIDParameters.Kp= 0.1;//0.4; //proportional gain / was 0.6
					DC_Mtr[i].msc.PIDParameters.Tn= 0.1;//0.3.1; //intergral action time
					DC_Mtr[i].msc.PIDParameters.Kfbk = 0.01; //windup dampenin
					
					DC_Mtr[i].msc.PID.enable = 0;
					DC_Mtr[i].msc.PID.pPar = &DC_Mtr[i].msc.PIDParameters;	
					DC_Mtr[i].msc.PID.request = 3; // Read parameters from PIDParameters	
					DC_Mtr[i].msc.PIDParameters.Tv= 0; //derivative action time
					DC_Mtr[i].msc.PIDParameters.Y_max = 100.0;  //max manipulated variable %
					DC_Mtr[i].msc.PIDParameters.Y_min = -100.0; //min manipulated variable %
					
					
				break;


				default:

					//strcpy(DC_Mtr[i].Name , "Spare ");
					xsprintf(DC_Mtr[i].Name, "Spare %d", i );

				break;	
	
		
			}	

			//CalcUnits(&DC_Mtr[i]);
			DC_Mtr[i].msc.kPos = (float)DC_Mtr[i].Cfg.units * DC_Mtr[i].Cfg.rev_scale;

						
		}


		/***********************************/
		
			for(i = 0 ; i < TML_SERVO_NUM ; i++){
		
				switch(i){
		
				
					// tml->_int.kPos = (tml->_cfg.units * tml->_cfg.rev_scale) / tml->_cfg.rev_motor;
					case TML_AX_AVC:					
						

						strcpy(TML_MTR_INST[i].Name , "AVC");
								
						// Analog Feedback from REF
						//TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.units = 4095;
						//TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0/5.0;
						//TML_MTR_INST[i]._cfg.maxVel = 10.0; //1//6000 rpm
						//TML_MTR_INST[i]._cfg.maxAcc = 100000.0;	
						//TML_MTR_INST[i]._cfg.satpMax = 27853; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.satpMax = 32000; // KPP bylo Stauration of proportional gain
						//TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
						//TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain
						TML_MTR_INST[i]._cfg.absFbk = 0; // absolute value feedback
													
						TML_MTR_INST[i]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];

						
						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1123_AVC_U_BEND_ENC_US_BEMF.sw");								
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1123");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
							TML_MTR_INST[i]._cfg.rev_motor = -1.0;							
							TML_MTR_INST[i]._cfg.kppMax = -32000; // KPP bylo Stauration of proportional gain
							TML_MTR_INST[i]._cfg.kipMax = -200; // KPP bylo Stauration of proportional gain

							TML_MTR_INST[i]._cfg.maxVel = 200.0; //1//6000 rpm
							TML_MTR_INST[i]._cfg.maxAcc = 100000.0;	
							
							TML_MTR_INST[i]._cfg.loopPeriod = 0.01; // real BEMF - experimental value

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0023_AVC_U_BEND_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0023");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C	
							TML_MTR_INST[i]._cfg.rev_motor = 1.0;							
							TML_MTR_INST[i]._cfg.kppMax = 32000; // KPP bylo Stauration of proportional gain
							TML_MTR_INST[i]._cfg.kipMax = 200; // KPP bylo Stauration of proportional gain

							TML_MTR_INST[i]._cfg.maxVel = 10.0; //1//6000 rpm
							TML_MTR_INST[i]._cfg.maxAcc = 100000.0;	

							TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						}	

						//TML_MTR_INST[i]._cfg.sftLimitPos = 1000.0;
						//TML_MTR_INST[i]._cfg.sftLimitNeg = -1000.0;	
		
					break;
					
					case TML_AX_OSC:

						strcpy(TML_MTR_INST[i].Name , "OSC");


						if(ProjectConfig == project_US_Orbital){
							strcpy(TML_MTR_INST[i]._cfg.programName , "1122_OSC_U_BEND_ENC_US_BEMF.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1122");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B							
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
							//TML_MTR_INST[i]._cfg.rev_motor = -1.0;
							TML_MTR_INST[i]._cfg.rev_motor = 1.0;
							
						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , "0022_OSC_U_BEND_ENC.sw");
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("0022");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
							TML_MTR_INST[i]._cfg.rev_motor = 1.0;
														
						}	

						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;
						TML_MTR_INST[i]._cfg.absFbk = 0; // value fom APOS which is analog Ref
						TML_MTR_INST[i]._cfg.units = 4096.0 ;
						//TML_MTR_INST[i]._cfg.rev_motor = 1;
						TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 80.0;  // this comes from experiment
						//TML_MTR_INST[i]._cfg.rev_scale = 1.0 / 56.0; // this comes from drawings
						TML_MTR_INST[i]._cfg.maxVel = 100.0; 
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;

						TML_MTR_INST[i]._cfg.AnalLimitPos = 3900;
						TML_MTR_INST[i]._cfg.AnalLimitNeg = 100;								
												
						
					break;

					case TML_AX_TVL:				
						

						strcpy(TML_MTR_INST[i].Name , "TVL");
					
						/// Deferent TML programs
						// Back EMF
						TML_MTR_INST[i]._cfg.loopPeriod = 0.001;		

						if(ProjectConfig == project_US_Orbital){


							strcpy(TML_MTR_INST[i]._cfg.programName , "1021_TVL_U_BEND_ENC_US.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1021");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
							TML_MTR_INST[i]._cfg.rev_motor = -1.0;
							TML_MTR_INST[i]._cfg.rev_scale = -1920.0;
							TML_MTR_INST[i]._cfg.units =  1000; //  to jest tyle ile z max speed TML EREF
							

							/* gotowe
							strcpy(TML_MTR_INST[i]._cfg.programName , "1121_TVL_U_BEND_ENC_US_BEMF.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1121");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("6A2B");  //0x674B
							TML_MTR_INST[i]._cfg.Appl_ID_adr = 0x7FCF;
							TML_MTR_INST[i]._cfg.rev_motor = -1.0;
							TML_MTR_INST[i]._cfg.rev_scale = -1920.0;
							TML_MTR_INST[i]._cfg.units =  70;
							*/

						}
						else{
							strcpy(TML_MTR_INST[i]._cfg.programName , " 1021_TVL_U_BEND_ENC_US.sw");	
							TML_MTR_INST[i].ProgramVersion = ASC2UDINT("1021");
							TML_MTR_INST[i].FirmwareVersion = ASC2UDINT("674C");  //0x674C
							TML_MTR_INST[i]._cfg.rev_motor = -1.0;
							TML_MTR_INST[i]._cfg.rev_scale = -1920.0;
							TML_MTR_INST[i]._cfg.units =  1000; //  to jest tyle ile z max speed TML EREF
						}	
										
						
						//TML_MTR_INST[i]._cfg.rev_scale = -1920.0;
						//TML_MTR_INST[i]._cfg.rev_motor = 1.0 ;
						TML_MTR_INST[i]._cfg.maxVel =  10.0; // mm/s
						TML_MTR_INST[i]._cfg.maxAcc = 100.0;
						TML_MTR_INST[i]._cfg.absFbk = 0; // non absolute value feedback , remember last value before drive reset

					break;

					default:

						//xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );
						xsprintf(TML_MTR_INST[i].Name, "Spare %d", i );

					break;	
		
				}	
		
			TML_MTR_INST[i].xCMD = TML_RESTART;
		
			
		}
		
		
		TML_mgr[0].hrdw[0].AxisNum = 3; 
		TML_mgr[0].hrdw[1].AxisNum = 0;

		TML_mgr[0].pAxis[0] = &AxisCh[0];
		TML_mgr[0].pAxis[1] = 0;
		//TML_mgr[0].pAxis[1] = &AxisCh[TML_mgr[0].hrdw[0].AxisNum];

		TML_mgr[0].pTML[0] = &TML_MTR_INST[0];
		TML_mgr[0].pTML[1] = 0;
		//TML_mgr[0].pTML[1] = &TML_MTR_INST[TML_mgr[0].hrdw[0].AxisNum];	

		AxisCh[TML_AX_TVL].AxisID	= 1;		
		AxisCh[TML_AX_OSC].AxisID 	= 2;		
		AxisCh[TML_AX_AVC].AxisID 	= 3;		

		/**************************************/
		/****   Process   ************************/
	
		// Lincoln Power Supply 
		for(i=0 ; i < 1; i++){
		
			switch(i){

				case 0: 
					
					strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
					PS_Param_Set[i].pPrc = &Process[PROC_TIG_PS];
				
					PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_AMPS_CMD];
					//PS_Param_Set[i].rawCmdMax			= 26170; // //
					//PS_Param_Set[i].AmpCMD_Max			= 500.0; // 62.5 amp / 1 V
					PS_Param_Set[i].rawCmdMax			= 32767;
					PS_Param_Set[i].AmpCMD_Max			= 627.0; 
					

					PS_Param_Set[i].pArcLinkRobot   = (UDINT)&ArcLink.robot;
				

				break;	

			}

		}
			
		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_AVC].Name , "AVC");
										
					strcpy(VectorStateMach[VECT_AVC].Name , "AVC");
										
					AVC_Param_Set[i].pPrc = &Process[PROC_AVC];
					AVC_Param_Set[i].pVect = &VectorStateMach[VECT_AVC];
					AVC_Param_Set[i].VectStateNum = 1;	
					AVC_Param_Set[i].Mode = 2; // Real BEMF Speed control

					AVC_Param_Set[i].MaxSpeedJog = 24.0;	

					if(ProjectConfig == project_US_Orbital){
						AVC_Param_Set[i].maxBEMFspeed = 200.0;
						AVC_Param_Set[i].Mode = 2; // Real BEMF Speed control
					}
					else{

						AVC_Param_Set[i].Mode = 0;

					}
					
					
					m->pCalib->Points[CALIB_TIG_VOLT_FBK].num = 10;
					AVC_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_TIG_VOLT_FBK];

					
				break;	

			}
		}


		for(i=0 ; i < 1 ; i++){	


			switch(i){

				case 0: 

					strcpy(Process[PROC_OSC].Name , "OSC");
					strcpy(VectorStateMach[VECT_OSC].Name , "OSC");
										
					OSC_TML_Param_Set[i].pPrc = &Process[PROC_OSC];	
					OSC_TML_Param_Set[i].pVect = &VectorStateMach[VECT_OSC];
					OSC_TML_Param_Set[i].VectStateNum = 1;
					OSC_TML_Param_Set[i].pTML = &TML_MTR_INST[TML_AX_OSC] ;	

					OSC_TML_Param_Set[i].Mode = 0;

					////  New Oscillation concept - BEMF
					OSC_TML_Param_Set[i].mm2ticks = TML_MTR_INST[TML_AX_OSC]._cfg.units * TML_MTR_INST[TML_AX_OSC]._cfg.rev_scale; 
			 		//OSC_TML_Param_Set[i].SpeedFactor = 410;
					//OSC_TML_Param_Set[i].MaxOscAmpl = 1.0 * 25.4;
					OSC_TML_Param_Set[i].MaxOscAmpl = 0.0;

					if(ProjectConfig == project_US_Orbital)
						OSC_TML_Param_Set[i].SpeedFactor = 100; // Real BEMF
					else
						OSC_TML_Param_Set[i].SpeedFactor = 410;

					/////////////////////////
					/////   Hardcoded Limits 
					if(cfg->HeadCfg.OSC.Limits_Harcoded){
						
						curCalib->Points[CALIB_OSC_SFT_LIMIT].num = 4;
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = 10.0;					
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = 75.0;	  
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[i].val[0]; 				
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[i].val[1];
					}
					
					////////////////////////////////////////////////		
					
					
				break;	

			}
				
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_GAS].Name , "GAS");
					GAS_Param_Set[i].pPrc = &Process[PROC_GAS];
										
					//GAS_Param_Set[i].pSensInput     = &Hardware[1].Inp[5];  //FourAxis Head
					GAS_Param_Set[i].pOutput		= &Hardware[1].Outp[4];
					
				break;	

			}

			
				
		}

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_COOL].Name , "COOLANT");
					COOL_Param_Set[i].pPrc = &Process[PROC_COOL];
										
					COOL_Param_Set[i].pSensInput     = &Hardware[1].Inp[4];  //FourAxis Head
					COOL_Param_Set[i].pOutput		= &Hardware[1].Outp[6];
					
								
				break;	

			}

							
		}




		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 
					
					strcpy(Process[PROC_HW_PS].Name , "HW PS");
					HW_PS_Param_Set[i].pPrc = &Process[PROC_HW_PS];	

					HW_PS_Param_Set[i].pCalibPoints		= &m->pCalib->Points[CALIB_HW_AMPS_CMD];
					HW_PS_Param_Set[i].rawCmdMax 		= 16383.0;
					HW_PS_Param_Set[i].AmpCMD_Max 		= 160.0;
											
				
				break;	

			}	
							
		}	

		for(i=0 ; i < 2; i++){

			switch(i){

				case 0:

					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
					strcpy(VectorStateMach[VECT_WF].Name ,"WrFeed#1");
					strcpy(VectorStateMach[VECT_WF_1].Name ,"WrFeed#2");


					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_FEED];
					WIRE_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];
					WIRE_Param_Set[i].VectStateNum = 1;
					WIRE_Param_Set[i].Mode = 0;  // classic

					
					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WF_SPEED_CMD];

								
				break;	

				case 1: 
					
					strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
					strcpy(VectorStateMach[VECT_WP].Name ,"WrPulse#1");
					strcpy(VectorStateMach[VECT_WP_1].Name ,"WrPulse#2");
								
					
					WIRE_Param_Set[i].pPrc = &Process[PROC_WIRE_PULSE];
					WIRE_Param_Set[i].pVect = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];
					WIRE_Param_Set[i].VectStateNum = 1;


					WIRE_Param_Set[i].pCalibPoints	= &m->pCalib->Points[CALIB_WP_SPEED_CMD];
								
								
				break;	


		}

		}

		

		for(i=0 ; i < 1; i++){

			switch(i){

				case 0: 

					strcpy(Process[PROC_TVL].Name , "TVL");
					strcpy(VectorStateMach[VECT_TVL].Name , "TVL");
					

					TVL_ROT_Param_Set[i].pPrc = &Process[PROC_TVL];
					TVL_ROT_Param_Set[i].pVect = &VectorStateMach[VECT_TVL];
					TVL_ROT_Param_Set[i].VectStateNum = 1;	

					TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Volt;
					//TVL_ROT_Param_Set[i].VectModeForJog = vectSt_Mode_Vel;

					TVL_ROT_Param_Set[i].MaxSpeedJog = 24.0;				

					TVL_ROT_Param_Set[i].TotalRescaleFactor = 1.0;
					TVL_ROT_Param_Set[i].pCalibPoints = &m->pCalib->Points[CALIB_TVL_SPEED_CMD];

					TVL_ROT_Param_Set[i].pTrackDia = &curCfg->Param[parTVL_TrackDia].val[0];
					TVL_ROT_Param_Set[i].pVelTolerance = &curCfg->Param[parTVL_SpeedTolerane].val[0];

					TVL_ROT_Param_Set[i].pEncoder = &AxisCh[TML_AX_TVL].curPos;
					TVL_ROT_Param_Set[i].pHomePos = &OLD_MTR_POS[TVL_ENC_HOME];
					TVL_ROT_Param_Set[i].EncPerTick = m->pCfg->HeadCfg.TVL.EncPerTick; 
					TVL_ROT_Param_Set[i].EncDir = m->pCfg->HeadCfg.TVL.Enc_Dir;
					TVL_ROT_Param_Set[i].TicksAtHighVel = 3;

							
			
				break;


			}		
		}

		for(i=0 ; i < 1 ; i++){

			switch(i){

				case 0: 

					strcpy(Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Name , "INDX");
					INDEX_Param_Set[i].pPrc = &Process[m->pCfg->HeadCfg.INDX.PROC_Indx];
					Process[m->pCfg->HeadCfg.INDX.PROC_Indx].Disable = 1;
					
				break;	

			}			
				
		}		
				
	return 1;
	
}



DINT Configure_OMEGA_16INCH_HP_ENCODER(MASTER_typ *m  , UINT headType ){

}

/////////////////////////////////////////////////////////////

void ParametrAssignToPointers(MASTER_typ *m  , UINT indx){
int i;
CurCfg_typ *c; 
Cfg_typ *cfg; 
CurCalib_typ *calib;
DINT headType;

	if(!m)
		return;

	if(!m->pCurCfg)
		return;
	
	if(!m->pCalib)
		return;

	if(!m->pCalib->GenSetup)
		return;

	if(!m->pCfg)
		return;

	cfg = m->pCfg;

	c = m->pCurCfg;

	 headType = m->pCalib->GenSetup[SETUP_HEAD_SETUP];
	
	for(i=0 ; i < 1; i++){

		switch(i){

			case 0: 
				
				//strcpy(Process[PROC_TIG_PS].Name , "TIG PS");
								
				if(c->Param[parTIG_StartDly].segmYes)	
						PS_Param_Set[i].pStartDly		= &c->Param[parTIG_StartDly].val[indx];
				else 	PS_Param_Set[i].pStartDly		= &c->Param[parTIG_StartDly].val[0];				

				if(c->Param[parTIG_StopDly].segmYes)
						PS_Param_Set[i].pStopDly		= &c->Param[parTIG_StopDly].val[indx];
				else		PS_Param_Set[i].pStopDly		= &c->Param[parTIG_StopDly].val[0];
				

				if(c->Param[parTIG_RampUp].segmYes)
						PS_Param_Set[i].pRampUp			= &c->Param[parTIG_RampUp].val[indx];
				else		PS_Param_Set[i].pRampUp			= &c->Param[parTIG_RampUp].val[0];


				if(c->Param[parTIG_RampDwn].segmYes)
						PS_Param_Set[i].pRampDwn		= &c->Param[parTIG_RampDwn].val[indx];
				else	PS_Param_Set[i].pRampDwn		= &c->Param[parTIG_RampDwn].val[0];
				
				
				if(c->Param[parTIG_AmpSP].segmYes)
						PS_Param_Set[i].pAmpSP			= &c->Param[parTIG_AmpSP].val[indx];
				else	PS_Param_Set[i].pAmpSP			= &c->Param[parTIG_AmpSP].val[0];

				if(c->Param[parTIG_AmpInSP].segmYes)
						PS_Param_Set[i].pAmpInSP		= &c->Param[parTIG_AmpInSP].val[indx];
				else	PS_Param_Set[i].pAmpInSP		= &c->Param[parTIG_AmpInSP].val[0];


				if(c->Param[parTIG_AmpOutSP].segmYes)
						PS_Param_Set[i].pAmpOutSP		= &c->Param[parTIG_AmpOutSP].val[indx];
				else	PS_Param_Set[i].pAmpOutSP		= &c->Param[parTIG_AmpOutSP].val[0];

				
				if(c->Param[parTIG_BackAmp].segmYes)
						PS_Param_Set[i].pBackAmp		= &c->Param[parTIG_BackAmp].val[indx];
				else		PS_Param_Set[i].pBackAmp 		= &c->Param[parTIG_BackAmp].val[0];


				if(c->Param[parTIG_StartAmp].segmYes)
						PS_Param_Set[i].pStartAmp		= &c->Param[parTIG_StartAmp].val[indx];	
				else		PS_Param_Set[i].pStartAmp		= &c->Param[parTIG_StartAmp].val[0];	

				if(c->Param[parTIG_EndAmp].segmYes)
						PS_Param_Set[i].pEndAmp			= &c->Param[parTIG_EndAmp].val[indx];
				else		PS_Param_Set[i].pEndAmp			= &c->Param[parTIG_EndAmp].val[0];

				
					
				if(c->Param[parTIG_AmpSP_Boost].segmYes)
						PS_Param_Set[i].pAmpBoost 		= &c->Param[parTIG_AmpSP_Boost].val[indx];
				else	PS_Param_Set[i].pAmpBoost 			= &c->Param[parTIG_AmpSP_Boost].val[0];


				if(c->Param_ENUM[parENUM_TIG_Mode].segmYes)
						PS_Param_Set[i].pMode			= &c->Param_ENUM[parENUM_TIG_Mode].val[indx];	
				else 	PS_Param_Set[i].pMode			= &c->Param_ENUM[parENUM_TIG_Mode].val[0];


				if(c->Param[parTIG_PulseFreq].segmYes)
						PS_Param_Set[i].pPulseFreq 		= &c->Param[parTIG_PulseFreq].val[indx];
				else		PS_Param_Set[i].pPulseFreq 		= &c->Param[parTIG_PulseFreq].val[0];

				if(c->Param[parTIG_PulseWidth].segmYes)
						PS_Param_Set[i].pPulseWidth 		= &c->Param[parTIG_PulseWidth].val[indx];
				else		PS_Param_Set[i].pPulseWidth 		= &c->Param[parTIG_PulseWidth].val[0];

				
				if(c->Param[parTIG_Boost1].segmYes)
						PS_Param_Set[i].pBoost1 		= &c->Param[parTIG_Boost1].val[indx];
				else	PS_Param_Set[i].pBoost1 		= &c->Param[parTIG_Boost1].val[0];


				if(c->Param[parTIG_Boost2].segmYes)
						PS_Param_Set[i].pBoost2 		= &c->Param[parTIG_Boost2].val[indx];
				else	PS_Param_Set[i].pBoost2 		= &c->Param[parTIG_Boost2].val[0];


				
				if(c->Param[parCONTIN_TIG_RampDwn].segmYes)
						PS_Param_Set[i].pContin_RampDwn 		= &c->Param[parCONTIN_TIG_RampDwn].val[indx];
				else	PS_Param_Set[i].pContin_RampDwn 		= &c->Param[parCONTIN_TIG_RampDwn].val[0];

				
				if(c->Param[parCONTIN_TIG_RampUp].segmYes)
						PS_Param_Set[i].pContin_RampUp 		= &c->Param[parCONTIN_TIG_RampUp].val[indx];
				else	PS_Param_Set[i].pContin_RampUp 		= &c->Param[parCONTIN_TIG_RampUp].val[0];


				if(c->Param[parCONTIN_TIG_Dwell].segmYes)
						PS_Param_Set[i].pContin_Dwell 		= &c->Param[parCONTIN_TIG_Dwell].val[indx];
				else	PS_Param_Set[i].pContin_Dwell 		= &c->Param[parCONTIN_TIG_Dwell].val[0];

				
				if(c->Param[parCONTIN_TIG_Percent].segmYes)
						PS_Param_Set[i].pContin_Amp_Reduce 		= &c->Param[parCONTIN_TIG_Percent].val[indx];
				else	PS_Param_Set[i].pContin_Amp_Reduce 		= &c->Param[parCONTIN_TIG_Percent].val[0];

				

			break;	

		}

	}


	for(i=0 ; i < 1 ; i++){

		switch(i){

			case 0: 

				strcpy(Process[PROC_AVC].Name , "AVC");
					

				if(c->Param[parAVC_TouchVolt].segmYes)
						AVC_Param_Set[i].pTouchVolt 		= &c->Param[parAVC_TouchVolt].val[indx];
				else 	AVC_Param_Set[i].pTouchVolt 		= &c->Param[parAVC_TouchVolt].val[0];

				if(c->Param[parAVC_TouchTm].segmYes)
						AVC_Param_Set[i].pTouchTm 			= &c->Param[parAVC_TouchTm].val[indx];
				else 	AVC_Param_Set[i].pTouchTm 			= &c->Param[parAVC_TouchTm].val[0];

				if(c->Param[parAVC_TRetractTm].segmYes)
						AVC_Param_Set[i].pRetractTm 		= &c->Param[parAVC_TRetractTm].val[indx];
				else 	AVC_Param_Set[i].pRetractTm 		= &c->Param[parAVC_TRetractTm].val[0];

				if(c->Param[parAVC_TouchRepeat].segmYes)
						AVC_Param_Set[i].pTouchRepeat 		= &c->Param[parAVC_TouchRepeat].val[indx];
				else 	AVC_Param_Set[i].pTouchRepeat 		= &c->Param[parAVC_TouchRepeat].val[0];
				
				if(c->Param[parAVC_VoltSP].segmYes)
						AVC_Param_Set[i].pVoltSP 			= &c->Param[parAVC_VoltSP].val[indx];
				else 	AVC_Param_Set[i].pVoltSP 			= &c->Param[parAVC_VoltSP].val[0];

				if(c->Param[parAVC_VoltInSP].segmYes)
						AVC_Param_Set[i].pVoltInSP 			= &c->Param[parAVC_VoltInSP].val[indx];
				else 	AVC_Param_Set[i].pVoltInSP 			= &c->Param[parAVC_VoltInSP].val[0];

				if(c->Param[parAVC_VoltOutSP].segmYes)
						AVC_Param_Set[i].pVoltOutSP 		= &c->Param[parAVC_VoltOutSP].val[indx];
				else 	AVC_Param_Set[i].pVoltOutSP 		= &c->Param[parAVC_VoltOutSP].val[0];

				if(c->Param[parAVC_VoltBackSP].segmYes)
						AVC_Param_Set[i].pBkgVoltSP			= &c->Param[parAVC_VoltBackSP].val[indx];
				else 	AVC_Param_Set[i].pBkgVoltSP 		= &c->Param[parAVC_VoltBackSP].val[0];

				if(c->Param[parAVC_VSPTmOut].segmYes)
						AVC_Param_Set[i].pVoltSPTimeOut 	= &c->Param[parAVC_VSPTmOut].val[indx];
				else 	AVC_Param_Set[i].pVoltSPTimeOut 	= &c->Param[parAVC_VSPTmOut].val[0];
						
				if(c->Param[parAVC_TouchVel].segmYes)
						AVC_Param_Set[i].pTouchVel 			= &c->Param[parAVC_TouchVel].val[indx];
				else 	AVC_Param_Set[i].pTouchVel 			= &c->Param[parAVC_TouchVel].val[0];

				if(c->Param[parAVC_ToSPVel].segmYes)
						AVC_Param_Set[i].pToSPVel 			= &c->Param[parAVC_ToSPVel].val[indx];
				else 	AVC_Param_Set[i].pToSPVel 			= &c->Param[parAVC_ToSPVel].val[0];

				if(c->Param[parAVC_LU_TM].segmYes)
						AVC_Param_Set[i].pLU_Tm 			= &c->Param[parAVC_LU_TM].val[indx];
				else 	AVC_Param_Set[i].pLU_Tm 			= &c->Param[parAVC_LU_TM].val[0];

				if(c->Param[parAVC_KissTm].segmYes)
						AVC_Param_Set[i].pKiss_Tm 			= &c->Param[parAVC_KissTm].val[indx];
				else 	AVC_Param_Set[i].pKiss_Tm 			= &c->Param[parAVC_KissTm].val[0];
				
				if(c->Param[parAVC_VoltFinal].segmYes)
						AVC_Param_Set[i].pFinalVolt 		= &c->Param[parAVC_VoltFinal].val[indx];
				else 	AVC_Param_Set[i].pFinalVolt 		= &c->Param[parAVC_VoltFinal].val[0];

				if(c->Param[parAVC_DownSlope].segmYes)	
						AVC_Param_Set[i].pRampDwn 		= &c->Param[parAVC_DownSlope].val[indx];
				else 	AVC_Param_Set[i].pRampDwn 		= &c->Param[parAVC_DownSlope].val[0];

				if(c->Param[parAVC_HoldTm].segmYes)
						AVC_Param_Set[i].pHoldTm 			= &c->Param[parAVC_HoldTm].val[indx];
				else 	AVC_Param_Set[i].pHoldTm 			= &c->Param[parAVC_HoldTm].val[0];

				if(c->Param[parAVC_GoBackTm].segmYes)
						AVC_Param_Set[i].pGoBackTm 			= &c->Param[parAVC_GoBackTm].val[indx];
				else 	AVC_Param_Set[i].pGoBackTm 			= &c->Param[parAVC_GoBackTm].val[0];
				
				if(c->Param[parAVC_StartDly].segmYes)	
						AVC_Param_Set[i].pStartDly 			= &c->Param[parAVC_StartDly].val[indx];
				else 	AVC_Param_Set[i].pStartDly 			= &c->Param[parAVC_StartDly].val[0];

				if(c->Param[parAVC_StopDly].segmYes)	
						AVC_Param_Set[i].pStopDly			= &c->Param[parAVC_StopDly].val[indx];
				else 	AVC_Param_Set[i].pStopDly 			= &c->Param[parAVC_StopDly].val[0];
				


				if(c->Param[parAVC_VoltInit].segmYes)
						AVC_Param_Set[i].pVoltInit			= &c->Param[parAVC_VoltInit].val[indx];
				else 	AVC_Param_Set[i].pVoltInit 			= &c->Param[parAVC_VoltInit].val[0];


				if(c->Param[parAVC_Upslope].segmYes)
						AVC_Param_Set[i].pRampUp 			= &c->Param[parAVC_Upslope].val[indx];				
				else 	AVC_Param_Set[i].pRampUp 			= &c->Param[parAVC_Upslope].val[0];
				
				if(c->Param[parAVC_MaxVoltError].segmYes)
						AVC_Param_Set[i].pMaxVolrError 		= &c->Param[parAVC_MaxVoltError].val[indx];
				else 	AVC_Param_Set[i].pMaxVolrError 		= &c->Param[parAVC_MaxVoltError].val[0];
				
				if(c->Param[parAVC_Limits_Mask_Tm].segmYes)
						AVC_Param_Set[i].pLimitsFilterTm 	= &c->Param[parAVC_Limits_Mask_Tm].val[indx];
				else 	AVC_Param_Set[i].pLimitsFilterTm 	= &c->Param[parAVC_Limits_Mask_Tm].val[0];
				
				if(c->Param[parAVC_JogSpeedDirCntrl].segmYes)
						AVC_Param_Set[i].pJogSpeedDirCntrl	= &c->Param[parAVC_JogSpeedDirCntrl].val[indx];	
				else 	AVC_Param_Set[i].pJogSpeedDirCntrl	= &c->Param[parAVC_JogSpeedDirCntrl].val[0];

				if(c->Param[parAVC_LiftSpeedDirCntrl].segmYes)
						AVC_Param_Set[i].pLiftSpeedDirCntrl	= &c->Param[parAVC_LiftSpeedDirCntrl].val[indx];	
				else 	AVC_Param_Set[i].pLiftSpeedDirCntrl	= &c->Param[parAVC_LiftSpeedDirCntrl].val[0];				

				if(c->Param_ENUM[parENUM_AVC_Mode].segmYes)
						AVC_Param_Set[i].pMode				= &c->Param_ENUM[parENUM_AVC_Mode].val[indx];	
				else 	AVC_Param_Set[i].pMode				= &c->Param_ENUM[parENUM_AVC_Mode].val[0];

				if(c->Param[parAVC_LiftSpeedDirCntrl].segmYes)
						AVC_Param_Set[i].pJogSpeedDirCntrl	= &c->Param[parAVC_JogSpeedDirCntrl].val[indx];	
				else 	AVC_Param_Set[i].pJogSpeedDirCntrl	= &c->Param[parAVC_JogSpeedDirCntrl].val[0];

				if(c->Param[parAVC_DB_Window].segmYes)
						AVC_Param_Set[i].pBB_Window 	= &c->Param[parAVC_DB_Window].val[indx];	
				else 	AVC_Param_Set[i].pBB_Window		= &c->Param[parAVC_DB_Window].val[0];

				if(c->Param[parAVC_BB_Vel].segmYes)
						AVC_Param_Set[i].pBB_Vel		= &c->Param[parAVC_BB_Vel].val[indx];	
				else 	AVC_Param_Set[i].pBB_Vel 	= &c->Param[parAVC_BB_Vel].val[0];

				if(c->Param[parAVC_BB_Gain].segmYes)
						AVC_Param_Set[i].pBB_Gain	= &c->Param[parAVC_BB_Gain].val[indx];	
				else 	AVC_Param_Set[i].pBB_Gain 	= &c->Param[parAVC_BB_Gain].val[0];		


				if(c->Param[parAVC_BB_Integr].segmYes)
						AVC_Param_Set[i].pBB_Integr	= &c->Param[parAVC_BB_Integr].val[indx];	
				else 	AVC_Param_Set[i].pBB_Integr 	= &c->Param[parAVC_BB_Integr].val[0];		


				if(c->Param[parAVC_Boost1].segmYes)
						AVC_Param_Set[i].pBoost1	= &c->Param[parAVC_Boost1].val[indx];	
				else 	AVC_Param_Set[i].pBoost1 	= &c->Param[parAVC_Boost1].val[0];	


				if(c->Param[parAVC_Boost2].segmYes)
						AVC_Param_Set[i].pBoost2	= &c->Param[parAVC_Boost2].val[indx];	
				else 	AVC_Param_Set[i].pBoost2 	= &c->Param[parAVC_Boost2].val[0];		
				
				
				
				
			break;	

		}
	}

	for(i=0 ; i < 1 ; i++){	

		switch(i){

			case 0:

				if(c->Param[parWRST_JogSpeedDirCntrl].segmYes)
						WRST_TML_Param_Set[i].pJogSpeedDirCntrl		= &c->Param[parWRST_JogSpeedDirCntrl].val[indx];
				else 	WRST_TML_Param_Set[i].pJogSpeedDirCntrl		= &c->Param[parWRST_JogSpeedDirCntrl].val[0];

				
				if(c->Param[parTVL_POS_OFFSET].segmYes)
						WRST_TML_Param_Set[i].pTVL_Pos_Offset 	= &c->Param[parTVL_POS_OFFSET].val[indx];
				else	WRST_TML_Param_Set[i].pTVL_Pos_Offset 	= &c->Param[parTVL_POS_OFFSET].val[0];

				if(c->Param[parTVL_POS_PREDICT].segmYes)
						WRST_TML_Param_Set[i].pTVL_Pos_Predict 	= &c->Param[parTVL_POS_PREDICT].val[indx];
				else	WRST_TML_Param_Set[i].pTVL_Pos_Predict 	= &c->Param[parTVL_POS_PREDICT].val[0];

				if(c->Param[parGEN_Radius].segmYes)
						WRST_TML_Param_Set[i].pRadius		= &c->Param[parGEN_Radius].val[indx];
				else 	WRST_TML_Param_Set[i].pRadius		= &c->Param[parGEN_Radius].val[0];

				if(c->Param[parGEN_RadSpeed_Boost].segmYes)
						WRST_TML_Param_Set[i].pRadSpeed_Boost		= &c->Param[parGEN_RadSpeed_Boost].val[indx];
				else 	WRST_TML_Param_Set[i].pRadSpeed_Boost		= &c->Param[parGEN_RadSpeed_Boost].val[0];
				
				
			break;

		}
	}

	for(i=0 ; i < 1 ; i++){	


		switch(i){

			case 0: 
			
				strcpy(Process[PROC_OSC].Name , "OSC");	
				

				if(c->Param[parOSC_StartDly].segmYes)
						OSC_TML_Param_Set[i].pStartDly		= &c->Param[parOSC_StartDly].val[indx]; 
				else 	OSC_TML_Param_Set[i].pStartDly		= &c->Param[parOSC_StartDly].val[0]; 

				if(c->Param[parOSC_RampUp].segmYes)
						OSC_TML_Param_Set[i].pRampUp		= &c->Param[parOSC_RampUp].val[indx]; 
				else 	OSC_TML_Param_Set[i].pRampUp		= &c->Param[parOSC_RampUp].val[0]; 

				if(c->Param[parOSC_Amplit].segmYes)
						OSC_TML_Param_Set[i].pPrimAmpl		= &c->Param[parOSC_Amplit].val[indx]; 
				else 	OSC_TML_Param_Set[i].pPrimAmpl		= &c->Param[parOSC_Amplit].val[0]; 

				if(c->Param[parOSC_InitAmplit].segmYes)
						OSC_TML_Param_Set[i].pInitAmpl		= &c->Param[parOSC_InitAmplit].val[indx]; 
				else	OSC_TML_Param_Set[i].pInitAmpl		= &c->Param[parOSC_InitAmplit].val[0]; 

				
				if(c->Param[parOSC_FinalAmplit].segmYes)
						OSC_TML_Param_Set[i].pFinalAmpl		= &c->Param[parOSC_FinalAmplit].val[indx]; 
				else	OSC_TML_Param_Set[i].pFinalAmpl		= &c->Param[parOSC_FinalAmplit].val[0]; 
				

				if(c->Param[parOSC_StopDly].segmYes)
						OSC_TML_Param_Set[i].pStopDly		= &c->Param[parOSC_StopDly].val[indx];
				else 	OSC_TML_Param_Set[i].pStopDly		= &c->Param[parOSC_StopDly].val[0];

				if(c->Param[parOSC_RampDwn].segmYes)
						OSC_TML_Param_Set[i].pRampDwn		= &c->Param[parOSC_RampDwn].val[indx]; 
				else 	OSC_TML_Param_Set[i].pRampDwn		= &c->Param[parOSC_RampDwn].val[0]; 

				if(c->Param[parOSC_RampUpdate].segmYes)
						OSC_TML_Param_Set[i].pRampUpdate	= &c->Param[parOSC_RampUpdate].val[indx];
				else 	OSC_TML_Param_Set[i].pRampUpdate	= &c->Param[parOSC_RampUpdate].val[0];

				if(c->Param[parOSC_Excur].segmYes)
						OSC_TML_Param_Set[i].pFreq			= &c->Param[parOSC_Excur].val[indx];
				else 	OSC_TML_Param_Set[i].pFreq			= &c->Param[parOSC_Excur].val[0];



				if(cfg->HeadCfg.OSC.DwellDir > 0){

				
					if(c->Param[parOSC_Dwell_In].segmYes)
						OSC_TML_Param_Set[i].pDwell_In		= &c->Param[parOSC_Dwell_Out].val[indx];
					else	OSC_TML_Param_Set[i].pDwell_In		= &c->Param[parOSC_Dwell_Out].val[0];

					if(c->Param[parOSC_Dwell_Out].segmYes)
						OSC_TML_Param_Set[i].pDwell_Out 	= &c->Param[parOSC_Dwell_In].val[indx];
					else	OSC_TML_Param_Set[i].pDwell_Out 	= &c->Param[parOSC_Dwell_In].val[0];


				}
				else {

				
					if(c->Param[parOSC_Dwell_In].segmYes)
							OSC_TML_Param_Set[i].pDwell_In		= &c->Param[parOSC_Dwell_In].val[indx];
					else	OSC_TML_Param_Set[i].pDwell_In		= &c->Param[parOSC_Dwell_In].val[0];

					if(c->Param[parOSC_Dwell_Out].segmYes)
							OSC_TML_Param_Set[i].pDwell_Out 	= &c->Param[parOSC_Dwell_Out].val[indx];
					else	OSC_TML_Param_Set[i].pDwell_Out 	= &c->Param[parOSC_Dwell_Out].val[0];



				}

				
				
				if(c->Param_ENUM[parENUM_OSC_CAM].segmYes) 
						OSC_TML_Param_Set[i].pCamType		= &c->Param_ENUM[parENUM_OSC_CAM].val[indx];
				else 	OSC_TML_Param_Set[i].pCamType		= &c->Param_ENUM[parENUM_OSC_CAM].val[0];
				

				if(c->Param[parOSC_JogSpeed].segmYes)
						OSC_TML_Param_Set[i].pJogSpeed		= &c->Param[parOSC_JogSpeed].val[indx];
				else 	OSC_TML_Param_Set[i].pJogSpeed		= &c->Param[parOSC_JogSpeed].val[0];

				if(c->Param[parOSC_JogSpeedDirCntrl].segmYes)
						OSC_TML_Param_Set[i].pJogSpeedDirCntrl		= &c->Param[parOSC_JogSpeedDirCntrl].val[indx];
				else 	OSC_TML_Param_Set[i].pJogSpeedDirCntrl		= &c->Param[parOSC_JogSpeedDirCntrl].val[0];

				////

				if(c->Param_ENUM[parENUM_OSC_Mode].segmYes) 
						OSC_TML_Param_Set[i].pOSC_Mode		= &c->Param_ENUM[parENUM_OSC_Mode].val[indx];
				else 	OSC_TML_Param_Set[i].pOSC_Mode		= &c->Param_ENUM[parENUM_OSC_Mode].val[0];

				
				if(c->Param_ENUM[parENUM_OSC_Synch].segmYes) 
						OSC_TML_Param_Set[i].pOSC_Synch		= &c->Param_ENUM[parENUM_OSC_Synch].val[indx];
				else	OSC_TML_Param_Set[i].pOSC_Synch		= &c->Param_ENUM[parENUM_OSC_Synch].val[0];


				if(c->Param[parOSC_Indx].segmYes)
						OSC_TML_Param_Set[i].pIndexDist		= &c->Param[parOSC_Indx].val[indx];
				else	OSC_TML_Param_Set[i].pIndexDist		= &c->Param[parOSC_Indx].val[0];

				if(c->Param[parOSC_Period].segmYes)
						OSC_TML_Param_Set[i].pPeriod		= &c->Param[parOSC_Period].val[indx];
				else	OSC_TML_Param_Set[i].pPeriod		= &c->Param[parOSC_Period].val[0];

				
				if(c->Param[parOSC_Indx_Vel].segmYes)
						OSC_TML_Param_Set[i].pIndxVel		= &c->Param[parOSC_Indx_Vel].val[indx];
				else	OSC_TML_Param_Set[i].pIndxVel		= &c->Param[parOSC_Indx_Vel].val[0];

				
			
				
			break;	

		}
			
	}

	for(i=0 ; i < 1 ; i++){

		switch(i){

			case 0: 

				strcpy(Process[PROC_GAS].Name , "GAS");
		
				if(c->Param[parGAS_PrePurgeTm].segmYes)
						GAS_Param_Set[i].pStartDly		= &c->Param[parGAS_PrePurgeTm].val[indx];
				else 	GAS_Param_Set[i].pStartDly		= &c->Param[parGAS_PrePurgeTm].val[0];

				if(c->Param[parGAS_PostPurgeTm].segmYes)
						GAS_Param_Set[i].pStopDly		= &c->Param[parGAS_PostPurgeTm].val[indx];
				else 	GAS_Param_Set[i].pStopDly		= &c->Param[parGAS_PostPurgeTm].val[0];

				if(c->Param[parGAS_Tmo].segmYes)
						GAS_Param_Set[i].pTmo			= &c->Param[parGAS_Tmo].val[indx];
				else 	GAS_Param_Set[i].pTmo			= &c->Param[parGAS_Tmo].val[0];
				
								
			break;	

		}

		
			
	}

	
	for(i=0 ; i < 1 ; i++){
	
		switch(i){

			case 0: 

				strcpy(Process[PROC_INDX].Name , "INDX");
		
				if(c->Param[parINDX_StepDist].segmYes)
						INDEX_Param_Set[i].pStepDist		= &c->Param[parINDX_StepDist].val[indx];
				else	INDEX_Param_Set[i].pStepDist		= &c->Param[parINDX_StepDist].val[0];

				
				if(c->Param[parINDX_StepVel].segmYes)
						INDEX_Param_Set[i].pStepVel		= &c->Param[parINDX_StepVel].val[indx];
				else	INDEX_Param_Set[i].pStepVel		= &c->Param[parINDX_StepVel].val[0];

				
				if(c->Param[parINDX_JogSpeedDirCntrl].segmYes)
						INDEX_Param_Set[i].pJogSpeedDirCntrl = &c->Param[parINDX_JogSpeedDirCntrl].val[indx];
				else	INDEX_Param_Set[i].pJogSpeedDirCntrl = &c->Param[parINDX_JogSpeedDirCntrl].val[0];

				
				
								
			break;	

		}

			
				
	}

	for(i=0 ; i < 1; i++){

		switch(i){

			case 0: 

				strcpy(Process[PROC_COOL].Name , "COOLANT");
				
				if(c->Param[parCOOL_Tmo].segmYes)
						COOL_Param_Set[i].pTmo = &c->Param[parCOOL_Tmo].val[indx];
				else 	COOL_Param_Set[i].pTmo = &c->Param[parCOOL_Tmo].val[0]; 				
							
			break;	

		}

		
			
	}




	for(i=0 ; i < 1; i++){

		switch(i){

			case 0: 
				
				strcpy(Process[PROC_HW_PS].Name , "HW PS");
				
				if(c->Param[parHW_RampDwnDly].segmYes)
						HW_PS_Param_Set[i].pStartDly	= &c->Param[parHW_RampDwnDly].val[indx];
				else 	HW_PS_Param_Set[i].pStartDly	= &c->Param[parHW_RampDwnDly].val[0]; 

				if(c->Param[parHW_RampDwnDly].segmYes)
						HW_PS_Param_Set[i].pStopDly 	= &c->Param[parHW_RampDwnDly].val[indx];				
				else 	HW_PS_Param_Set[i].pStopDly 	= &c->Param[parHW_RampDwnDly].val[0];
				
				if(c->Param[parHW_RampUp].segmYes)
						HW_PS_Param_Set[i].pRampUp		= &c->Param[parHW_RampUp].val[indx];
				else 	HW_PS_Param_Set[i].pRampUp		= &c->Param[parHW_RampUp].val[0];

				if(c->Param[parHW_RampDwn].segmYes)
						HW_PS_Param_Set[i].pRampDwn 	= &c->Param[parHW_RampDwn].val[indx];
				else 	HW_PS_Param_Set[i].pRampDwn 	= &c->Param[parHW_RampDwn].val[0];				

				if(c->Param[parHW_StartAmp].segmYes)
						HW_PS_Param_Set[i].pStartAmp	= &c->Param[parHW_StartAmp].val[indx];	
				else 	HW_PS_Param_Set[i].pStartAmp	= &c->Param[parHW_StartAmp].val[0];

				if(c->Param[parHW_AmpSP].segmYes)
						HW_PS_Param_Set[i].pAmpSP		= &c->Param[parHW_AmpSP].val[indx];	
				else 	HW_PS_Param_Set[i].pAmpSP		= &c->Param[parHW_AmpSP].val[0];	

				if(c->Param[parHW_EndAmp].segmYes)
						HW_PS_Param_Set[i].pEndAmp		= &c->Param[parHW_EndAmp].val[indx];
				else 	HW_PS_Param_Set[i].pEndAmp		= &c->Param[parHW_EndAmp].val[0];
				
				
				if(c->Param[parHW_RampUpdate].segmYes)
						HW_PS_Param_Set[i].pRampUpdate 	= &c->Param[parHW_RampUpdate].val[indx];	
				else 	HW_PS_Param_Set[i].pRampUpdate 	= &c->Param[parHW_RampUpdate].val[0];	

				if(c->Param[parHW_VoltSP].segmYes)
						HW_PS_Param_Set[i].pVoltSP 		= &c->Param[parHW_VoltSP].val[indx];
				else 	HW_PS_Param_Set[i].pVoltSP		= &c->Param[parHW_VoltSP].val[0];
				
				if(c->Param[parHW_AmpSP_Boost].segmYes)
						HW_PS_Param_Set[i].pAmpBoost 	= &c->Param[parHW_AmpSP_Boost].val[indx];	
				else 	HW_PS_Param_Set[i].pAmpBoost 	= &c->Param[parHW_AmpSP_Boost].val[0];	
				
				
			break;	

		}	
						
	}	

	for(i=0 ; i < 2; i++){

		switch(i){

			
			case 0:					
			
				if(i == 0)
					strcpy(Process[PROC_WIRE_FEED].Name ,"WrFeed");
				else
					strcpy(Process[PROC_WIRE_FEED].Name ,"WrPulse");
				
				if(c->Param[parWF_StartDly].segmYes)
						WIRE_Param_Set[i].pStartDly		= &c->Param[parWF_StartDly].val[indx]; 			// 1
				else	WIRE_Param_Set[i].pStartDly		= &c->Param[parWF_StartDly].val[0];

				if(c->Param[parWF_SpeedSP].segmYes)
						WIRE_Param_Set[i].pSpeedSp		= &c->Param[parWF_SpeedSP].val[indx]; 			// 2
				else	WIRE_Param_Set[i].pSpeedSp		= &c->Param[parWF_SpeedSP].val[0]; 

				
				if(c->Param[parWF_SpeedInSP].segmYes)
						WIRE_Param_Set[i].pSpeedInSp		= &c->Param[parWF_SpeedInSP].val[indx]; 	// 3
				else	WIRE_Param_Set[i].pSpeedInSp		= &c->Param[parWF_SpeedInSP].val[0]; 

				
				if(c->Param[parWF_SpeedOutSP].segmYes)
						WIRE_Param_Set[i].pSpeedOutSp		= &c->Param[parWF_SpeedOutSP].val[indx]; 	// 4
				else	WIRE_Param_Set[i].pSpeedOutSp		= &c->Param[parWF_SpeedOutSP].val[0]; 

				
				if(c->Param[parWF_BkgSpeedSP].segmYes)
						WIRE_Param_Set[i].pBkgSpeedSp		= &c->Param[parWF_BkgSpeedSP].val[indx];	// 5
				else	WIRE_Param_Set[i].pBkgSpeedSp		= &c->Param[parWF_BkgSpeedSP].val[0];

				if(c->Param[parWF_SpeedInit].segmYes)
						WIRE_Param_Set[i].pSpeedInit	= &c->Param[parWF_SpeedInit].val[indx]; 		// 6			
				else	WIRE_Param_Set[i].pSpeedInit	= &c->Param[parWF_SpeedInit].val[0]; 

				if(c->Param[parWF_SpeedFinal].segmYes)
						WIRE_Param_Set[i].pSpeedFinal	= &c->Param[parWF_SpeedFinal].val[indx]; 		// 7
				else	WIRE_Param_Set[i].pSpeedFinal	= &c->Param[parWF_SpeedFinal].val[0]; 

				if(c->Param[parWF_RampUp].segmYes)
						WIRE_Param_Set[i].pRampUp		= &c->Param[parWF_RampUp].val[indx]; 			// 8
				else	WIRE_Param_Set[i].pRampUp		= &c->Param[parWF_RampUp].val[0];

				if(c->Param[parWF_StopDly].segmYes)
						WIRE_Param_Set[i].pStopDly		= &c->Param[parWF_StopDly].val[indx]; 			// 9
				else	WIRE_Param_Set[i].pStopDly		= &c->Param[parWF_StopDly].val[0];

				if(c->Param[parWF_RampDwn].segmYes)
						WIRE_Param_Set[i].pRampDwn		= &c->Param[parWF_RampDwn].val[indx];			// 10
				else	WIRE_Param_Set[i].pRampDwn		= &c->Param[parWF_RampDwn].val[0]; 

				if(c->Param[parWF_RampUpdate].segmYes)
						WIRE_Param_Set[i].pRampUpdate	= &c->Param[parWF_RampUpdate].val[indx];		// 11
				else	WIRE_Param_Set[i].pRampUpdate	= &c->Param[parWF_RampUpdate].val[0];
				
				if(c->Param[parWF_Boost1SP].segmYes)
						WIRE_Param_Set[i].pBoost1SP		= &c->Param[parWF_Boost1SP].val[indx];			// 12
				else	WIRE_Param_Set[i].pBoost1SP		= &c->Param[parWF_Boost1SP].val[0];
				
				if(c->Param[parWF_Boost2SP].segmYes)
						WIRE_Param_Set[i].pBoost2SP		= &c->Param[parWF_Boost2SP].val[indx];			// 13
				else	WIRE_Param_Set[i].pBoost2SP		= &c->Param[parWF_Boost2SP].val[0];
				
				if(c->Param[parWF_JogSpeed].segmYes)
						WIRE_Param_Set[i].pJogSpeed		= &c->Param[parWF_JogSpeed].val[indx];			// 14
				else	WIRE_Param_Set[i].pJogSpeed		= &c->Param[parWF_JogSpeed].val[0];

				if(c->Param[parWF_JogSpeedDirCntrl].segmYes)
						WIRE_Param_Set[i].pJogSpeedDirCntrl	= &c->Param[parWF_JogSpeedDirCntrl].val[indx];	// 15
				else	WIRE_Param_Set[i].pJogSpeedDirCntrl	= &c->Param[parWF_JogSpeedDirCntrl].val[0];
				

				if(c->Param[parCONTIN_WF_RampDwn].segmYes)
						WIRE_Param_Set[i].pContinRampDwn		= &c->Param[parCONTIN_WF_RampDwn].val[indx];	// 16
				else	WIRE_Param_Set[i].pContinRampDwn    	= &c->Param[parCONTIN_WF_RampDwn].val[0];

				if(c->Param[parCONTIN_WF_RampUp].segmYes)
						WIRE_Param_Set[i].pContinRampUp		= &c->Param[parCONTIN_WF_RampUp].val[indx];		// 17
				else	WIRE_Param_Set[i].pContinRampUp    	= &c->Param[parCONTIN_WF_RampUp].val[0];			
				

				//  Wire specific
				
				if(c->Param[parWF_RetractDly].segmYes)
						WIRE_Param_Set[i].pRetracDly		= &c->Param[parWF_RetractDly].val[indx];
				else	WIRE_Param_Set[i].pRetracDly		= &c->Param[parWF_RetractDly].val[0];

				if(c->Param[parWF_RetracDist].segmYes)
						WIRE_Param_Set[i].pRetracDist		= &c->Param[parWF_RetracDist].val[indx];
				else	WIRE_Param_Set[i].pRetracDist		= &c->Param[parWF_RetracDist].val[0];


				if(c->Param[parWF_RetractSpeed].segmYes)
						WIRE_Param_Set[i].pRetracSpeed		= &c->Param[parWF_RetractSpeed].val[indx];
				else	WIRE_Param_Set[i].pRetracSpeed		= &c->Param[parWF_RetractSpeed].val[0];


				if(c->Param_ENUM[parENUM_WF_AUX].segmYes) 
						WIRE_Param_Set[i].pAuxMtrMode		= &c->Param_ENUM[parENUM_WF_AUX].val[indx];
				else 	WIRE_Param_Set[i].pAuxMtrMode		= &c->Param_ENUM[parENUM_WF_AUX].val[0];
				
					
				/*
				WIRE_Param_Set[i].pRetracDly = 0;
				WIRE_Param_Set[i].pRetracDist = 0;
				WIRE_Param_Set[i].pRetracSpeed = 0;
				WIRE_Param_Set[i].pAuxMtrMode = 0;
				*/
			
				
						
			break;	
			
			
			case 1: 
				
				strcpy(Process[PROC_WIRE_PULSE].Name ,"WrPulse");
				
				if(c->Param[parWP_StartDly].segmYes)
						WIRE_Param_Set[i].pStartDly		= &c->Param[parWP_StartDly].val[indx];    		// 1
				else	WIRE_Param_Set[i].pStartDly		= &c->Param[parWP_StartDly].val[0];

				if(c->Param[parWP_SpeedSP].segmYes)
						WIRE_Param_Set[i].pSpeedSp		= &c->Param[parWP_SpeedSP].val[indx];    		// 2
				else	WIRE_Param_Set[i].pSpeedSp		= &c->Param[parWP_SpeedSP].val[0]; 


				if(c->Param[parWP_SpeedInSP].segmYes)
						WIRE_Param_Set[i].pSpeedInSp		= &c->Param[parWP_SpeedInSP].val[indx]; 	// 3
				else	WIRE_Param_Set[i].pSpeedInSp		= &c->Param[parWP_SpeedInSP].val[0]; 

				if(c->Param[parWP_SpeedOutSP].segmYes)
						WIRE_Param_Set[i].pSpeedOutSp		= &c->Param[parWP_SpeedOutSP].val[indx];   	// 4
				else	WIRE_Param_Set[i].pSpeedOutSp		= &c->Param[parWP_SpeedOutSP].val[0]; 

				
				if(c->Param[parWP_BkgSpeedSP].segmYes)
						WIRE_Param_Set[i].pBkgSpeedSp		= &c->Param[parWP_BkgSpeedSP].val[indx]; 	// 5
				else	WIRE_Param_Set[i].pBkgSpeedSp		= &c->Param[parWP_BkgSpeedSP].val[0]; 

				if(c->Param[parWP_SpeedInit].segmYes)
						WIRE_Param_Set[i].pSpeedInit	= &c->Param[parWP_SpeedInit].val[indx]; 		// 6		
				else	WIRE_Param_Set[i].pSpeedInit	= &c->Param[parWP_SpeedInit].val[0]; 

				if(c->Param[parWP_SpeedFinal].segmYes)
						WIRE_Param_Set[i].pSpeedFinal	= &c->Param[parWP_SpeedFinal].val[indx]; 		// 7
				else	WIRE_Param_Set[i].pSpeedFinal	= &c->Param[parWP_SpeedFinal].val[0]; 

				if(c->Param[parWP_RampUp].segmYes)
						WIRE_Param_Set[i].pRampUp		= &c->Param[parWP_RampUp].val[indx]; 			// 8
				else	WIRE_Param_Set[i].pRampUp		= &c->Param[parWP_RampUp].val[0];

				if(c->Param[parWP_StopDly].segmYes)
						WIRE_Param_Set[i].pStopDly		= &c->Param[parWP_StopDly].val[indx]; 			// 9
				else	WIRE_Param_Set[i].pStopDly		= &c->Param[parWP_StopDly].val[0];

				if(c->Param[parWP_RampDwn].segmYes)
						WIRE_Param_Set[i].pRampDwn		= &c->Param[parWP_RampDwn].val[indx];			// 10
				else	WIRE_Param_Set[i].pRampDwn		= &c->Param[parWP_RampDwn].val[0]; 

				if(c->Param[parWP_RampUpdate].segmYes)
						WIRE_Param_Set[i].pRampUpdate	= &c->Param[parWP_RampUpdate].val[indx];		// 11
				else	WIRE_Param_Set[i].pRampUpdate	= &c->Param[parWP_RampUpdate].val[0];
				
				if(c->Param[parWP_Boost1SP].segmYes)
						WIRE_Param_Set[i].pBoost1SP		= &c->Param[parWP_Boost1SP].val[indx];			// 12
				else	WIRE_Param_Set[i].pBoost1SP		= &c->Param[parWP_Boost1SP].val[0];
				
				if(c->Param[parWP_Boost2SP].segmYes)
						WIRE_Param_Set[i].pBoost2SP		= &c->Param[parWP_Boost2SP].val[indx];			// 13
				else	WIRE_Param_Set[i].pBoost2SP		= &c->Param[parWP_Boost2SP].val[0];
				
				if(c->Param[parWP_JogSpeed].segmYes)
						WIRE_Param_Set[i].pJogSpeed		= &c->Param[parWP_JogSpeed].val[indx];			// 14
				else	WIRE_Param_Set[i].pJogSpeed		= &c->Param[parWP_JogSpeed].val[0];

				if(c->Param[parWP_JogSpeedDirCntrl].segmYes)
						WIRE_Param_Set[i].pJogSpeedDirCntrl	= &c->Param[parWP_JogSpeedDirCntrl].val[indx];		// 15
				else	WIRE_Param_Set[i].pJogSpeedDirCntrl	= &c->Param[parWP_JogSpeedDirCntrl].val[0];

				
				if(c->Param[parCONTIN_WP_RampDwn].segmYes)
						WIRE_Param_Set[i].pContinRampDwn		= &c->Param[parCONTIN_WP_RampDwn].val[indx];	// 16
				else	WIRE_Param_Set[i].pContinRampDwn		= &c->Param[parCONTIN_WP_RampDwn].val[0];

				if(c->Param[parCONTIN_WP_RampUp].segmYes)
						WIRE_Param_Set[i].pContinRampUp 	= &c->Param[parCONTIN_WP_RampUp].val[indx];			// 17
				else	WIRE_Param_Set[i].pContinRampUp 	= &c->Param[parCONTIN_WP_RampUp].val[0];
				
							
							
			break;	
			


		}

	}
	

	for(i=0 ; i < 1; i++){

		switch(i){

			case 0: 

				strcpy(Process[PROC_TVL].Name , "TVL");
				

				if(c->Param[parTVL_InitVel].segmYes)
						TVL_ROT_Param_Set[i].pInitVel 		= &c->Param[parTVL_InitVel].val[indx]; 
				else 	TVL_ROT_Param_Set[i].pInitVel 		= &c->Param[parTVL_InitVel].val[0]; 
				
				if(c->Param[parTVL_VelSP].segmYes)
						TVL_ROT_Param_Set[i].pPrimVel		= &c->Param[parTVL_VelSP].val[indx]; 
				else	TVL_ROT_Param_Set[i].pPrimVel		= &c->Param[parTVL_VelSP].val[0]; 	


				if(c->Param[parTVL_VelInSP].segmYes)
						TVL_ROT_Param_Set[i].pPrimInVel		= &c->Param[parTVL_VelInSP].val[indx]; 
				else	TVL_ROT_Param_Set[i].pPrimInVel		= &c->Param[parTVL_VelInSP].val[0];

				if(c->Param[parTVL_VelOutSP].segmYes)
						TVL_ROT_Param_Set[i].pPrimOutVel		= &c->Param[parTVL_VelOutSP].val[indx]; 
				else	TVL_ROT_Param_Set[i].pPrimOutVel		= &c->Param[parTVL_VelOutSP].val[0];

				if(c->Param[parTVL_VelBackSP].segmYes)
						TVL_ROT_Param_Set[i].pPrimBackVel		= &c->Param[parTVL_VelBackSP].val[indx]; 
				else	TVL_ROT_Param_Set[i].pPrimBackVel		= &c->Param[parTVL_VelBackSP].val[0];

				if(c->Param[parTVL_FinalVel].segmYes)
						TVL_ROT_Param_Set[i].pFinalVel		= &c->Param[parTVL_FinalVel].val[indx]; 
				else	TVL_ROT_Param_Set[i].pFinalVel		= &c->Param[parTVL_FinalVel].val[0]; 				

				if(c->Param[parTVL_Jog2Stop].segmYes)
						TVL_ROT_Param_Set[i].pJog2Stop = &c->Param[parTVL_Jog2Stop].val[indx];
				else	TVL_ROT_Param_Set[i].pJog2Stop 		= &c->Param[parTVL_Jog2Stop].val[0];

				if(c->Param[parTVL_JogSpeedDirCntrl].segmYes)	
						TVL_ROT_Param_Set[i].pJogSpeedDirCntrl	= &c->Param[parTVL_JogSpeedDirCntrl].val[indx];
				else	TVL_ROT_Param_Set[i].pJogSpeedDirCntrl	= &c->Param[parTVL_JogSpeedDirCntrl].val[0];

				if(c->Param[parTVL_StartDly].segmYes)			
						TVL_ROT_Param_Set[i].pStartDly 		= &c->Param[parTVL_StartDly].val[indx];
				else 	TVL_ROT_Param_Set[i].pStartDly 		= &c->Param[parTVL_StartDly].val[0];
				
				if(c->Param[parTVL_RampUp].segmYes)
						TVL_ROT_Param_Set[i].pRampUp		= &c->Param[parTVL_RampUp].val[indx]; 
				else 	TVL_ROT_Param_Set[i].pRampUp		= &c->Param[parTVL_RampUp].val[0]; 

				if(c->Param[parTVL_StopDly].segmYes)
						TVL_ROT_Param_Set[i].pStopDly		= &c->Param[parTVL_StopDly].val[indx]; 
				else 	TVL_ROT_Param_Set[i].pStopDly		= &c->Param[parTVL_StopDly].val[0]; 


				if(c->Param[parTVL_RampDwn].segmYes)
						TVL_ROT_Param_Set[i].pRampDwn		= &c->Param[parTVL_RampDwn].val[indx]; 
				else 	TVL_ROT_Param_Set[i].pRampDwn		= &c->Param[parTVL_RampDwn].val[0]; 

				if(c->Param[parTVL_RampUpdate].segmYes)
						TVL_ROT_Param_Set[i].pRampUpdate	= &c->Param[parTVL_RampUpdate].val[indx];
				else 	TVL_ROT_Param_Set[i].pRampUpdate	= &c->Param[parTVL_RampUpdate].val[0];
				

				if(c->Param[parTVL_RewrapDly].segmYes)
						TVL_ROT_Param_Set[i].pRewrapDly		= &c->Param[parTVL_RewrapDly].val[indx];
				else 	TVL_ROT_Param_Set[i].pRewrapDly		= &c->Param[parTVL_RewrapDly].val[0];
				

				if(c->Param[parTVL_RewrapVel].segmYes)
						TVL_ROT_Param_Set[i].pRewrapVel		= &c->Param[parTVL_RewrapVel].val[indx];
				else 	TVL_ROT_Param_Set[i].pRewrapVel		= &c->Param[parTVL_RewrapVel].val[0];


				if(c->Param[parTVL_Boost1].segmYes)
						TVL_ROT_Param_Set[i].pBoost1		= &c->Param[parTVL_Boost1].val[indx];
				else 	TVL_ROT_Param_Set[i].pBoost1		= &c->Param[parTVL_Boost1].val[0];

				
				if(c->Param[parTVL_Boost2].segmYes)
						TVL_ROT_Param_Set[i].pBoost2		= &c->Param[parTVL_Boost2].val[indx];
				else	TVL_ROT_Param_Set[i].pBoost2		= &c->Param[parTVL_Boost2].val[0];


				if(c->Param[parCONTIN_TVL_RampDwn].segmYes)
						TVL_ROT_Param_Set[i].pContinRampDwn		= &c->Param[parCONTIN_TVL_RampDwn].val[indx];
				else	TVL_ROT_Param_Set[i].pContinRampDwn		= &c->Param[parCONTIN_TVL_RampDwn].val[0];


				if(c->Param[parCONTIN_TVL_RampUp].segmYes)
						TVL_ROT_Param_Set[i].pContinRampUp		= &c->Param[parCONTIN_TVL_RampUp].val[indx];
				else	TVL_ROT_Param_Set[i].pContinRampUp		= &c->Param[parCONTIN_TVL_RampUp].val[0];

					
			
			break;


		}


		
	}


}

DINT NextDivider(DINT *in , DINT mod , BOOL dir){
DINT x , base;

/*
return :

-1 ->  wrong module
0 -> not exists counting up
1 -> not exist counting down
2 -> OK found

*/

	x = *in;
	base = *in;
	
	if(mod < 1){
		*in = 1;
		return -1;

	}	
	
	if(dir){
		
		do{

			x++;

			if(x > mod){
		
				*in = mod;
				return 0;

			}
				
		}while( remainderf ((float)mod,(float)x));

	}
	else{
		
		do{
			x--;

			if(x < 1){
				*in = 1;
				return 1;

			}	
		
		}while( remainderf ((float)mod,(float)x));
	}		

	*in = x;
	return 2;

}

DINT PickPinsNo(DINT *indx , DINT mod  ){
int i;
DINT x , ret;

	x = 1;

	if(mod < 1)
		return -100;

	if(*indx >= 0){

				

		for(i = 0 ; i < *indx ; i++){
		
			if( NextDivider(&x , mod , 1)== 0 ){

				ret = mod/x;
				*indx = i;
				return ret;// max indx

			}

		}

	}
	else{
	
		ret = mod;
		*indx = 0;
		return ret; // min indx
		

	}
		
	ret = mod/x;
	return ret;	
	
}

void PleaseUpdateHeadSetup(MASTER_typ *m ){
DINT x , k;

CurCalib_typ *curCalib ;
CurCfg_typ *curCfg;

INT pinsPerZone;


	if(!m)
		return;


	curCalib = m->pCalib;	
	curCfg	 = m->pCurCfg;

	if(!curCalib || !curCfg)
		return;


	
	if(curCalib->GenSetup[SETUP_PIN_PER_ROT]< 1)
		curCalib->GenSetup[SETUP_PIN_PER_ROT] = 1;

	////////////////////////////////////////////////////////////
	//  Calculate number of Segment and Zone 
	curCalib->GenSetup[SETUP_SEGM_NO] = curCalib->GenSetup[SETUP_PIN_PER_ROT] ;
	m->ticksPerSegm = 1;	
	m->numSegm = curCalib->GenSetup[SETUP_PIN_PER_ROT] / m->ticksPerSegm;
		
		
	if(curCfg->Param_INT[parINT_NumZone].val[0]> 32.0)
		curCfg->Param_INT[parINT_NumZone].val[0] = 32.0;
	
	if(curCfg->Param_INT[parINT_NumZone].val[0]> (float)curCalib->GenSetup[SETUP_PIN_PER_ROT])
		curCfg->Param_INT[parINT_NumZone].val[0] = (float)curCalib->GenSetup[SETUP_PIN_PER_ROT];

	
	if(curCfg->Param_INT[parINT_NumZone].val[0]< 1.0)
		curCfg->Param_INT[parINT_NumZone].val[0] = 1.0;

	
	m->numZone = (INT)(curCfg->Param_INT[parINT_NumZone].val[0]); 	

	/////////////////////////////////////////////////////////////////////////
	if((curCalib->GenSetup[SETUP_MAPPING_ON]&MAPPING_SEGM))
		m->numZone = curCalib->GenSetup[SETUP_POLE_ELEMENTS] * 2;

	///////////////////////////////////////////////////////////////////////

		
}

DINT  DefaultCalibr_BPV_FACE_OSC(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391; 		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578; 		// 12 V
		defCalib->Points[i].val[3] = 4.45922852; 		// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		/*
		defCalib->Points[i].val[0] = 36.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		*/
		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT  DefaultCalibr_BPV_v2_MT(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.377; 	// 0 V			
		defCalib->Points[i].val[1] = 1.667; 	// 6 V		
		defCalib->Points[i].val[2] = 3.08; 		// 12 V
		defCalib->Points[i].val[3] = 4.477; 	// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 

		i=CALIB_INDX_CMD;	
		defCalib->Points[i].num = 4;
			
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 8;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}
DINT  DefaultCalibr_BPV_v2(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.377; 	// 0 V			
		defCalib->Points[i].val[1] = 1.667; 	// 6 V		
		defCalib->Points[i].val[2] = 3.08; 		// 12 V
		defCalib->Points[i].val[3] = 4.477; 	// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 

		i=CALIB_INDX_CMD;	
		defCalib->Points[i].num = 4;
			
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 8;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT  DefaultCalibr_MIG_TIG(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.377; 	// 0 V			
		defCalib->Points[i].val[1] = 1.667; 	// 6 V		
		defCalib->Points[i].val[2] = 3.08; 		// 12 V
		defCalib->Points[i].val[3] = 4.477; 	// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 

		i=CALIB_INDX_CMD;	
		defCalib->Points[i].num = 4;
			
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 8;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}
///////////////////////////////////////////////////////////////

DINT  DefaultCalibr_BPV_v2_MT_BO(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.377; 	// 0 V			
		defCalib->Points[i].val[1] = 1.667; 	// 6 V		
		defCalib->Points[i].val[2] = 3.08; 		// 12 V
		defCalib->Points[i].val[3] = 4.477; 	// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 

		i=CALIB_INDX_CMD;	
		defCalib->Points[i].num = 4;
			
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 8;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}


DINT  DefaultCalibr_BPV_v2_TT_BO(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.377; 	// 0 V			
		defCalib->Points[i].val[1] = 1.667; 	// 6 V		
		defCalib->Points[i].val[2] = 3.08; 		// 12 V
		defCalib->Points[i].val[3] = 4.477; 	// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 

		i=CALIB_INDX_CMD;	
		defCalib->Points[i].num = 4;
			
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 8;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}
DINT  DefaultCalibr_BPV_v2_MT_BO_TOS(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.377; 	// 0 V			
		defCalib->Points[i].val[1] = 1.667; 	// 6 V		
		defCalib->Points[i].val[2] = 3.08; 		// 12 V
		defCalib->Points[i].val[3] = 4.477; 	// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 

		i=CALIB_INDX_CMD;	
		defCalib->Points[i].num = 4;
			
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 8;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}
DINT  DefaultCalibr_BPV_v2_TT_BO_TOS(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.377; 	// 0 V			
		defCalib->Points[i].val[1] = 1.667; 	// 6 V		
		defCalib->Points[i].val[2] = 3.08; 		// 12 V
		defCalib->Points[i].val[3] = 4.477; 	// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 

		i=CALIB_INDX_CMD;	
		defCalib->Points[i].num = 4;
			
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 8;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT  DefaultCalibr_BPV_v2_MPBO(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.377; 	// 0 V			
		defCalib->Points[i].val[1] = 1.667; 	// 6 V		
		defCalib->Points[i].val[2] = 3.08; 		// 12 V
		defCalib->Points[i].val[3] = 4.477; 	// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 

		i=CALIB_INDX_CMD;	
		defCalib->Points[i].num = 4;
			
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 8;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT  DefaultCalibr_BPV_v2_MPGH(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.377; 	// 0 V			
		defCalib->Points[i].val[1] = 1.667; 	// 6 V		
		defCalib->Points[i].val[2] = 3.08; 		// 12 V
		defCalib->Points[i].val[3] = 4.477; 	// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 

		i=CALIB_INDX_CMD;	
		defCalib->Points[i].num = 4;
			
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 8;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT  DefaultCalibr_BPV_v2_MPGV(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.377; 	// 0 V			
		defCalib->Points[i].val[1] = 1.667; 	// 6 V		
		defCalib->Points[i].val[2] = 3.08; 		// 12 V
		defCalib->Points[i].val[3] = 4.477; 	// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 

		i=CALIB_INDX_CMD;	
		defCalib->Points[i].num = 4;
			
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 8;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}



///////////////////////////////////////////////////////////////
DINT  DefaultCalibr_SUPER_MINI(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391; 		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578; 		// 12 V
		defCalib->Points[i].val[3] = 4.45922852; 		// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		/*
		defCalib->Points[i].val[0] = 36.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		*/
		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT DefaultCalibr_CLAMSHELL_HEAD(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391; 		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578; 		// 12 V
		defCalib->Points[i].val[3] = 4.45922852; 		// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		/*
		defCalib->Points[i].val[0] = 36.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		*/
		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}
DINT DefaultCalibr_CHERRYPOINT_BPV2_HEAD(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391; 		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578; 		// 12 V
		defCalib->Points[i].val[3] = 4.45922852; 		// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		/*
		defCalib->Points[i].val[0] = 36.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		*/
		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT DefaultCalibr_CHERRYPOINT_BPV1_HEAD(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391; 		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578; 		// 12 V
		defCalib->Points[i].val[3] = 4.45922852; 		// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		/*
		defCalib->Points[i].val[0] = 36.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		*/
		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT  DefaultCalibr_BPV_F_HEAD(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391; 		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578; 		// 12 V
		defCalib->Points[i].val[3] = 4.45922852; 		// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		/*
		defCalib->Points[i].val[0] = 36.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		*/
		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT  DefaultCalibr_BPV_V1_MT(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391; 		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578; 		// 12 V
		defCalib->Points[i].val[3] = 4.45922852; 		// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		/*
		defCalib->Points[i].val[0] = 36.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		*/
		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT  DefaultCalibr_M_94(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = -1.0e+23; 					
		defCalib->Points[i].val[1] = 1.0e+23;  
		defCalib->Points[i].val[2] = -1.0e+23; 					
		defCalib->Points[i].val[3] = 1.0e+23;   	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 0.0; 	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391; 		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578; 		// 12 V
		defCalib->Points[i].val[3] = 4.45922852; 		// 18 V			


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;

		/*
		defCalib->Points[i].val[0] = 36.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		*/
		
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 80.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
			
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}
DINT  DefaultCalibr_F_HEAD_MINI_STND(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;

		defCalib->Points[i].val[0] = 0.0; 					
		defCalib->Points[i].val[1] = 80.0;  
		defCalib->Points[i].val[2] = 0.0; 					
		defCalib->Points[i].val[3] = 80.0;  	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
				
		defCalib->Points[i].val[0] = 0.0;	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391;		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578;		// 12 V
		defCalib->Points[i].val[3] = 4.45922852;		// 18 V 		


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 38.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		
		/*
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 160.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 160.0; // Y2 
		*/		
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}


DINT  DefaultCalibr_D_HEAD_HP(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;

		defCalib->Points[i].val[0] = 0.0; 					
		defCalib->Points[i].val[1] = 80.0;  
		defCalib->Points[i].val[2] = 0.0; 					
		defCalib->Points[i].val[3] = 80.0;  	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
				
		defCalib->Points[i].val[0] = 0.0;	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391;		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578;		// 12 V
		defCalib->Points[i].val[3] = 4.45922852;		// 18 V 		


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 38.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		
		/*
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 160.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 160.0; // Y2 
		*/		
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT  DefaultCalibr_F_HEAD_MINI_OMEGA(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;

		defCalib->Points[i].val[0] = 0.0; 					
		defCalib->Points[i].val[1] = 80.0;  
		defCalib->Points[i].val[2] = 0.0; 					
		defCalib->Points[i].val[3] = 80.0;  	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
				
		defCalib->Points[i].val[0] = 0.0;	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391;		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578;		// 12 V
		defCalib->Points[i].val[3] = 4.45922852;		// 18 V 		


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 38.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		
		/*
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 160.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 160.0; // Y2 
		*/		
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT  DefaultCalibr_RUBIX(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;

		defCalib->Points[i].val[0] = 0.0; 					
		defCalib->Points[i].val[1] = 80.0;  
		defCalib->Points[i].val[2] = 0.0; 					
		defCalib->Points[i].val[3] = 80.0;  	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
				
		defCalib->Points[i].val[0] = 0.0;	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391;		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578;		// 12 V
		defCalib->Points[i].val[3] = 4.45922852;		// 18 V 		


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 38.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		
		/*
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 160.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 160.0; // Y2 
		*/		
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}


DINT  DefaultCalibr_F_HEAD_HP_MINI_ENC(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;

		defCalib->Points[i].val[0] = 0.0; 					
		defCalib->Points[i].val[1] = 80.0;  
		defCalib->Points[i].val[2] = 0.0; 					
		defCalib->Points[i].val[3] = 80.0;  	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
				
		defCalib->Points[i].val[0] = 0.0;	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391;		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578;		// 12 V
		defCalib->Points[i].val[3] = 4.45922852;		// 18 V 		


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 38.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		
		/*
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 160.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 160.0; // Y2 
		*/		
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT  DefaultCalibr_F_HEAD_HP_ENC_BEMF(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;

		defCalib->Points[i].val[0] = 0.0; 					
		defCalib->Points[i].val[1] = 80.0;  
		defCalib->Points[i].val[2] = 0.0; 					
		defCalib->Points[i].val[3] = 80.0;  	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
				
		defCalib->Points[i].val[0] = 0.0;	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391;		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578;		// 12 V
		defCalib->Points[i].val[3] = 4.45922852;		// 18 V 		
		
		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 38.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		
		/*
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 160.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 160.0; // Y2 
		*/		
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT  DefaultCalibr_F_HEAD_HP_ENCODER(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;

		defCalib->Points[i].val[0] = 0.0; 					
		defCalib->Points[i].val[1] = 80.0;  
		defCalib->Points[i].val[2] = 0.0; 					
		defCalib->Points[i].val[3] = 80.0;  	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
				
		defCalib->Points[i].val[0] = 0.0;	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391;		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578;		// 12 V
		defCalib->Points[i].val[3] = 4.45922852;		// 18 V 		
		
		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s

		/*
		// Going Up
		defCalib->Points[i].val[0] = 0.846663; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 1.212983; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.1166663; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 2.621189; 	// Y2 pos	

		// Going Down
		defCalib->Points[i].val[4] = 0.846663;		// X1 neg	
		defCalib->Points[i].val[5] = 1.212983;		// Y1 neg	
		defCalib->Points[i].val[6] = 2.1166663;	// X2 neg	
		defCalib->Points[i].val[7] = 2.621189;	// Y2 neg	
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 38.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		
		/*
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 160.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 160.0; // Y2 
		*/		
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}


DINT  DefaultCalibr_OMEGA_16INCH_HP_ENCODER(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 42.0; 					
		defCalib->Points[i].val[1] = 8.0;  
		defCalib->Points[i].val[2] = 42.0; 					
		defCalib->Points[i].val[3] = 8.0;  	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
				
		defCalib->Points[i].val[0] = 0.0;	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391;		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578;		// 12 V
		defCalib->Points[i].val[3] = 4.45922852;		// 18 V 		
		


		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH
		defCalib->Points[i].val[0] = 1.297357; 	// X1 pos	
		defCalib->Points[i].val[1] = 0.7805365; 		// Y1 pos	
		defCalib->Points[i].val[2] = 2.917188; 	// X2 pos	
		defCalib->Points[i].val[3] = 1.59265; 		// Y2 pos	
		
		defCalib->Points[i].val[4] = 1.331588;	// X1 neg	
		defCalib->Points[i].val[5] = 0.7805365;	// Y1 neg	
		defCalib->Points[i].val[6] = 2.934148;	// X2 neg	
		defCalib->Points[i].val[7] = 1.59265;		// Y2 neg	
		
			
		/*
		// OMEGA 16 INCH
		// 1.9063= 20.969 / 11.0  (frame/pipe)
		// 0.5246 = 11.0/20.969
		defCalib->Points[i].val[0] = 1.666591 * 1.9063;	// X1 pos	
		defCalib->Points[i].val[1] = 2.0;		// Y1 pos	
		defCalib->Points[i].val[2] = 3.307278 * 1.9063;	// X2 pos	
		defCalib->Points[i].val[3] = 4.0;		// Y2 pos	
		
		defCalib->Points[i].val[4] = 1.677865 * 1.9063;	// X1 neg	
		defCalib->Points[i].val[5] = 2.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 3.374775 * 1.9063;	// X2 neg	
		defCalib->Points[i].val[7] = 4.0;		// Y2 neg	
		defCalib->Points[i].num = 8;
		*/

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 38.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		
		/*
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 160.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 160.0; // Y2 
		*/		
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}
DINT  DefaultCalibr_U_BEND_HP_ENC(CurCalib_typ* defCalib)
{
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;

		defCalib->Points[i].val[0] = 0.0; 					
		defCalib->Points[i].val[1] = 80.0;  
		defCalib->Points[i].val[2] = 0.0; 					
		defCalib->Points[i].val[3] = 80.0;  	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
				
		defCalib->Points[i].val[0] = 0.0;	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391;		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578;		// 12 V
		defCalib->Points[i].val[3] = 4.45922852;		// 18 V 
		
		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 38.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		
		/*
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 160.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 160.0; // Y2 
		*/		
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

DINT  DefaultCalibr_U_BEND_HP_ENC_BEMF(CurCalib_typ* defCalib)
{
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].num = 4;

		defCalib->Points[i].val[0] = 0.0; 					
		defCalib->Points[i].val[1] = 80.0;  
		defCalib->Points[i].val[2] = 0.0; 					
		defCalib->Points[i].val[3] = 80.0;  	
		

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].num = 4;
				
		defCalib->Points[i].val[0] = 0.0;	// 0 V			
		defCalib->Points[i].val[1] = 1.44775391;		// 6 V		
		defCalib->Points[i].val[2] = 2.96142578;		// 12 V
		defCalib->Points[i].val[3] = 4.45922852;		// 18 V 
		
		i = CALIB_TVL_SPEED_CMD;
		defCalib->Points[i].num = 8;
		
		// OMEGA 16 INCH  // 1"/min = 0.423 mm/s
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 pos	 at 2"/min
		defCalib->Points[i].val[1] = 0.0; 	// Y1 pos	
		defCalib->Points[i].val[2] = 10.0; 	// X2 pos	at 5"/min
		defCalib->Points[i].val[3] = 10.0; 	// Y2 pos	

		defCalib->Points[i].val[4] = 0.0;		// X1 neg	
		defCalib->Points[i].val[5] = 0.0;		// Y1 neg	
		defCalib->Points[i].val[6] = 10.0;	// X2 neg	
		defCalib->Points[i].val[7] = 10.0;	// Y2 neg	
		

		i = CALIB_WF_SPEED_CMD;
		defCalib->Points[i].num = 8;

		/*
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
	
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].num = 8;
		
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		
	
		i=CALIB_TIG_AMPS_CMD;	
		defCalib->Points[i].num = 4;
		/*
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		*/
		
		defCalib->Points[i].val[0] = 0.0; 	// X1 
		defCalib->Points[i].val[1] = 0.0; 	// Y1 
		defCalib->Points[i].val[2] = 500.0; // X2  
		defCalib->Points[i].val[3] = 500.0; // Y2 
		
		
	
		i=CALIB_HW_AMPS_CMD;
		defCalib->Points[i].num = 4;
		
		defCalib->Points[i].val[0] = 38.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		
		/*
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 160.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 160.0; // Y2 
		*/		
		
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}

#if 0

Old U bend calibration
{
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].val[0] = 55.0; 					
		defCalib->Points[i].val[1] = 2.0;  
		defCalib->Points[i].val[2] = 55.0; 					
		defCalib->Points[i].val[3] = 2.0;  
		defCalib->Points[i].num = 4;

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].val[0] = 0.113551; 	// 0 V					
		defCalib->Points[i].val[1] = 0.5213675; // 2 V	
		defCalib->Points[i].val[2] = 1.230769;  // 4 V		
		defCalib->Points[i].val[3] = 1.3235606; // 6 V	
		defCalib->Points[i].val[4] = 1.73138; 	// 8 V	
		defCalib->Points[i].val[5] = 2.125763; 	// 10 V	
		defCalib->Points[i].val[6] = 2.533577; 	// 12 V
		defCalib->Points[i].val[7] = 2.932845; 	// 14 V	
		defCalib->Points[i].val[8] = 3.327228; 	// 16 V
		defCalib->Points[i].val[9] = 3.720391; 	// 18 V	
		defCalib->Points[i].num = 10;


		i = CALIB_TVL_SPEED_CMD;	

		//* UBEND
		defCalib->Points[i].val[0] = 1.232002; 	// X1 pos	
		defCalib->Points[i].val[1] = 2.319729; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.492902; 	// X2 pos	
		defCalib->Points[i].val[3] = 3.810391; 	// Y2 pos	
		
		defCalib->Points[i].val[4] = 1.513998;	// X1 neg	
		defCalib->Points[i].val[5] = 2.319729;	// Y1 neg	
		defCalib->Points[i].val[6] = 2.77144;	// X2 neg	
		defCalib->Points[i].val[7] = 3.810391;	// Y2 neg
		defCalib->Points[i].num = 8;
			

		i = CALIB_WF_SPEED_CMD;	
		
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		/*
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		*/	
		
		defCalib->Points[i].num = 8;

		
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		defCalib->Points[i].num = 8;
	
		i=CALIB_TIG_AMPS_CMD;
		
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  - 345 amp max
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		
		/*
		defCalib->Points[i].val[0] = 0; 	// X1 
		defCalib->Points[i].val[1] = 0; 	// Y1 
		defCalib->Points[i].val[2] = 100; // X2  - 345 amp max
		defCalib->Points[i].val[3] = 100; // Y2 
		defCalib->Points[i].num = 4;
		*/
	
		i=CALIB_HW_AMPS_CMD;
	
		
		defCalib->Points[i].val[0] = 38.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		
		/*
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 160.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 160.0; // Y2 
		*/		
		defCalib->Points[i].num = 4;
	
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}
#endif

DINT  DefaultCalibr_U_BEND_HP_PINS(CurCalib_typ* defCalib){
UINT i;

		if(!defCalib)
			return 0;
	
		//////////////////////////////////////////////////////// 
		////   Default CALIBRATION


		i = CALIB_OSC_SFT_LIMIT;	
		defCalib->Points[i].val[0] = 55.0; 					
		defCalib->Points[i].val[1] = 2.0;  
		defCalib->Points[i].val[2] = 55.0; 					
		defCalib->Points[i].val[3] = 2.0;  
		defCalib->Points[i].num = 4;

		i = CALIB_TIG_VOLT_FBK;	
		defCalib->Points[i].val[0] = 0.113551; 	// 0 V					
		defCalib->Points[i].val[1] = 0.5213675; // 2 V	
		defCalib->Points[i].val[2] = 1.230769;  // 4 V		
		defCalib->Points[i].val[3] = 1.3235606; // 6 V	
		defCalib->Points[i].val[4] = 1.73138; 	// 8 V	
		defCalib->Points[i].val[5] = 2.125763; 	// 10 V	
		defCalib->Points[i].val[6] = 2.533577; 	// 12 V
		defCalib->Points[i].val[7] = 2.932845; 	// 14 V	
		defCalib->Points[i].val[8] = 3.327228; 	// 16 V
		defCalib->Points[i].val[9] = 3.720391; 	// 18 V	
		defCalib->Points[i].num = 10;


		i = CALIB_TVL_SPEED_CMD;	

		//* UBEND
		defCalib->Points[i].val[0] = 1.232002; 	// X1 pos	
		defCalib->Points[i].val[1] = 2.319729; 	// Y1 pos	
		defCalib->Points[i].val[2] = 2.492902; 	// X2 pos	
		defCalib->Points[i].val[3] = 3.810391; 	// Y2 pos	
		
		defCalib->Points[i].val[4] = 1.513998;	// X1 neg	
		defCalib->Points[i].val[5] = 2.319729;	// Y1 neg	
		defCalib->Points[i].val[6] = 2.77144;	// X2 neg	
		defCalib->Points[i].val[7] = 3.810391;	// Y2 neg
		defCalib->Points[i].num = 8;
			

		i = CALIB_WF_SPEED_CMD;	
		
		defCalib->Points[i].val[0] = 34.7; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 42.3; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 70.6; 	// X2 LEFT
		defCalib->Points[i].val[3] = 84.7; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 34.7;	// X1 RIGHT
		defCalib->Points[i].val[5] = 42.3;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 70.6;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 84.7;	// Y2 RIGHT
		
		/*
		defCalib->Points[i].val[0] = 0.0; 	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0; 	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0; 	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0; 	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT	
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		*/	
		
		defCalib->Points[i].num = 8;

		
		i = CALIB_WP_SPEED_CMD; 
		defCalib->Points[i].val[0] = 0.0;	// X1 LEFT	
		defCalib->Points[i].val[1] = 0.0;	// Y1 LEFT	
		defCalib->Points[i].val[2] = 10.0;	// X2 LEFT
		defCalib->Points[i].val[3] = 10.0;	// Y2 LEFT
		
		defCalib->Points[i].val[4] = 0.0;	// X1 RIGHT
		defCalib->Points[i].val[5] = 0.0;	// Y1 RIGHT
		defCalib->Points[i].val[6] = 10.0;	// X2 RIGHT 
		defCalib->Points[i].val[7] = 10.0;	// Y2 RIGHT
		defCalib->Points[i].num = 8;
	
		i=CALIB_TIG_AMPS_CMD;
		
		defCalib->Points[i].val[0] = 92.0;	// X1 
		defCalib->Points[i].val[1] = 80.0;	// Y1 
		defCalib->Points[i].val[2] = 171.0; // X2  - 345 amp max
		defCalib->Points[i].val[3] = 150.0; // Y2 
		defCalib->Points[i].num = 4;
		
		/*
		defCalib->Points[i].val[0] = 0; 	// X1 
		defCalib->Points[i].val[1] = 0; 	// Y1 
		defCalib->Points[i].val[2] = 100; // X2  - 345 amp max
		defCalib->Points[i].val[3] = 100; // Y2 
		defCalib->Points[i].num = 4;
		*/
	
		i=CALIB_HW_AMPS_CMD;
	
		
		defCalib->Points[i].val[0] = 38.0;	// X1 
		defCalib->Points[i].val[1] = 36.0;	// Y1 
		defCalib->Points[i].val[2] = 83.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 80.0; // Y2 
		
		/*
		defCalib->Points[i].val[0] = 0.0;	// X1 
		defCalib->Points[i].val[1] = 0.0;	// Y1 
		defCalib->Points[i].val[2] = 160.0; // X2  - 160 amp max
		defCalib->Points[i].val[3] = 160.0; // Y2 
		*/		
		defCalib->Points[i].num = 4;
	
		//// How many calibrations we have
		defCalib->num = 7;
		//////////////////////////////////////////////////////////////////////////////////

		return 1;

}


#endif



/********************************************************************
 * COPYRIGHT -- wsi
 ********************************************************************
 * Program: Master
 * File: Master.c
 * Author: wsi
 * Created: September 25, 2012
 ********************************************************************

 Hardware[1].Inp[23] - index 80x switch
 * Implementation of program Master
 ********************************************************************/
#include <bur/plctypes.h>

#ifdef _DEFAULT_INCLUDES
#include <AsDefault.h>
#endif

#include <math.h>



#include <..\GlobDef.h>
#include <..\..\Lib\WSI_Lib.c>

#include <..\GlobDecl.h>
#include <..\Hardcoded.c>
#include <..\HMI_Cntrl.c>
#include <..\HeadConfig.c>


#include <..\..\Lib\Statelib.c>
#include <..\..\Lib\LCDLib.c> 
#include <..\..\Lib\LoggerLib.c>

//#include <..\..\Lib\utilityLib\bgdebug.h>
#define TEST_ONLY_PLC_ANDROID
#define HASH_NUM				308

_LOCAL DINT 	statusInit;

_LOCAL Cfg_typ * cfg;
_LOCAL CurCfg_typ * curCfg;
_LOCAL CurCalib_typ * curCalib, *defCalib;
_LOCAL Scaled_Var_obj * var;

_LOCAL MASTER_typ * m;
_LOCAL SerialPortDriver_typ * rs;
_LOCAL LCD_MGR_obj * lcd;
_LOCAL PENDANT_HARDWARE_obj * pend;
_LOCAL HMI_typ * hmi;
_LOCAL HMI_INTRF_typ * intrf;

_LOCAL LCD_NODE_obj * nodes;
_LOCAL TON_typ	CalibrTMR, WF_Catch_TMR;
_LOCAL UINT 	WF_RAMPUP_Comp_Step;

_LOCAL TON_typ	DoubleStop_TMR;
_LOCAL plcbit	DoubleStopBtn;
_LOCAL plcbit	DoubleStopBtn_Latch, StopBtn_Latch;

_LOCAL TON_typ	ESTOP_Dly_Tmr, AndroidConnect_Tmr;
_LOCAL UDINT	GlblBtnLED_Mask;
_LOCAL plcbit	ESTOP_PERMIT;

//_LOCAL UINT CalibStep;
//_LOCAL BOOL CalibStepDone;
prcsSTATUS_Enum _ProcStatus;

_LOCAL INT		ANDROID_Pendant;
_LOCAL plcbit	StartBtn, StopBtn;

_LOCAL TON_typ	WireDisable_TMR;
_LOCAL UINT 	TVL_Latch_Cnt, TVL_Latch_Tm;
_LOCAL UINT 	TVL_Latch_Latched, _TVL_Latch_Latched;


_LOCAL plcbit	Force_ENTR_LCD, _Force_ENTR_LCD;
_LOCAL UINT 	DebaunceCnt[16], DebounceTickSw, DebounceTickSwMax;
_LOCAL BOOL 	TickSw, _TickSw;
_LOCAL DINT 	WF_TVL_Diff;

INT 			_curZone;

_LOCAL plcbit	FirstScan;

BOOL			SendRS232, _SendRS232;
_LOCAL plcstring txt[16][32];
_LOCAL Calib_Param_typ tempCalib;

_LOCAL plcbit	_segmSw;

_LOCAL plcbit	ROM_USB;

_LOCAL DINT 	_SETUP_HEAD_SETUP;
_LOCAL plcbit	AutoStartEnable;


_LOCAL DINT 	actTicks, actTickBalance, actRot, _actRot, actPathCnt;
_LOCAL DINT 	deltaTick, actTicksForZone, actTicksForHead, actTVL_Dist, encHome_TVL;
_LOCAL DINT 	tickEncoder, _tickEncoder, encDelta;
_LOCAL UINT 	btnProgress, btnProgressMax, btnProgressBias;
_LOCAL UINT 	curTML_indx, stillRun;
_LOCAL DINT 	KK_actTicks;
DINT			_KK_actTicks;

float			_TIG_CalibAmp, _HW_CalibAmp;

//_LOCAL Calib_Param_typ tempCalibPar; 
UINT			_ToolHeadID;
DINT			_GlblBtnCmd[2];

INT 			_AndroidWheel;
UINT			_AndroidEntrBtn;
_LOCAL plcstring LineTxt[128];
_LOCAL INT		parametersDump_Step, paramIndx;
_LOCAL DTStructure DTStruct;
_LOCAL DTGetTime_typ DTGetTime_1;

UDINT			_datagramCountTotal[2];
UDINT			_datagramPerSec[2];

UINT			_PLC_Changes;
_LOCAL plcbit	AutoStartBtn;

_LOCAL Robot_typ * robot;


_LOCAL USINT	KK_Life;
_LOCAL BOOL 	KK_AUTO_Test, KK_test;
_LOCAL plcstring KK_text[64];
_LOCAL INT		KK_AndroidWheelIncr;
_LOCAL INT		KK_Drill, KK_Out, KK_ZONE;
_LOCAL DINT 	KK_actPosProcss;
_LOCAL float	KK_CatchAndroidComErr;
_LOCAL UINT 	KK_CatchAndroidErr;

_LOCAL DINT 	myCounter;

void ProcessEvents_Android(MASTER_typ * m, LCD_NODE_obj * nodes, HMI_typ * hmi, HMI_INTRF_typ * intrf);
void EditParam(UINT paramIndx);
void JogProcessAndroid(HMI_INTRF_typ * intrf, UINT procIndx, float gain);
void TakeNextWeldProgram(HMI_typ * hmi);
void AndroidHelper(MASTER_typ * m, UINT n);

void CalibrationModePendantButtons(MASTER_typ * m, HMI_typ * hmi, HMI_INTRF_typ * intrf, LCD_MGR_obj * lcd);
void StopModeAndroidButtons(MASTER_typ * m, HMI_typ * hmi, HMI_INTRF_typ * intrf, LCD_MGR_obj * lcd);
void StopCalibrationModeAndroidButtons(MASTER_typ * m, HMI_typ * hmi, HMI_INTRF_typ * intrf, LCD_MGR_obj * lcd);
void RunModeAndroidButtons(MASTER_typ * m, HMI_typ * hmi, HMI_INTRF_typ * intrf, LCD_MGR_obj * lcd);
void RunCalibrationModeAndroidButtons(MASTER_typ * m, HMI_typ * hmi, HMI_INTRF_typ * intrf, LCD_MGR_obj * lcd);


DINT MasterSequence(MASTER_typ * m, HMI_typ * hmi, plcbit StartBtn, plcbit StopBtn);
DINT CalibrationSequence(MASTER_typ * m, HMI_typ * hmi, plcbit StartBtn, plcbit StopBtn);

void IncrParam(CurCfg_typ * curCfg, UINT param, DINT segm, float gain);
void DecrParam(CurCfg_typ * curCfg, UINT param, DINT segm, float gain);

void Check_parOSC_Excur(CurCfg_typ * curCfg, HMI_typ * hmi, UINT seg);

void Check_parOSC_Amplit(CurCfg_typ * curCfg, HMI_typ * hmi, UINT seg);
void PleaseUpdateHeadSetup(MASTER_typ * m);

void SetBannerTxt(MASTER_typ * m, HMI_typ * hmi, HMI_INTRF_typ * intrf);
float getBtnProgress();
void SetZeroPosition(MASTER_typ * m);
void CreateParamList();
void DeleteExtension(char * p);
void WireDisableInable(plcbit Tmr_Q);

void DumpParamToFile();
void EvaluatePosition();
void Fill_Segments(CurCfg_typ * curCfg, UINT par, UINT seg, UINT Mode, UINT Step);

int WatchArcLinkError(MASTER_typ * m, Robot_typ * robot);


void _INIT Main2_INIT(void)
{
	int 			i;

<<<<<<< HEAD
	strcpy(PLC_Version_TXT, "UnivCntrl-07-18-17A");
=======
	strcpy(PLC_Version_TXT, "UnivCntrl-07-14-17D");
>>>>>>> myBackup/ChrisKaczkowskiDev

	//	Program options
	KK_DoNotChangeTMLProgram = 0;
	KK_DoNotHashCalculation = 1;
	KK_No_TVL_Restart	= 0;
	KK_ManualCalib		= 0;
	KK_TML_PowerON		= 0;
	KK_DoNot_Erase		= 0;

	//////////////////////////
	TVL_Latch_Tm		= 50;
	ANDROID_Pendant 	= 1;

	btnProgressMax		= 30;
	btnProgressBias 	= 30;

#ifdef TEST_ONLY_PLC_ANDROID
	ANDROID_Pendant 	= 1;
#endif

	KK_AUTO_Test		= 0;

	DebounceTickSwMax	= 2;


	// Just to see globals in the watch window
	Master[0].Active	= Master[0].Active;

	//LCD_MGR[0].curHead = LCD_MGR[0].curHead; 
	RS232[0].Ident		= RS232[0].Ident;
	Pendant[0].ABEncoder = Pendant[0].ABEncoder;


	ESTOP_Dly_Tmr.PT	= 1000; 					// 1 sec delay off ESTOP
	Hardware[0].Inp[4]	= 1;						// ESTOP

	Master[0].AndIntrf[0].Alive = 0;


	myCounter			= myCounter;

	actTicks			= actTicksPerm;

	ReadPermMemory_HS.Go = 0;
	ReadPermMemory_HS.Ready = 0;


	TimerStart(&DoubleStop_TMR, 1.0);
	TimerExecute(&DoubleStop_TMR);


}


void _CYCLIC Main2_CYCLIC(void)
{

	int 			i, k;
	char			status, _status;
	DINT			d;
	int 			len;

	//plcbit StartBtn , StopBtn;
	INT 			tickIncr;
	LCD_NODE_obj *	curNode;


	/////////////////////////////cas
	////  Must be in cyclic
	///  This is real pointer pickup 
	///////////////////////
	// Take pointers from SupeMaster
	m					= pMaster[0];
	lcd 				= pLCD_MGR[0];
	rs					= pRS232[0];
	pend				= pPendant[0];


	// Check if pointers are not null
	if (!m)
		return;

	nodes				= m->pNode[0];

	if (!nodes)
		return;

	if (!lcd)
		return;

	if (!rs)
		return;


	if (!pend)
		return;

	if (!m->pCurCfg || !m->pCfg || !m->pCalib || !m->pScaledVar)
		return;

	cfg 				= (Cfg_typ *)
	m->pCfg;
	curCfg				= (CurCfg_typ *)
	m->pCurCfg;
	curCalib			= (CurCalib_typ *)
	m->pCalib;
	defCalib			= (CurCalib_typ *)
	m->pDefaultCalib;
	var 				= (Scaled_Var_obj *)
	m->pScaledVar;


	robot				= (Robot_typ *)
	PS_Param_Set[0].pArcLinkRobot;

	hmi 				= &m->Hmi[0];
	intrf				= &m->Intrf[0];

	if (!hmi || !intrf)
		return;

	// No active when command is lunched
	if (m->xCmd)
	{

		m->Active			= 0;

		ReadPermMemory_HS.Go = 0;
		ReadPermMemory_HS.Ready = 0;

		for (i = 0; i < PROCESS_NUM; i++)
			Process[i].ConfigReady = 0;


	}

	///////////////
	//////////	  Which Heads are allowe and which is default  /////////////////////////

	/*
	if(!((NextHeadConfig_Indx == BPV_F_HEAD) 
		|| (NextHeadConfig_Indx == F_HEAD_HP_MINI_ENC) ))
		NextHeadConfig_Indx = F_HEAD_HP_MINI_ENC;
	*/
	////////////////////////	
	curCalib->GenSetup[SETUP_HEAD_SETUP] = NextHeadConfig_Indx;

	//////////////////////////////////////////////////////////////////
	DumpParamToFile();

	////////////////////////////////////////////////////
	// Task restart from supemaster
	if (m->xCmd == mstrRESTART)
	{
		m->xCmd 			= 0;

		if (m->pNode[0])
		{

			sm_init(&m->sm);
			pend->_intr.TickIncr = 2;

			//SerialPortInit(rs ,  pend->RSDeviceStr , "/PHY=RS232 /BD=9600 /DB=8 /PA=N /SB=1");
			//SerialPortInit(rs , "IF1" , "/PHY=RS232 /BD=9600 /DB=8 /PA=N /SB=1");
			SerialPortInit(rs, "IF6.ST11.IF1", "/PHY=RS232 /BD=9600 /DB=8 /PA=N /SB=1");

			//SerialPortInit(rs , "SS1.IF1.ST5.IF1.ST4.IF1" , "/PHY=RS232 /BD=9600 /DB=8 /PA=N /SB=1");

			/** Master reinit **/
			m->varLastNum		= varLAST_VARIABLE;
			m->paramLastNum 	= parLAST_PARAM;
			m->numSegm			= SEGM_NUM_MAX;
			m->paramEnumLastNum = parENUM_LAST_PARAM;
			m->varEnumLastNum	= varENUM_LAST_VARIABLE;
			m->paramIntgLastNum = parINT_LAST_PARAM;
			m->varIntLastNum	= varINT_LAST_VARIABLE;
			m->paramStrLastNum	= parSTRING_LAST_PARAM;
			m->varStrLastNum	= varSTRING_LAST_VARIABLE;

			memset(nodes, 0, sizeof(LCD_NODE_obj) *NODES_NUM_MAX);

			//ScaledValuesCfg(m); // This is pointer population
			HardCodeCFg(m); 						// This is for pamaeters and variable definition	

			CreateParamList();

			SetupNODES_Android(m, nodes, P_LAST_NODE); // this is what will be displayed on LCD - menu etc

			statusInit			= LCD_MGR_Init(lcd, NUM_LINE, NODES_NUM_MAX, m, rs, nodes, P_INIT, 0.05);

			lcd->EditMode		= EDIT_MODE_VALUE;	// Edit only value of parameter on the screen

			//////////////////////////////////////////
			// Assign HMI pointers from external instances			
			for (i = 0; i < 20; i++)
				hmi->pHMI_Lines[i] = HMI_lines[i];

			for (i = 0; i < 4; i++)
				hmi->pMessage[i] = m->AndIntrf[0].Message[i];

			hmi->pBanner		= m->AndIntrf[0].Banner;

			/////////////////////////////////////////
			TimerStart(&hmi->MsgTmr, 0.1);

			if (ConfigureHead(m, curCalib->GenSetup[SETUP_HEAD_SETUP]))
			{

				m->Active			= 1;			// Master active
				m->LOCKED			= 0;
				m->sm.Step			= 0;			// Main state machine reset

				ReadPermMemory_HS.Go = 1;

			}

			_SETUP_HEAD_SETUP	= curCalib->GenSetup[SETUP_HEAD_SETUP];
			LoggerInit(&LogMgr, &LogID, "LogBook1", 2000);

			ESTOP_PERMIT		= 1;

			///////////////////////////////////////////
			//GB: calculate hash value for the NODES array	
			if (KK_DoNotHashCalculation)
			{

				gHashValuesArray[0] = HASH_NUM;
				gHashValuesArray[1] = gHashValuesArray[0];

			}
			else 
			{

				gHashValuesArray[0] = hash_of_binary_array(nodes, sizeof(LCD_NODE_obj) *NODES_NUM_MAX);
				gHashValuesArray[1] = hash_of_binary_array(cfg, sizeof(Cfg_typ));

			}

			////////////////////////////////////////////
			TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx]._cfg.signFilter = curCfg->Param[parAVC_FbkFilter].val[0];
			TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx]._cfg.kpp =
				 (DINT) (curCfg->Param[parAVC_KPP].val[0] *TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx]._cfg.kppMax);
			TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx]._cfg.kip =
				 (DINT) (curCfg->Param[parAVC_KIP].val[0] *TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx]._cfg.kipMax);

			for (i = 0; i < TML_SERVO_NUM; i++)
				TML_MTR_INST[i].xCMD = TML_RESTART;

			for (i = 0; i < PROCESS_NUM; i++)
				Process[i].xCMD = prcsRESTART;


			intrf->TestMode 	= 1;
			m->WireDisabled 	= 1;

		}


	}

	//if(!m->Active ){
	if (!m->Active || !ReadPermMemory_HS.Ready)
	{
		ESTOP_PERMIT		= 0;
		FirstScan			= 1;
		return;
	}

	if (FirstScan)
	{
		FirstScan			= 0;
		CheckCurCfg(m); 							// check CurCfg if values are in range

	}


	/////////////////////////////////////////////////////	
	// Store last Position
	if (TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx]._int.Init &&
		 (TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx]._cfg.absFbk != 2))
		OLD_MTR_POS[OSC_LAST_POS] = AxisCh[m->pCfg->HeadCfg.OSC.TML_A_Indx].curPos;

	if (TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx]._int.Init &&
		 (TML_MTR_INST[m->pCfg->HeadCfg.TVL.TML_Indx]._cfg.absFbk != 2))
		OLD_MTR_POS[TVL_LAST_POS] = AxisCh[m->pCfg->HeadCfg.TVL.TML_Indx].curPos;

	/////////////////////////////////////////////////////	
	EvaluatePosition();

	//////////////////////////
	// Trigger ESTOP when TML error
	if (KK_TML_PowerON)
		Hardware[1].Outp[7] = 1;
	else 
		Hardware[1].Outp[7] = !TML_MTR_CUT_POWER;


	if (curCfg->Param[parLCD_BtnMode].val[0] > 0.0)
		lcd->EntrBtnPressReq = 1; // LCD ENtr button should be hold to edit
	else 
		lcd->EntrBtnPressReq = 0;



	intrf->GlblBtnCmd[0] = (m->AndIntrf[0].GlblBtnCmd[0] &0xFFFFFFFE); // first bit is wheel is not pressed so we mask it;	

	if (intrf->GlblBtnCmd[0] == 0)
		btnProgress = 0;

	intrf->Wheel		= m->AndIntrf[0].Wheel;

	intrf->WheelDelta	= m->AndIntrf[0].Wheel - _AndroidWheel;
	_AndroidWheel		= m->AndIntrf[0].Wheel;


	intrf->LCDEntr		= (m->AndIntrf[0].EntrBtn > 0);
	intrf->TickPlus 	= ((intrf->WheelDelta > 0) || ((intrf->GlblBtnCmd[0] &ANDR_BTN_UP) &&
		 !intrf->_intr._GlblBtnCmd[0]));
	intrf->TickMinus	= ((intrf->WheelDelta < 0) || ((intrf->GlblBtnCmd[0] &ANDR_BTN_DOWN) &&
		 !intrf->_intr._GlblBtnCmd[0]));

	intrf->LCDEntr_PosEdge = (m->AndIntrf[0].EntrBtn && !_AndroidEntrBtn);
	intrf->LCDEntr_NegEdge = (!m->AndIntrf[0].EntrBtn && _AndroidEntrBtn);
	_AndroidEntrBtn 	= m->AndIntrf[0].EntrBtn;

	m->AndIntrf[0].GlblBtnLED[0] = intrf->GlblBtnLED[0];

	////////////////////////////////////////	
	hmi->curHeadID		= m->AndIntrf[0].curHeadID;
	hmi->curNodeID		= m->AndIntrf[0].curLineID;


	hmi->FiredEvent 	= m->AndIntrf[0].FiredEvent;
	hmi->PleaseUpdate	= m->AndIntrf[0].PleaseUpdate;
	hmi->UserLevel		= m->AndIntrf[0].UserLevel;
	m->AndIntrf[0].FiredEvent = 0;


	/////////////////////////////////////////
	// Security for edit on node
	if (hmi->curHeadID < P_LAST_NODE)
	{ // on one of drill down page

		if (hmi->UserLevel < nodes[hmi->curNodeID].MinUserLevel)
			intrf->LCDEntr = 0;


	}

	/////////////////////////////////
	EvaluateHMI_Android(m, nodes, hmi, intrf);

	//strcpy(m->AndIntrf[0].MasterModTXT , m->sm.Text);		
	//xsprintf(m->AndIntrf[0].MasterModTXT , "Frm: %d / TVL: %d / WF: %d / Ret: %d" , m->curSegm[FR_SEGM]  , m->curSegm[ACT_TVL_DIST], m->curSegm[WF_STOP_CATCH], WF_TVL_Diff);
	xsprintf(m->AndIntrf[0].MasterModTXT, "%d/%d TVL: %d / Enc: %d / OVLP: %d", File_RW._int.PathDoneCnt,
		 (UINT) curCfg->Param[parGEN_WeldProgramRepeat].val[0], TVL_ROT_Param_Set[0].EncPos_FBK, actTicks,
		 WF_TVL_Diff);								// m->curSegm[FR_SEGM]
	ProcessEvents_Android(m, nodes, hmi, intrf);

	m->AndIntrf[0].MsgTmr_Done = !hmi->MsgTmr.Q;
	m->AndIntrf[0].MsgTmr_Duration = (UINT) (hmi->MsgTmr.PT / 1000.0);
	m->AndIntrf[0].MasterMode = m->Mode;

	if (_PLC_Changes != hmi->PLC_Changes)
	{ // New flag
		m->AndIntrf[0].PLC_Changes = hmi->PLC_Changes; // New flag
		_PLC_Changes		= hmi->PLC_Changes;

	}

	else if (m->AndIntrf[0].PLC_Changes == 0)
	{ // Changes accepted
		hmi->PLC_Changes	= 0;
		_PLC_Changes		= hmi->PLC_Changes;

	}



	if (!m->AndIntrf[0].xCMD)
	{

		if ((hmi->Node2JumpID >= P_MENU) && hmi->xCMD)
		{

			m->AndIntrf[0].xCMD = hmi->xCMD;
			m->AndIntrf[0].JumpLineID = hmi->JumpLineID;
			m->AndIntrf[0].Node2JumpID = hmi->Node2JumpID;

			hmi->xCMD			= 0;
			hmi->JumpLineID 	= 0;
			hmi->Node2JumpID	= 0;
		}
		else 
		{



		}
	}

	// No Buttons pressed when pop up message is on
	if (m->AndIntrf[0].MsgTmr_Done)
	{
		intrf->GlblBtnCmd[0] = 0;
		m->AndIntrf[0].GlblBtnCmd[0] = 0;
	}

	///////////////////
	// Buttons
	m->AndIntrf[0].GlblBtnLED[0] = 0;

	if (intrf->TestMode)
		m->AndIntrf[0].GlblBtnLED[0] |= 0x1;

	if (!m->WireDisabled)
		m->AndIntrf[0].GlblBtnLED[0] |= 0x2;

	if (Process[m->pCfg->HeadCfg.AVC.PROC_Indx].Param[0])
		m->AndIntrf[0].GlblBtnLED[0] |= 0x4;

	if (Process[m->pCfg->HeadCfg.GAS.PROC_Indx].Status != prcsSTATUS_Stopped)
		m->AndIntrf[0].GlblBtnLED[0] |= 0x8;

	if (!m->ToolHeadID)
		m->AndIntrf[0].GlblBtnLED[0] |= 0x10;
	else 
		m->AndIntrf[0].GlblBtnLED[0] |= 0x20;


	m->AndIntrf[0].GlblBtnLED[1] = 0;

	switch (curCalib->GenSetup[SETUP_OSC_EXC_MODE])
	{
		case 1:
			m->AndIntrf[0].GlblBtnLED[1] |= 0x1;
			break; // Dwell In

		case 2:
			m->AndIntrf[0].GlblBtnLED[1] |= 0x2;
			break; // Dwell Out		

		default:
			break; // Excursion time
	}

	//m->AndIntrf[0].curNumSegments = m->numZone;
	//m->AndIntrf[0].maxNumSegments = FR_SEGM_NUM_MAX;
	m->AndIntrf[0].curNumSegments = m->curSegm[ZONE];
	m->AndIntrf[0].maxNumSegments = m->numZone + 1;

	Master_numZone		= m->numZone;

	hmi->xCMD			= 0;


	/********************************************************/

	if (m->ESTOP && lcd->Intr.SlowBlink)
		strcpy(lcd->Banner, "	ESTOP !!!!! ");



	if (Force_ENTR_LCD)
	{
		intrf->LCDEntr		= 1;
		lcd->EditMode		= EDIT_MODE_VALUE;
		lcd->Intr.editStep	= 3;
	}

	if (Force_ENTR_LCD && !_Force_ENTR_LCD)
		intrf->LCDEntr_PosEdge = 1;

	else if (!Force_ENTR_LCD && _Force_ENTR_LCD)
		intrf->LCDEntr_NegEdge = 1;

	_Force_ENTR_LCD 	= Force_ENTR_LCD;

	Force_ENTR_LCD		= 0;

	if (!ANDROID_Pendant)
	{

		if (statusInit == 1)
		{

			lcd->Intrf.WheelDelta = intrf->WheelDelta;

			lcd->Intrf.LCDEntr	= intrf->LCDEntr;
			lcd->Intrf.LCDEntr_NegEdge = intrf->LCDEntr_NegEdge;
			lcd->Intrf.LCDEntr_PosEdge = intrf->LCDEntr_PosEdge;

			lcd->Intrf.TickMinus = intrf->TickMinus;
			lcd->Intrf.TickPlus = intrf->TickPlus;

			status				= LCD_MGR_Srv(lcd);

			// Trigger sending to screen every second loop
			if (SendRS232)
			{

				if (!rs->txBufRequest)
					rs->txBufRequest = 1;

			}

			SendRS232			= !SendRS232;
			/****************************************/
		}
	}

	/************************************************************/
	///////////////////////////////////
	//	New Head Selection Process start
	if (m->ESTOP)
	{

		if (hmi->curHeadID != P_PARAM_GLOBAL)
		{

			if (_SETUP_HEAD_SETUP != curCalib->GenSetup[SETUP_HEAD_SETUP])
			{
				m->xCmd 			= 1;			// Restart entire system to get new head configuration			

			}

			_SETUP_HEAD_SETUP	= curCalib->GenSetup[SETUP_HEAD_SETUP];

		}

	}
	else 
		_SETUP_HEAD_SETUP = curCalib->GenSetup[SETUP_HEAD_SETUP];


	if (m->LOCKED && (m->sm.Step < 230))
	{

		for (i = 0; i < PROCESS_NUM; i++)
			Process[i].xCMD = prcsHalt;

		for (i = 0; i < TML_SERVO_NUM; i++)
			TML_MTR_INST[i].xCMD = TML_RESET_ONLY_CMD;


		m->Mode 			= MASTER_MODE_INIT;

		//STOP_SavingData = 1;
		m->sm.Step			= 230;
	}


	////////////////////
	// Android connection
	if (ANDROID_Pendant)
	{

		if ((m->sm.Step > 1))
		{ // Allow init first

			if (_datagramCountTotal[0] != datagramCountTotal[0])
				TimerStart(&AndroidConnect_Tmr, 3.5);

			if (TimerIsTimeOut(&AndroidConnect_Tmr))
			{

				AndroidConnect_Tmr.IN = 0;
				AndroidConnect_Tmr.Q = 0;

				if (m->AndIntrf[0].Alive)
				{
					Errors(&ErrorMgr, ERROR_PENDANT, ERROR_ADROID_COM_LOST, 0);
					LogTxt(&LogMgr, "Pendant com. error");
					KK_CatchAndroidComErr = AndroidConnect_Tmr.ET;
					KK_CatchAndroidErr	= 1;
				}

				m->AndIntrf[0].Alive = 0;

			}

		}
		else 
		{

			AndroidConnect_Tmr.IN = 0;
			AndroidConnect_Tmr.Q = 0;


		}

	}

	///////////////////////////////////////////////
	//	ESTOP and ERROS handling
	if (m->pESTOP_Inp)
	{

#ifdef TEST_ONLY_PLC_ANDROID
		(*m->pESTOP_Inp)	= 1;					// Remove KK
#endif

		if (! (*m->pESTOP_Inp))
		{
			m->ESTOP			= 1;
			ESTOP_Dly_Tmr.IN	= 0;

			if (m->sm.Step > 5 && m->sm.Step < 190)
			{
				m->sm.Step			= 190;
			}


		}
		else 
			m->ESTOP = 0;


	}


	if (ErrorMgr.Error && !m->LOCKED)
	{


		if (m->sm.Step > 5 && m->sm.Step < 190)
		{ // Give chance to clear error by step first steps and download TML programs 


			// Always Coolant On
			if (Process[m->pCfg->HeadCfg.COOL.PROC_Indx].Status != prcsSTATUS_Run)
				Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsSTART;

			Process[m->pCfg->HeadCfg.TVL.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.OSC.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.AVC.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.WF.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.WP.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.TIG.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.HW.PROC_Indx].xCMD = prcsHalt;

			Process[m->pCfg->HeadCfg.GAS.PROC_Indx].xCMD = prcsSTOP;

			//Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsHalt;
			m->Mode 			= MASTER_MODE_ERROR;
			m->sm.Step			= 200;

		}

	}

	////////////////////////////////////////////////////////////////
	// Extra Imperatives
	//curCfg->Param[parTVL_RunDist].val[0] = (float)curCalib->GenSetup[SETUP_TVL_DISTANCE];
	///////////////////////////////////////////////////////////////
	KK_HomeBtn			= (!intrf->_intr._GlblBtnCmd[0] && (intrf->GlblBtnCmd[0] &ANDR_BTN_HOME));
	KK_StopBtn			= (!intrf->_intr._GlblBtnCmd[0] && (intrf->GlblBtnCmd[0] &ANDR_BTN_STOP));

	// MAIN STATES //
	switch (m->sm.Step)
	{
		case 0:
			sm_text("Start", &m->sm);

			if (ANDROID_Pendant)
			{ // start only when is android connection				

				if (_datagramCountTotal[0] == datagramCountTotal[0])
					break;

			}

			if (m->ESTOP)
			{
				m->Mode 			= MASTER_MODE_ESTOP;
				break;
			}

			hmi->Node2JumpID = P_MODE_1;
			hmi->JumpLineID = 0;
			hmi->xCMD = JUMP2ID_CMD;
			hmi->DynPageNodeIndx = 0xFFFF;
			lcd->StaticMessageVisible = 0;
			ParametrAssignToPointers(m, m->curSegm[ZONE]);
			intrf->ModeLED = 1;
			PleaseUpdateHeadSetup(m);
			AckAllErrors(&ErrorMgr);
			TML_MTR_CUT_POWER = 0;

			for (i = 0; i < PROCESS_NUM; i++)
				Process[i].xCMD = prcsRESTART;

			for (i = 0; i < TML_SERVO_NUM; i++)
			{

				TML_MTR_INST[i].xCMD = TML_RESTART;
				TML_MTR_INST[i]._int.restartCnt = 0;
				TML_MTR_INST[i]._int.Init = 0;
			}

			m->SeqStep = 0;
			m->Mode = MASTER_MODE_INIT;

			// Coolant always ON
			//Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsForceON;
			curTML_indx = 0;
			TimerStart(&m->sm.Tmr1, 5.0); // Time to Init TML servo
			m->sm.Step++;
			break;

		case 1:
			sm_text("Check TML", &m->sm);

			if (TimerIsTimeOut(&m->sm.Tmr1))
			{ // Check why TML did not start

				status				= 0;
				_status 			= status;

				for (i = 0; i < TML_SERVO_NUM; i++)
				{

					if (TML_MTR_INST[i].pState)
					{


						if (TML_MTR_INST[i].xCMD == TML_WAIT_FOR_DOWNLOAD)
						{

							LogTxt(&LogMgr, "Wrong Setup %s ", TML_MTR_INST[i].Name);

							if (_status < 2)
								status = 2;


						}

						else if (TML_MTR_INST[i]._int.restartCnt > 10)
						{

							LogTxt(&LogMgr, "CAN com. Err. %s ", TML_MTR_INST[i].Name);

							if (_status < 1)
								status = 1;

						}
						else if (!TML_MTR_INST[i]._int.Init)
						{

#ifndef TEST_ONLY_PLC_ANDROID

							if (TML_MTR_INST[i].xCMD)
								LogTxt(&LogMgr, "Not Comun. %s ", TML_MTR_INST[i].Name);
							else 
								LogTxt(&LogMgr, "Not Init. %s ", TML_MTR_INST[i].Name);

							if (_status < 1)
								status = 1;

#endif
						}

						_status 			= status;

					}



				}



			}
			else 
			{


				status				= 1;


				for (i = 0; i < TML_SERVO_NUM; i++)
				{

					if (TML_MTR_INST[i].pState)
					{

						if (!TML_MTR_INST[i]._int.Init)
							status = 0;

					}

				}

				if (status)
				{
					m->sm.Step			= 5;
					break;
				}
				else 
					break;

			}

			if (KK_DoNotChangeTMLProgram)
			{
				if (status == 2)
					status = 0;
			}

			KK_actPosProcss = status;

			switch (status)
			{
				case 1:
					Errors(&ErrorMgr, ERROR_MOTOR, ERROR_TML_1, 10);
					m->sm.Step = 200;
					break;

				case 2:
					TML_MTR_CUT_POWER = 1;
					m->LOCKED = 1;

					/*
					if(File_RW.CMD == 0){	

						LogTxt(&LogMgr , "TML Refresh" );
						curTML_indx = 0;
						TML_MTR_INST[curTML_indx].xCMD = TML_DOWNL;
						TimerStart(&m->sm.Tmr1 , 1.0);
						m->sm.Step = 220; // TML download
					}
					*/
					break;

				default:
					if (ANDROID_Pendant)
						m->sm.Step = 5;
					else 
					{

						TimerStart(&m->sm.Tmr1, 5.0); // Time to Init Arclink
						m->sm.Step			= 49;

					}

					break;
			}

			break;

		case 5:
			sm_text("Wait for Pendant", &m->sm);

			//if(datagramCountTotal[0] > 100)
#ifndef TEST_ONLY_PLC_ANDROID

			if (m->AndIntrf[0].Alive && Hardware[1].CouplerOK[0])
#else

			if (1)
#endif

			{

				KK_AUTO_Test		= 0;

				TimerStart(&DoubleStop_TMR, 0.1);

				m->SubSeqStep		= 1;

				TimerStart(&m->sm.Tmr1, 30.0);		// Time to Init Arclink
				m->sm.Step			= 49;

			}
			break;

		case 49:
			sm_text("Wait for Arclink", &m->sm);

			if (robot)
			{ // Arclink connection

				if (robot->Cntrl.Fbk.Status &PS_Ready)
					m->sm.Step = 50;

				
				else if(TimerIsTimeOut(&m->sm.Tmr1)){

					Errors(&ErrorMgr,ERROR_TIG_PROC, ERROR_ADROID_COM_LOST, 1 );						
					LogTxt(&LogMgr , "Arclink TimeOut "  );	

				}
				
			}
			else 
				m->sm.Step = 50;

			break;

		// Watch for button pressed 
		case 50:
			sm_text("Normal Stop", &m->sm);

			if (WatchArcLinkError(m, robot))
				break;

			m->Mode = MASTER_MODE_STOP;

			if (_curZone != m->curSegm[ZONE])
				ParametrAssignToPointers(m, m->curSegm[ZONE]);

			_curZone = m->curSegm[ZONE];
			StopModeAndroidButtons(m, hmi, intrf, lcd);
			StartBtn = (!intrf->_intr._GlblBtnCmd[0] && (intrf->GlblBtnCmd[0] &ANDR_BTN_START));
			StopBtn = (!intrf->_intr._GlblBtnCmd[0] && (intrf->GlblBtnCmd[0] &ANDR_BTN_STOP));
			MasterSequence(m, hmi, StartBtn, StopBtn);
			hmi->CalibMode = 0; // No Calibration	

			if (m->SeqStep > 0)
				m->sm.Step = 51;

			break;

		case 51:
			sm_text("Normal Run", &m->sm);

			if (WatchArcLinkError(m, robot))
				break;

			m->Mode = MASTER_MODE_RUN;

			if (_curZone != m->curSegm[ZONE])
				ParametrAssignToPointers(m, m->curSegm[ZONE]);

			_curZone = m->curSegm[ZONE];

			if (Process[m->pCfg->HeadCfg.AVC.PROC_Indx].Status != prcsSTATUS_Stopped)
				RunModeAndroidButtons(m, hmi, intrf, lcd);
			else 
				StopModeAndroidButtons(m, hmi, intrf, lcd);

			StartBtn = (!intrf->_intr._GlblBtnCmd[0] && (intrf->GlblBtnCmd[0] &ANDR_BTN_START));
			StopBtn = (!intrf->_intr._GlblBtnCmd[0] && (intrf->GlblBtnCmd[0] &ANDR_BTN_STOP));
			MasterSequence(m, hmi, StartBtn, StopBtn);

			if (m->SeqStep == 0)
				m->sm.Step = 50;

			break;

		case 100:
			sm_text("Calibration Stop", &m->sm);
			m->Mode = MASTER_MODE_CALIB_STOP;
			StopCalibrationModeAndroidButtons(m, hmi, intrf, lcd);
			StartBtn = (!intrf->_intr._GlblBtnCmd[0] && (intrf->GlblBtnCmd[0] &ANDR_BTN_START));
			StopBtn = (!intrf->_intr._GlblBtnCmd[0] && (intrf->GlblBtnCmd[0] &ANDR_BTN_STOP));

			switch (CalibrationSequence(m, hmi, StartBtn, StopBtn))
			{
				case 0: // Not Ready						
					break;

				case 1: //	Stop						
					break;

				case 2: //	Run					
					m->sm.Step = 101;
					break;
			}

			break;

		case 101:
			sm_text("Calibration Run", &m->sm);
			m->Mode = MASTER_MODE_CALIB_RUN;
			RunCalibrationModeAndroidButtons(m, hmi, intrf, lcd);
			StartBtn = (!intrf->_intr._GlblBtnCmd[0] && (intrf->GlblBtnCmd[0] &ANDR_BTN_START));
			StopBtn = (!intrf->_intr._GlblBtnCmd[0] && (intrf->GlblBtnCmd[0] &ANDR_BTN_STOP));

			switch (CalibrationSequence(m, hmi, StartBtn, StopBtn))
			{
				case 0: // Not Ready
					m->sm.Step = 100;
					break;

				case 1: //	Stop				
					m->sm.Step = 100;
					break;

				case 2: //	Run 				
					break;
			}

			break;

		////////////////////////////////////////
		////////////////////////////////////////					
		case 190:
			sm_text("ESTOP Catched!", &m->sm);
			m->Mode = MASTER_MODE_ESTOP;
			hmi->Node2JumpID = P_INIT;
			hmi->JumpLineID = 0;
			hmi->xCMD = JUMP2ID_CMD;
			hmi->DynPageNodeIndx = P_INIT;
			LogTxt(&LogMgr, " ESTOP Pressed");

			for (i = 0; i < PROCESS_NUM; i++)
				Process[i].xCMD = prcsHalt;

			Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsSTOP;
			Process[m->pCfg->HeadCfg.GAS.PROC_Indx].xCMD = prcsSTOP; // rmaintain gas
			m->SeqStep = 0;
			ParametrAssignToPointers(m, m->curSegm[ZONE]);
			m->sm.Step++;
			break;

		case 191:
			sm_text("Wait: ESTOP", &m->sm);

			if (!m->ESTOP)
			{

				m->sm.Step			= 0;

			}

			break;

		////////////////////////////////////////
		////////////////////////////////////////
		case 200:
			m->Mode = MASTER_MODE_ERROR;

			if (m->sm.Step != m->sm.oldStep)
			{

				if (!m->ESTOP)
					hmi->DynPageNodeIndx = P_ERRORS;

				LogTxt(&LogMgr, " Get ERROR ");

			}
			else if (ErrorMgr.Error <= ERROR_FATAL)
			{


				hmi->DynPageNodeIndx = P_ERRORS;

				m->sm.Step			= 255;

			}
			else if (!ErrorMgr.Error)
			{
				m->Mode 			= MASTER_MODE_INIT;

				//////////////////////////
				if (robot)
				{ // Arclink connection

					if (robot->Cntrl.Fbk.Error > 0)
						robot->Cntrl.Cmd.RST = 1;

				}


				/////////////////////////
				
				TimerStart(&m->sm.Tmr1, 0.1);
				m->sm.Step++;

			}
			else if (!intrf->_intr._GlblBtnCmd[0] && (intrf->GlblBtnCmd[0] &ANDR_BTN_STOP))
			{

				AckAllErrors(&ErrorMgr);

				m->Mode 			= MASTER_MODE_INIT;
				TimerStart(&m->sm.Tmr1, 0.1);
				m->sm.Step++;
			}

			sm_text("ERROR !", &m->sm);
			break;

		case 201:
			sm_text("No Errors wait", &m->sm);

			if (TimerIsTimeOut(&m->sm.Tmr1))
			{

				hmi->Node2JumpID	= P_MODE_1;
				hmi->JumpLineID 	= 0;
				hmi->xCMD			= JUMP2ID_CMD;


				for (i = 0; i < TML_SERVO_NUM; i++)
					TML_MTR_INST[i].xCMD = TML_RESTART;


				m->sm.Step			= 0;

			}

			break;

		/*
		case 220: sm_text("TML Refresh Start" , &m->sm);


			if(TimerIsTimeOut(&m->sm.Tmr1)){ 

				 /// Try to upload new firmware 
				
				if(curTML_indx >= 3){

					LogTxt(&LogMgr , "TML Refresh Start");
					curTML_indx = 0;
					m->sm.Step	= 0;
					
				}
				else {

					if((TML_MTR_INST[curTML_indx].xCMD == TML_IDLE) // if OK skip 
						&& TML_MTR_INST[curTML_indx]._int.Init )
						curTML_indx++;
					
					else if(File_RW.CMD == 0){						
						
						TML_MTR_INST[curTML_indx].xCMD = TML_DOWNL;
						m->sm.Step ++;

					}
				
				}	

			}


		break;	


		case 221: sm_text("TML Refresh Start" , &m->sm);				

			// it was not working well
			//if(TML_MTR_INST[curTML_indx].xCMD != (TML_DOWNL +7)) // anty blocking timer
				//TimerStart(&m->sm.Tmr1 , 10.0);

			if(TML_MTR_INST[curTML_indx].xCMD == TML_DOWNL_DONE){

				LogTxt(&LogMgr , "TML Refresh Start");
				TimerStart(&m->sm.Tmr1 , 1.5);
				curTML_indx ++;
				m->sm.Step = 220;


			}
			// it was not working well
			
		break;			

		case 222: sm_text("TML Setup loading" , &m->sm);

			curTML_indx = intrf->tempIndx;
			if(TML_MTR_INST[curTML_indx].xCMD == TML_DOWNL_DONE)
				m->sm.Step = 1;





		break;	

		*/
		////////////////////////////////////////////
		/////  New Head Configuration Selected
		case 230:
			sm_text("Check (1) TML", &m->sm);

			if (!m->ESTOP)
				m->sm.Step++;

			break;

		case 231:
			sm_text("Check (2) TML", &m->sm);
			TML_MTR_CUT_POWER = 0;

			for (i = 0; i < TML_SERVO_NUM; i++)
				TML_MTR_INST[i].xCMD = TML_RESTART;

			TimerStart(&m->sm.Tmr1, 10.0);
			m->sm.Step++;
			break;

		case 232:
			sm_text("Check TML (3)", &m->sm);

			if (TimerIsTimeOut(&m->sm.Tmr1))
			{

				status				= 0;

				for (i = 0; i < TML_SERVO_NUM; i++)
				{

					if (TML_MTR_INST[i].pState)
					{

						if (status == 0)
						{ // Catch only first

							if (TML_MTR_INST[i].xCMD)
							{

								if ((TML_MTR_INST[i].xCMD == TML_WAIT_FOR_DOWNLOAD) || (TML_MTR_INST[i].xCMD <= 9))
								{ // Reset was blocked
									curTML_indx 		= i;
									status				= 1;
								}
							}

						}
					}

				}

				if (status)
					m->sm.Step++;

				else 
				{

					m->sm.Step			= 246;

				}

			}

			break;

		case 233:
			sm_text("Start Download", &m->sm);

			if (File_RW.CMD == 0)
			{

				TML_MTR_INST[curTML_indx].xCMD = TML_DOWNL;
				TimerStart(&m->sm.Tmr1, 10.0);
				m->sm.Step++;

			}
			else 
			{

				LogTxt(&LogMgr, "File Manager busy");
				m->sm.Step			= 1;
			}

			break;

		case 234:
			sm_text("Wait Downloading", &m->sm);

			if (TML_MTR_INST[curTML_indx].xCMD == 107)
			{

				m->sm.Step			= 235;
				TimerStart(&m->sm.Tmr1, 4.0);


			}
			else if (TML_MTR_INST[curTML_indx].xCMD == 106)
			{

				m->sm.Step			= 236;
				TimerStart(&m->sm.Tmr1, 4.0);


			}
			else if (TML_MTR_INST[curTML_indx].xCMD == TML_DOWNL_DONE)
				m->sm.Step = 245;
			else if (TimerIsTimeOut(&m->sm.Tmr1))
				m->sm.Step = 246;

			break;

		case 235:
			if (TML_MTR_INST[curTML_indx].xCMD != 107)
			{

				m->sm.Step			= 234;
			}
			else if (TimerIsTimeOut(&m->sm.Tmr1))
			{

				//TML_MTR_INST[curTML_indx].xCMD = TML_DOWNL;
				LogTxt(&LogMgr, "Setup Transm. Error %s", TML_MTR_INST[curTML_indx].Name);
				m->sm.Step			= 230;

			}

			break;

		case 236:
			if (TML_MTR_INST[curTML_indx].xCMD != 106)
			{

				m->sm.Step			= 234;
			}
			else if (TimerIsTimeOut(&m->sm.Tmr1))
			{

				LogTxt(&LogMgr, "Setup Transm. Error %s", TML_MTR_INST[curTML_indx].Name);
				m->sm.Step			= 230;

			}

			break;

		case 245: // Try again setup checkout
			m->sm.Step = 231;
			break;

		case 246: // Restart Whole system
			m->xCmd = 1;
			break;
	}



	// Head Selection
	// FWD Direction  - Head B	m->ToolHeadID = 1
	if (m->ToolHeadID == 0)
	{

		Hardware[1].Outp[5] = 0;					// Select Head Signal

		//TVL
		Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[1] = 0; // Select Calibration & Direction

		//WF
		Process[m->pCfg->HeadCfg.WF.PROC_Indx].Param[1] = 0; // Select Calibration
		WIRE_Param_Set[0].pVect = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx];

		if (m->pCfg->HeadCfg.WF.VECT_A_Indx != m->pCfg->HeadCfg.WF.VECT_B_Indx)
			VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx].Mode = vectSt_Mode_Idle;

		//WP
		Process[m->pCfg->HeadCfg.WP.PROC_Indx].Param[1] = 0; // Select Calibration
		WIRE_Param_Set[1].pVect = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx];

		if (m->pCfg->HeadCfg.WP.VECT_A_Indx != m->pCfg->HeadCfg.WP.VECT_B_Indx)
			VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx].Mode = vectSt_Mode_Idle;


		//OSC
		Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Param[1] = 0; // Select Calibration
		OSC_TML_Param_Set[0].pVect = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx];

		if (m->pCfg->HeadCfg.OSC.VECT_A_Indx != m->pCfg->HeadCfg.OSC.VECT_B_Indx)
			VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx].Mode = vectSt_Mode_Idle;

		VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx].OutVect.softLimits[0] =
			 curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];
		VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx].OutVect.softLimits[1] =
			 curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];

		//AVC
		AVC_Param_Set[0].pVect = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx];

		if (m->pCfg->HeadCfg.AVC.VECT_A_Indx != m->pCfg->HeadCfg.AVC.VECT_B_Indx)
			VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx].Mode = vectSt_Mode_Idle;


	}

	// REV Direction  - Head A	m->ToolHeadID = 0
	else 
	{

		Hardware[1].Outp[5] = 1;					// Select Head Signal

		//TVL
		Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[1] = 0x1 + 0x2; // Select Calibration & Direction

		//WF
		Process[m->pCfg->HeadCfg.WF.PROC_Indx].Param[1] = 1; // Select Calibration
		WIRE_Param_Set[0].pVect = &VectorStateMach[m->pCfg->HeadCfg.WF.VECT_B_Indx];

		if (m->pCfg->HeadCfg.WF.VECT_A_Indx != m->pCfg->HeadCfg.WF.VECT_B_Indx)
			VectorStateMach[m->pCfg->HeadCfg.WF.VECT_A_Indx].Mode = vectSt_Mode_Idle;

		//WP
		Process[m->pCfg->HeadCfg.WP.PROC_Indx].Param[1] = 1; // Select Calibration
		WIRE_Param_Set[1].pVect = &VectorStateMach[m->pCfg->HeadCfg.WP.VECT_B_Indx];

		if (m->pCfg->HeadCfg.WP.VECT_A_Indx != m->pCfg->HeadCfg.WP.VECT_B_Indx)
			VectorStateMach[m->pCfg->HeadCfg.WP.VECT_A_Indx].Mode = vectSt_Mode_Idle;


		//OSC
		Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Param[1] = 1; // Select Calibration
		OSC_TML_Param_Set[0].pVect = &VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx];

		if (m->pCfg->HeadCfg.OSC.VECT_A_Indx != m->pCfg->HeadCfg.OSC.VECT_B_Indx)
			VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx].Mode = vectSt_Mode_Idle;

		VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx].OutVect.softLimits[0] =
			 curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2];
		VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx].OutVect.softLimits[1] =
			 curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3];


		//AVC
		AVC_Param_Set[0].pVect = &VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_B_Indx];

		if (m->pCfg->HeadCfg.AVC.VECT_A_Indx != m->pCfg->HeadCfg.AVC.VECT_B_Indx)
			VectorStateMach[m->pCfg->HeadCfg.AVC.VECT_A_Indx].Mode = vectSt_Mode_Idle;



	}


	if (m->ToolHeadID != _ToolHeadID)
	{

		Process[m->pCfg->HeadCfg.OSC.PROC_Indx].xCMD = prcsRESTART;
		_ToolHeadID 		= m->ToolHeadID;

	}

	// On page calibration No limits and Force ToolID assigments
	if (hmi->curHeadID == P_MODE_OSC_LIMIT_CALIB)
	{

		VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx].OutVect.softLimits[0] =
			 defCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];
		VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_A_Indx].OutVect.softLimits[1] =
			 defCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];

		VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx].OutVect.softLimits[0] =
			 defCalib->Points[CALIB_OSC_SFT_LIMIT].val[2];
		VectorStateMach[m->pCfg->HeadCfg.OSC.VECT_B_Indx].OutVect.softLimits[1] =
			 defCalib->Points[CALIB_OSC_SFT_LIMIT].val[3];

	}

	///////////////////////////////////////////////////////////////
	FinalPos			= StartPos + (DINT)
	curCfg->Param[parTVL_RunDist].val[0];


	//////////
	intrf->_intr._GlblBtnCmd[0] = intrf->GlblBtnCmd[0];
	intrf->_intr._GlblBtnCmd[1] = intrf->GlblBtnCmd[1];


	// THIS MUST BE RUN //
	// This is for pipe compensation
	if (m->FrameDia > 0)
		TVL_ROT_Param_Set[0].TotalRescaleFactor = curCfg->Param[parTVL_TrackDia].val[0] / m->FrameDia;
	else 
		TVL_ROT_Param_Set[0].TotalRescaleFactor = 1.0;

	sm_serv(&m->sm);
	TimerExecute(&ESTOP_Dly_Tmr);
	TimerExecute(&DoubleStop_TMR);
	LoggerSrv(&LogMgr);


	//AndroidHelper(m , 0);		
	SetBannerTxt(m, hmi, intrf);
	TimerExecute(&AndroidConnect_Tmr);

	_datagramCountTotal[0] = datagramCountTotal[0];
	_datagramPerSec[0]	= datagramPerSec[0];

	if (btnProgress < btnProgressMax)
		btnProgress++;


	KK_Life++;

}



/*********************************************************/
/****	Process parameters assigments	************************/
DINT MasterSequence(MASTER_typ * m, HMI_typ * hmi, plcbit StartBtn, plcbit StopBtn)
{
	int 			i;
	char			status;
	DINT			ret;
	DINT			d;
	USINT			newFile;

	//Cfg_typ *cfg;
	CurCfg_typ *	curCfg;

	//CurCalib_typ *curCalib , *defCalib;
	//Scaled_Var_obj *var;
	//cfg = (Cfg_typ*) m->pCfg;
	curCfg				= (CurCfg_typ *)
	m->pCurCfg;

	//curCalib = (CurCalib_typ*) m->pCalib;
	//defCalib = (CurCalib_typ*) m->pDefaultCalib;
	//var = (Scaled_Var_obj*) m->pScaledVar;
	m->TestMode 		= intrf->TestMode;

	ret 				= 0;

	/////////
	if (StopBtn)
	{

		AutoStartBtn		= 0;

		if (TimerIsTimeOut(&DoubleStop_TMR))
			TimerStart(&DoubleStop_TMR, 0.5);

		else 
			DoubleStopBtn_Latch = 1;
	}

	if (StopBtn)
		StopBtn_Latch = 1;


	if ((Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status == prcsSTATUS_Stopped) ||
		 (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status == prcsSTATUS_ReturnDly))
	{

		switch (m->SubSeqStep)
		{
			default: // Weld to Infinity
				break;

			case 1: // Weld to Target				
				if (m->curSegm[ACT_TVL_DIST] > (DINT)
				curCfg->Param[parTVL_RunDist].val[0])
				{

					if (DoubleStopBtn_Latch)
						m->SubSeqStep = 0;

					else 
						m->SubSeqStep = 2;
				}

				break;

			case 2: // Rewrap	
				if (DoubleStopBtn_Latch)
					m->SubSeqStep = 0;

				break;
		}

		DoubleStopBtn_Latch = 0;

	}

	if (StopBtn_Latch)
		Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[2] = 0; // No Auto Stop and Not Rewrap

	//////////////////////////
	////////////////////////////
	if (m->SeqStep > 0)
		GlobalTimer += 0.0512; // Timer based on task class

	//	 MASTER SEQUENCE  //
	switch (m->SeqStep)
	{
		case 0:
			// Reset Disable when was in Test Mode
			Process[m->pCfg->HeadCfg.AVC.PROC_Indx].Disable &= 0xFD;
			Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Disable &= 0xFD;
			Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Disable &= 0xFD;
			Process[m->pCfg->HeadCfg.TIG.PROC_Indx].Disable &= 0xFD;
			Process[m->pCfg->HeadCfg.HW.PROC_Indx].Disable &= 0xFD;
			StopBtn_Latch = 0;

			if (StopBtn)
			{

				LogTxt(&LogMgr, "Quick stop");
				m->SeqStep			= 254;			// Halt Stop

				break;
			}

			status = 1;

			if (//(Process[m->pCfg->HeadCfg.GAS.PROC_Indx].Status != prcsSTATUS_Stopped)
			(Process[m->pCfg->HeadCfg.AVC.PROC_Indx].Status != prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status != prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status != prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.WF.PROC_Indx].Status != prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.WP.PROC_Indx].Status != prcsSTATUS_Stopped))
				status = 0;

			if (status)
			{

				if (!ErrorMgr.Error)
				{


					ret 				= 1;		// Raedy To Run

					if (StartBtn || AutoStartBtn)
					{

						AutoStartBtn		= 0;

						if (m->SubSeqStep == 2)
						{ // Rewrap							

							if (curCalib->GenSetup[SETUP_SOUND_DELAY] || curCalib->GenSetup[SETUP_AUTO_START])
								TimerStart(&m->sm.Tmr1, curCalib->GenFloatValue[SETUP_FLOAT_SOUND_TM]);

							else 
								TimerStart(&m->sm.Tmr1, 0.1);


							m->SeqStep			= 150;

						}
						else 
						{


							GlobalTimer 		= 0;

							LogTxt(&LogMgr, "PreProcess start");


							if (curCalib->GenSetup[SETUP_SOUND_DELAY] || curCalib->GenSetup[SETUP_AUTO_START])
								TimerStart(&m->sm.Tmr1, curCalib->GenFloatValue[SETUP_FLOAT_SOUND_TM]);
							else 
								TimerStart(&m->sm.Tmr1, 0.1);

							m->SeqStep++;

						}
					}
				}

			}
			else 
			{


				if (StopBtn)
				{

					LogTxt(&LogMgr, "Some Prcs aborted");
					m->SeqStep			= 254;

				}


			}

			break;

		case 1:
			// Always Coolant On
			if (!m->TestMode)
			{
				if (Process[m->pCfg->HeadCfg.COOL.PROC_Indx].Status != prcsSTATUS_Run)
					Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsSTART;
			}

			ret = 2; // Preparig To Run	

			if (StopBtn)
			{

				LogTxt(&LogMgr, "Some Prcs aborted");
				m->SeqStep			= 254;

			}
			else if (ErrorMgr.Error)
				m->SeqStep = 100;
			else if (!TimerIsTimeOut(&m->sm.Tmr1))
				break;
			else 
			{

				if (!m->TestMode)
				{

					Process[m->pCfg->HeadCfg.GAS.PROC_Indx].xCMD = prcsSTART;
					Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsSTART;
				}

				if (m->TestMode)
				{


					//Process[m->pCfg->HeadCfg.AVC.PROC_Indx].Disable |= 0x02 ;
					Process[m->pCfg->HeadCfg.AVC.PROC_Indx].TestMode = 1;
					Process[m->pCfg->HeadCfg.TIG.PROC_Indx].Disable |= 0x02;
					Process[m->pCfg->HeadCfg.HW.PROC_Indx].Disable |= 0x02;

				}
				else 
				{

					if ((Process[m->pCfg->HeadCfg.GAS.PROC_Indx].Status == prcsSTATUS_Run) &&
						 (Process[m->pCfg->HeadCfg.COOL.PROC_Indx].Status == prcsSTATUS_Run))
					{

						//Process[m->pCfg->HeadCfg.AVC.PROC_Indx].Disable &= 0xFD ;
						Process[m->pCfg->HeadCfg.AVC.PROC_Indx].TestMode = 0;
						Process[m->pCfg->HeadCfg.TIG.PROC_Indx].Disable &= 0xFD;
						Process[m->pCfg->HeadCfg.HW.PROC_Indx].Disable &= 0xFD;

					}
					else 
						break;

				}

				Process[m->pCfg->HeadCfg.AVC.PROC_Indx].xCMD = prcsSTART;

				//if(!m->TestMode)
				Process[m->pCfg->HeadCfg.TIG.PROC_Indx].xCMD = prcsForceON;


				LogTxt(&LogMgr, "ARC start");


				m->SeqStep++;



			}

			break;

		case 2:
			// Always Coolant On
			if (!m->TestMode)
			{
				if (Process[m->pCfg->HeadCfg.COOL.PROC_Indx].Status != prcsSTATUS_Run)
					Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsSTART;
			}

			ret = 2; // Preparig To Run	

			if (StopBtn)
			{

				LogTxt(&LogMgr, "Some Prcs aborted");
				m->SeqStep			= 254;

			}

			///////////////////////////
			else if (ErrorMgr.Error)
				m->SeqStep = 100;
			else if (Process[m->pCfg->HeadCfg.AVC.PROC_Indx].Status == prcsSTATUS_Run)
			{


				Process[m->pCfg->HeadCfg.OSC.PROC_Indx].xCMD = prcsSTART;
				Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Param[0] = 0; // Start with ramp 
				Process[m->pCfg->HeadCfg.TIG.PROC_Indx].xCMD = prcsSTART;

				/*	TVL */
				Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[2] = m->SubSeqStep;
				Process[m->pCfg->HeadCfg.TVL.PROC_Indx].xCMD = prcsSTART;

				StartPos			= 0;
				Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[0] =
					 ((DINT) (curCfg->Param[parTVL_RunDist].val[0]) *m->ticksPerSegm); //Distance to  Run
				Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[3] =
					 ((DINT) (curCfg->Param[parTVL_RewrapDist].val[0]) *m->ticksPerSegm); //Distance to  Rewrap


				if ((TVL_ROT_Param_Set[0].TotalRescaleFactor > 0.0) && (m->pCfg->HeadCfg.TVL.DistPerTick > 0.0))
					WF_TVL_Diff =
						 (DINT) (((*TVL_ROT_Param_Set[0].pPrimVel) *curCfg->Param[parWF_RampUp].val[0]) / (m->pCfg->HeadCfg.TVL.DistPerTick * TVL_ROT_Param_Set[0].TotalRescaleFactor));
				else 
					WF_TVL_Diff = 0;



				switch (curCfg->Param_ENUM[parENUM_TVL_MODE].val[0])
				{
					default: // relative
						Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[3] -= WF_TVL_Diff;
						break;

					case 1: // Side A overlap
						if (!m->ToolHeadID)
							Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[3] -= WF_TVL_Diff;
						else 
							Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[3] =
								 ((DINT) (curCfg->Param[parTVL_RunDist].val[0]) *m->ticksPerSegm); //Distance to	Rewrap				

						break;

					case 2: // Side A overlap
						if (m->ToolHeadID)
							Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[3] -= WF_TVL_Diff;
						else 
							Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[3] =
								 ((DINT) (curCfg->Param[parTVL_RunDist].val[0]) *m->ticksPerSegm); //Distance to	Rewrap				

						break;
				}


				if (!m->WireDisabled)
				{
					Process[m->pCfg->HeadCfg.WF.PROC_Indx].xCMD = prcsSTART;
					Process[m->pCfg->HeadCfg.WP.PROC_Indx].xCMD = prcsSTART;
					Process[m->pCfg->HeadCfg.HW.PROC_Indx].xCMD = prcsSTART;
				}

				LogTxt(&LogMgr, "ARC established");

				TimerStart(&WireDisable_TMR, 3.0);

				m->SeqStep++;

			}

			break;

		case 3:
			// Always Coolant On
			if (!m->TestMode)
			{
				if (Process[m->pCfg->HeadCfg.COOL.PROC_Indx].Status != prcsSTATUS_Run)
					Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsSTART;
			}

			WireDisableInable(WireDisable_TMR.Q);
			Process[m->pCfg->HeadCfg.TIG.PROC_Indx].Param[0] = Process[m->pCfg->HeadCfg.OSC.PROC_Indx].subStatus;
			Process[m->pCfg->HeadCfg.HW.PROC_Indx].Param[0] = Process[m->pCfg->HeadCfg.OSC.PROC_Indx].subStatus;
			ret = 3; //  Run	

			if (actRot != _actRot)
				TakeNextWeldProgram(hmi);

			_actRot = actRot;

			if (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].subStatus == 1)
			{ // End of travel reached

				LogTxt(&LogMgr, "Path Done");

				m->SeqStep			= 200;

			}

			if (StopBtn)
			{

				LogTxt(&LogMgr, "Process stop");

				//Process[m->pCfg->HeadCfg.TVL.PROC_Indx].xCMD = prcsSTOP;
				m->SeqStep			= 200;

			}
			else if (ErrorMgr.Error || m->ESTOP)
			{
				LogTxt(&LogMgr, "Process Error");
				m->SeqStep			= 100;
			}

			break;

		case 100:
			// Always Coolant On
			if (!m->TestMode)
			{
				if (Process[m->pCfg->HeadCfg.COOL.PROC_Indx].Status != prcsSTATUS_Run)
					Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsSTART;
			}

			Process[m->pCfg->HeadCfg.TVL.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.OSC.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.AVC.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.WF.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.WP.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.TIG.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.HW.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.GAS.PROC_Indx].xCMD = prcsSTOP;

			//Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsHalt;
			switch (ErrorMgr.Error)
			{
				case ERROR_FATAL:
					m->SeqStep++;
					break;

				case ERROR_MOTOR:
					m->SeqStep++;
					break;

				case ERROR_MOTOR_INIT:
					m->SeqStep++;
					break;

				case ERROR_TIG_PROC:
					m->SeqStep++;
					break;

				default:
					m->SeqStep++;
					break;
			}

			break;

		case 101:
			ret = 4; // Preparig To Stop in Halt Mode	

			if (StopBtn)
			{


				for (i = 0; i < PROCESS_NUM; i++)
				{
					if (i != PROC_COOL)
						Process[i].xCMD = prcsHalt;
				}

				Process[m->pCfg->HeadCfg.GAS.PROC_Indx].xCMD = prcsSTOP; // rmaintain gas

			}

			status = 1;

			if (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (Process[m->pCfg->HeadCfg.AVC.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (Process[m->pCfg->HeadCfg.WF.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (Process[m->pCfg->HeadCfg.GAS.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (Process[m->pCfg->HeadCfg.WP.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (Process[m->pCfg->HeadCfg.TIG.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (Process[m->pCfg->HeadCfg.HW.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (status)
			{

				LogTxt(&LogMgr, "Prc Final stopped");

				m->SeqStep			= 254;
			}

			break;

		case 150:
			if (StopBtn)
			{

				LogTxt(&LogMgr, "Quick stop");

				m->SeqStep			= 254;			// Quick Stop
				break;
			}

			if (!TimerIsTimeOut(&m->sm.Tmr1))
				break;

			/*	TVL */
			Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[2] = m->SubSeqStep;
			Process[m->pCfg->HeadCfg.TVL.PROC_Indx].xCMD = prcsSTART;
			StartPos = 0;
			Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[0] =
				 ((DINT) (curCfg->Param[parTVL_RunDist].val[0]) *m->ticksPerSegm); //Distance to  Run
			Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[3] =
				 ((DINT) (curCfg->Param[parTVL_RewrapDist].val[0]) *m->ticksPerSegm); //Distance to	Rewrap										

			if ((TVL_ROT_Param_Set[0].TotalRescaleFactor > 0.0) && (m->pCfg->HeadCfg.TVL.DistPerTick > 0.0))
				WF_TVL_Diff =
					 (DINT) (((*TVL_ROT_Param_Set[0].pPrimVel) *curCfg->Param[parWF_RampUp].val[0]) / (m->pCfg->HeadCfg.TVL.DistPerTick * TVL_ROT_Param_Set[0].TotalRescaleFactor));
			else 
				WF_TVL_Diff = 0;

			switch (curCfg->Param_ENUM[parENUM_TVL_MODE].val[0])
			{
				default: // relative
					Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[3] -= WF_TVL_Diff;
					break;

				case 1: // Side A overlap
					if (!m->ToolHeadID)
						Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[3] -= WF_TVL_Diff;
					else 
						Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[3] =
							 ((DINT) (curCfg->Param[parTVL_RunDist].val[0]) *m->ticksPerSegm); //Distance to	Rewrap								

					break;

				case 2: // Side A overlap
					if (m->ToolHeadID)
						Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[3] -= WF_TVL_Diff;
					else 
						Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[3] =
							 ((DINT) (curCfg->Param[parTVL_RunDist].val[0]) *m->ticksPerSegm); //Distance to	Rewrap				

					break;
			}

			m->SeqStep = 202;
			break;

		case 200:
			// Always Coolant On
			if (!m->TestMode)
			{
				if (Process[m->pCfg->HeadCfg.COOL.PROC_Indx].Status != prcsSTATUS_Run)
					Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsSTART;
			}

			for (i = 0; i < PROCESS_NUM; i++)
			{

				if ((i != PROC_COOL)) //&&( i != m->pCfg->HeadCfg.TVL.PROC_Indx))
					Process[i].xCMD = prcsSTOP;



			}

			//TimerStart(&WF_Catch_TMR, curCfg->Param[parWF_RampDwn].val[0]);		
			m->SeqStep++;
			break;

		case 201:
			// Always Coolant On
			if (!m->TestMode)
			{
				if (Process[m->pCfg->HeadCfg.COOL.PROC_Indx].Status != prcsSTATUS_Run)
					Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsSTART;
			}

			if (StopBtn)
			{

				LogTxt(&LogMgr, "Quick stop");

				m->SeqStep			= 254;			// Quick Stop
				break;
			}

			TimerStart(&m->sm.Tmr1, 0.1);
			m->SeqStep++;
			break;

		case 202:
			// Always Coolant On
			if (StopBtn)
			{

				LogTxt(&LogMgr, "Halt stop");

				m->SeqStep			= 254;			// Quick Stop
				break;
			}

			if (!m->TestMode)
			{
				if (Process[m->pCfg->HeadCfg.COOL.PROC_Indx].Status != prcsSTATUS_Run)
					Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsSTART;
			}

			if (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status == prcsSTATUS_Stopped)
				m->SeqStep++;

			break;

		case 203:
			// Always Coolant On
			if (!m->TestMode)
			{
				if (Process[m->pCfg->HeadCfg.COOL.PROC_Indx].Status != prcsSTATUS_Run)
					Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsSTART;
			}

			ret = 5; // Preparing To Stop	

			if (StopBtn)
			{

				LogTxt(&LogMgr, "Quick stop");

				m->SeqStep			= 254;			// Quick Stop
			}

			status = 1;

			if (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status != prcsSTATUS_Stopped) // stopped by end of travel
				status = 0;

			if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (Process[m->pCfg->HeadCfg.AVC.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (Process[m->pCfg->HeadCfg.WF.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (Process[m->pCfg->HeadCfg.GAS.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (Process[m->pCfg->HeadCfg.WP.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (Process[m->pCfg->HeadCfg.TIG.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (Process[m->pCfg->HeadCfg.HW.PROC_Indx].Status != prcsSTATUS_Stopped)
				status = 0;

			if (status)
			{

				// Start Index Move
				m->SeqStep++;
			}

			break;

		case 204:
			// Always Coolant On
			if (!m->TestMode)
			{
				if (Process[m->pCfg->HeadCfg.COOL.PROC_Indx].Status != prcsSTATUS_Run)
					Process[m->pCfg->HeadCfg.COOL.PROC_Indx].xCMD = prcsSTART;
			}

			ret = 5; // Preparing To Stop	

			if (StopBtn)
			{

				LogTxt(&LogMgr, "Quick stop");

				m->SeqStep			= 254;			// Quick Stop
			}

			// Check if Index move done
			if (1)
			{

				if (m->ticksPerSegm > 0)
					d =
						 (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[0] -Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[3]) / m->ticksPerSegm;
				else 
					d = 0;

				d					+= 2;

				if (m->curSegm[ACT_TVL_DIST] <= d)
				{

					m->SubSeqStep		= 1;

					if (curCfg->Param_ENUM[parENUM_PathMode].val[0] == 0.0)
						m->ToolHeadID = !m->ToolHeadID;

					if (curCfg->Param_ENUM[parENUM_TVL_MODE].val[0] == 0)
					{ // Relative Move

						if (TVL_ROT_Param_Set[0].pEncoder)
							OLD_MTR_POS[TVL_ENC_HOME] = *TVL_ROT_Param_Set[0].pEncoder;


					}

					m->SeqStep++;

				}
				else 
				{

					m->SeqStep			= 254;
				}


			}

			break;

		case 205:
			File_RW._int.PathDoneCnt++;
			newFile = 0;

			if (curCfg->Param_ENUM[parENUM_WeldProgramLinkMode].val[0] > 0.0)
			{

				if (curCfg->Param[parGEN_WeldProgramRepeat].val[0] == 0.0)
				{

					if (strlen(curCfg->NextProgramName) > 0)
					{

						if (!strstr(curCfg->NextProgramName, "NONE"))
						{ // Not None
							TakeNextWeldProgram(hmi);
							newFile 			= 1;

						}

					}

				}

				else 
				{

					if (File_RW._int.PathDoneCnt > (UINT)
					curCfg->Param[parGEN_WeldProgramRepeat].val[0])
					{

						if (strlen(curCfg->NextProgramName) > 0)
						{

							if (!strstr(curCfg->NextProgramName, "NONE"))
							{ // Not None
								TakeNextWeldProgram(hmi);
								newFile 			= 1;
							}
						}
					}

				}

			}

			if (newFile)
				m->SeqStep = 206;
			else 
				m->SeqStep = 207;

			break;

		case 206:
			if (File_RW.CMD == 0)
			{

				if (File_RW.Error)
					m->SeqStep = 206;

				else 
				{

					AutoStartEnable 	= 1;
					m->SeqStep			= 207;

				}
			}

			break;

		case 207:
			AutoStartEnable = 1;

			if (File_RW._int.PathDoneCnt > (UINT)
			curCfg->Param[parGEN_WeldProgramRepeat].val[0])
			{
				File_RW._int.PathDoneCnt = (UINT)
				curCfg->Param[parGEN_WeldProgramRepeat].val[0];

				AutoStartEnable 	= 0;
			}

			m->SeqStep++;
			break;

		case 208:
			///////////////////////////////////
			//Auto Start		
			if (curCalib->GenSetup[SETUP_AUTO_START] && AutoStartEnable)
			{
				TimerStart(&m->sm.Tmr1, curCalib->GenFloatValue[SETUP_FLOAT_AUTOSTART_DLY]);
				m->SeqStep			= 220;

			}
			else 
				m->SeqStep = 254;

			break;

		case 220:
			if (StopBtn)
			{

				LogTxt(&LogMgr, "Quick stop");

				m->SeqStep			= 254;			// Quick Stop
				break;
			}
			else if (!TimerIsTimeOut(&m->sm.Tmr1))
				break;

			GlobalTimer = 0;

			//WF_TVL_Diff = 0;	
			LogTxt(&LogMgr, "Auto Repeat");
			AutoStartBtn = 1;
			m->SeqStep = 0;
			break;

		case 254:
			for (i = 0; i < PROCESS_NUM; i++)
			{ // beside PROC_COOL	

				if (i != PROC_COOL)
					Process[i].xCMD = prcsHalt;

			}

			Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Param[0] = 1; // STop without ramp 
			Process[m->pCfg->HeadCfg.OSC.PROC_Indx].xCMD = prcsQuickSTOP; // return to center position
			Process[m->pCfg->HeadCfg.GAS.PROC_Indx].xCMD = prcsSTOP; // rmaintain gas
			m->SeqStep++;
			break;

		default:
			if (StopBtn)
			{

				LogTxt(&LogMgr, "Halt stop");

				for (i = 0; i < PROCESS_NUM; i++)
				{ // beside PROC_COOL	

					if (i != PROC_COOL)
						Process[i].xCMD = prcsHalt;

				}

				Process[m->pCfg->HeadCfg.GAS.PROC_Indx].xCMD = prcsSTOP; // rmaintain gas

				m->SeqStep			= 0;

			}

			if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_Stopped)
				m->SeqStep = 0;

			if (m->SeqStep == 0)
			{

				// Load new AVC param from new file
				TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx]._cfg.signFilter =
					 curCfg->Param[parAVC_FbkFilter].val[0];


			}

			break;
	}

	//if((Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status == prcsSTATUS_Stopped))
	//StopBtn_Latch = 0;
	////////////////////////////
	TimerExecute(&WireDisable_TMR);
	TimerExecute(&WF_Catch_TMR);

	return ret;
}


void ProcessEvents_Android(MASTER_typ * m, LCD_NODE_obj * nodes, HMI_typ * hmi, HMI_INTRF_typ * intrf)
{


	USINT			status;
	UINT			where, indx, seg;
	Scaled_Var_obj * pVar;
	int 			i, k;
	float			x, y, z, a, A, b, B;
	CurCfg_typ *	curCfg;

	UINT			segm;

	//float TVL_StopDly , TVL_RmpDwn ,TVL_Vel , TVL_Vel_Fin , TVL_ReWrap;	
	//float WF_StopDly , WF_RmpDwn;
	curCfg				= m->pCurCfg;

	if (!curCfg)
		return;


	if (File_RW.NewFileLoaded)
	{

		File_RW.NewFileLoaded = 0;

		hmi->PLC_Changes	|= (0x0001 + 0x0002 + 0x0004 + 0x0008); // New CurCfg and New segment List

		PleaseUpdateHeadSetup(m);

		// Force limits from Cfg in curCfg for enumerated values
		for (i = 0; i < m->paramEnumLastNum; i++)
		{

			curCfg->Param_ENUM[i].min = cfg->Param_ENUM[i].min;
			curCfg->Param_ENUM[i].max = cfg->Param_ENUM[i].max;

		}


	}

	switch (hmi->FiredEvent)
	{
		//////////////////////////////////////////////////////////////////
		case EVNT_FILL_MODE:
			curCalib->GenSetup[SETUP_OSC_EXC_MODE] ++;

			if (curCalib->GenSetup[SETUP_OSC_EXC_MODE] > 2)
				curCalib->GenSetup[SETUP_OSC_EXC_MODE] = 0;

			break;

		////////////////////////////////////////////////////////////////////
		case EVENT_WELD_WIZARD_DONE:
			strcpy(hmi->pMessage[0], "	  WIZARD");
			strcpy(hmi->pMessage[1], "	Calculated ");
			xsprintf(hmi->pMessage[2], "New Timing");
			strcpy(hmi->pMessage[3], " ");
			TimerStart(&hmi->MsgTmr, 0.1);
			break;

		////////////////////////////////////////////////////////////////////
		case EVNT_STEP_FWD:
			if (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status == prcsSTATUS_Stopped)
				Process[m->pCfg->HeadCfg.TVL.PROC_Indx].xCMD = prcsSTEPpos;

			break;

		////////////////////////////////////////////////////////////////////
		case EVNT_STEP_REV:
			if (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status == prcsSTATUS_Stopped)
				Process[m->pCfg->HeadCfg.TVL.PROC_Indx].xCMD = prcsSTEPneg;

			break;

		////////////////////////////////////////////////////////////////////
		case EVNT_TEST_MODE_ON_OFF:
			if (m->SeqStep == 0)
			{

				if (intrf->TestMode != 0)
					intrf->TestMode = 0;
				else 
					intrf->TestMode = 1;
			}

			break;

		////////////////////////////////////////////////////////////////////
		case EVNT_SWAP_HEAD:
			if (m->SeqStep != 0) // No Head Changes on run
				break;

			if (m->ToolHeadID != 0)
				m->ToolHeadID = 0;
			else 
				m->ToolHeadID = 1;

			if (TVL_ROT_Param_Set[0].pEncoder)
				OLD_MTR_POS[TVL_ENC_HOME] = *TVL_ROT_Param_Set[0].pEncoder;

			m->SubSeqStep = 1;
			break;

		////////////////////////////////////////////////////////////////////
		case EVNT_SAVE_CURCFG:
			if (File_RW.CMD == 0)
			{
				File_RW.CMD 		= F_SAVE_CURCFG;


				strcpy(hmi->pMessage[0], "	  Parameters  ");
				strcpy(hmi->pMessage[1], "	 ");
				strcpy(hmi->pMessage[2], "		SAVED ");
				strcpy(hmi->pMessage[3], " ");
				TimerStart(&hmi->MsgTmr, 1.0);

			}

			break;

		////////////////////////////////////////////////////////////////////
		case EVNT_SET_HOME:
			if (m->SeqStep == 0)
			{

				// set zero Postion
				SetZeroPosition(m);

			}

			break;

		////////////////////////////////////////////////////////////////////
		case EVNT_TEST_OSC:
			if (m->SeqStep == 0)
			{

				if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_Stopped)
				{
					Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Param[0] = 1; // Start without ramp 
					Process[m->pCfg->HeadCfg.OSC.PROC_Indx].xCMD = prcsJump2Run;
				}

				else if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_Run)
				{

					Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Param[0] = 1; // Stop without ramp 
					Process[m->pCfg->HeadCfg.OSC.PROC_Indx].xCMD = prcsQuickSTOP;

				}

			}

			break;

		////////////////////////////////////////////////////////////////////
		case EVNT_GAS_ON_OFF:
			if (m->Mode != MASTER_MODE_RUN)
			{

				if (Process[m->pCfg->HeadCfg.GAS.PROC_Indx].Status == prcsSTATUS_Stopped)
					Process[m->pCfg->HeadCfg.GAS.PROC_Indx].xCMD = prcsForceON;

				else if (Process[m->pCfg->HeadCfg.GAS.PROC_Indx].Status == prcsSTATUS_Run)
					Process[m->pCfg->HeadCfg.GAS.PROC_Indx].xCMD = prcsHalt;

			}

			break;

		////////////////////////////////////////////////////////////////////
		case EVNT_GO_CALIB_MODE:
			if ((Process[m->pCfg->HeadCfg.GAS.PROC_Indx].Status != prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.AVC.PROC_Indx].Status != prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status != prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status != prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.WF.PROC_Indx].Status != prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.WP.PROC_Indx].Status != prcsSTATUS_Stopped))
				status = 0;

			if (status && (m->sm.Step == 50))
			{

				m->sm.Step			= 100;


			}

			break;

		////////////////////////////////////////////////////////////////////
		case EVNT_RETURN_CALIB_MODE:
			for (i = 0; i < PROCESS_NUM; i++)
			{ // beside PROC_COOL	

				if (i != PROC_COOL)
					Process[i].xCMD = prcsHalt;

			}

			Process[m->pCfg->HeadCfg.GAS.PROC_Indx].xCMD = prcsSTOP; // rmaintain gas
			m->sm.Step = 0;
			break;

		/////////////////////////////////////////////////////////////////////////////////
		case EVNT_OSC_POS_LIMIT_SET:
			if (m->pCfg->HeadCfg.OSC.Limits_Harcoded)
			{

				strcpy(hmi->pMessage[0], " OSC Limits  ");
				strcpy(hmi->pMessage[1], " are hardcoded  ");
				strcpy(hmi->pMessage[2], " Operation ");
				strcpy(hmi->pMessage[3], " denied");
				TimerStart(&hmi->MsgTmr, 1.5);

				break;

			}

			if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Param[1] == 0)
			{

				if (TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx].PosFBK >
					 curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0])
				{

					curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] =
						 TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx].PosFBK;

					if (m->pCfg->HeadCfg.OSC.TML_A_Indx == m->pCfg->HeadCfg.OSC.TML_B_Indx) // Only One OSC
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1];


					strcpy(hmi->pMessage[0], " OSC Positive  ");
					strcpy(hmi->pMessage[1], " Software  ");
					strcpy(hmi->pMessage[2], " Limit SET ");
					strcpy(hmi->pMessage[3], " ");
					TimerStart(&hmi->MsgTmr, 1.5);

				}
				else 
				{

					strcpy(hmi->pMessage[0], " Positive is ");
					strcpy(hmi->pMessage[1], "	 lower ");
					strcpy(hmi->pMessage[2], " than negative");
					strcpy(hmi->pMessage[3], "	TRY AGAIN ");
					TimerStart(&hmi->MsgTmr, 2.0);


				}



			}
			else 
			{

				if (TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx].PosFBK >
					 curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2])
				{

					curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3] =
						 TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx].PosFBK;

					if (m->pCfg->HeadCfg.OSC.TML_A_Indx == m->pCfg->HeadCfg.OSC.TML_B_Indx) // Only One OSC
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1] = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3];

					strcpy(hmi->pMessage[0], " OSC Positive  ");
					strcpy(hmi->pMessage[1], " Software  ");
					strcpy(hmi->pMessage[2], " Limit SET ");
					strcpy(hmi->pMessage[3], " ");
					TimerStart(&hmi->MsgTmr, 1.5);

				}
				else 
				{

					strcpy(hmi->pMessage[0], " Positive is ");
					strcpy(hmi->pMessage[1], "	 lower ");
					strcpy(hmi->pMessage[2], " than negative");
					strcpy(hmi->pMessage[3], "	TRY AGAIN ");
					TimerStart(&hmi->MsgTmr, 2.0);


				}

			}

			break;

		/////////////////////////////////////////////////////////////////////////			
		case EVNT_OSC_NEG_LIMIT_SET:
			if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Param[1] == 0)
			{

				if (TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx].PosFBK <
					 curCalib->Points[CALIB_OSC_SFT_LIMIT].val[1])
				{

					curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] =
						 TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_A_Indx].PosFBK;

					if (m->pCfg->HeadCfg.OSC.TML_A_Indx == m->pCfg->HeadCfg.OSC.TML_B_Indx) // Only One OSC
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0];

					strcpy(hmi->pMessage[0], " OSC Negative  ");
					strcpy(hmi->pMessage[1], " Software  ");
					strcpy(hmi->pMessage[2], " Limit SET ");
					strcpy(hmi->pMessage[3], " ");
					TimerStart(&hmi->MsgTmr, 1.5);

				}
				else 
				{

					strcpy(hmi->pMessage[0], " Negative is ");
					strcpy(hmi->pMessage[1], "	 greater ");
					strcpy(hmi->pMessage[2], " than positive");
					strcpy(hmi->pMessage[3], "	TRY AGAIN ");
					TimerStart(&hmi->MsgTmr, 2.0);


				}



			}
			else 
			{

				if (TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx].PosFBK <
					 curCalib->Points[CALIB_OSC_SFT_LIMIT].val[3])
				{

					curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2] =
						 TML_MTR_INST[m->pCfg->HeadCfg.OSC.TML_B_Indx].PosFBK;

					if (m->pCfg->HeadCfg.OSC.TML_A_Indx == m->pCfg->HeadCfg.OSC.TML_B_Indx) // Only One OSC
						curCalib->Points[CALIB_OSC_SFT_LIMIT].val[0] = curCalib->Points[CALIB_OSC_SFT_LIMIT].val[2];

					strcpy(hmi->pMessage[0], " OSC Positive  ");
					strcpy(hmi->pMessage[1], " Software  ");
					strcpy(hmi->pMessage[2], " Limit SET ");
					strcpy(hmi->pMessage[3], " ");
					TimerStart(&hmi->MsgTmr, 1.5);

				}
				else 
				{

					strcpy(hmi->pMessage[0], " Negative is ");
					strcpy(hmi->pMessage[1], "	 greater ");
					strcpy(hmi->pMessage[2], " than positive");
					strcpy(hmi->pMessage[3], "	TRY AGAIN ");
					TimerStart(&hmi->MsgTmr, 2.0);


				}

			}

			break;

		case EVNT_VER_TIG_PS_CALIB:
			hmi->CalibStep = 4;
			hmi->CalibStepDone = 1;
			strcpy(hmi->pHMI_Lines[0], "Ready To Test");

			//memcpy(&hmi->tempCalib , &curCalib->Points[CALIB_TIG_AMPS_CMD] , sizeof(tempCalib));
			break;

		case EVNT_VER_HW_PS_CALIB:
			hmi->CalibStep = 4;
			hmi->CalibStepDone = 1;
			strcpy(hmi->pHMI_Lines[0], "Ready To Test");

			//memcpy(&hmi->tempCalib , &curCalib->Points[CALIB_HW_AMPS_CMD] , sizeof(tempCalib));
			break;

		case EVNT_VER_TVL_CALIB:
			hmi->CalibStep = 6;
			hmi->CalibStepDone = 1;
			strcpy(hmi->pHMI_Lines[0], "Ready To Test");

			//memcpy(&hmi->tempCalib , &curCalib->Points[CALIB_TVL_SPEED_CMD] , sizeof(tempCalib));
			break;

		case EVNT_VER_WF_CALIB:
			hmi->CalibStep = 6;
			hmi->CalibStepDone = 1;
			strcpy(hmi->pHMI_Lines[0], "Ready To Test");

			//memcpy(&hmi->tempCalib , &curCalib->Points[CALIB_WF_SPEED_CMD] , sizeof(tempCalib));
			break;

		////////////////////////////////////////////////////////////////////
		case EVNT_SAVE_SETUP_BIN:
			if (File_RW.CMD == 0)
			{

				File_RW.CMD 		= F_SAVE_SETUP_BIN;

				strcpy(hmi->pMessage[0], " Setup As Binary");
				strcpy(hmi->pMessage[1], "");
				strcpy(hmi->pMessage[2], "	   SAVED ");
				strcpy(hmi->pMessage[3], " ");
				TimerStart(&hmi->MsgTmr, 1.0);

			}

			break;

		case EVNT_SAVE_SETUP_AS_BIN:
			if (File_RW.CMD == 0)
			{

				if (strlen(curCfg->CurProgramName) == 0)
					strcpy(curCfg->CurProgramName, "Default");

				strcpy(File_RW.fileNewName, curCfg->CurProgramName);

				strcat(File_RW.fileNewName, "_setup");

				File_RW.CMD 		= F_SAVE_AS_CURCFG_BIN;

				strcpy(hmi->pMessage[0], " Setup As Binary");
				strcpy(hmi->pMessage[1], "");
				strcpy(hmi->pMessage[2], "	   SAVED ");
				strcpy(hmi->pMessage[3], " ");
				TimerStart(&hmi->MsgTmr, 1.0);

			}

			break;
	}



	// Temporary Patch it should be on event process switch
	if ((intrf->WheelDelta != 0) || ((intrf->GlblBtnCmd[0] &ANDR_BTN_RIGHT) && !intrf->_intr._GlblBtnCmd[0]) ||
		 ((intrf->GlblBtnCmd[0] &ANDR_BTN_LEFT) && !intrf->_intr._GlblBtnCmd[0]))
	{


		if (curCfg->Param_ENUM[parENUM_WF_WP_Relation].val[0] > 0)
		{

			for (i = 0; i < m->numZone; i++)
				curCfg->Param[parWP_SpeedSP].val[i] =
					 curCfg->Param[parWF_SpeedSP].val[i] *0.31552314834734205493308631414126;
		}

	}

	// Check Updated Values
	if (hmi->PleaseUpdate)
	{

		if (!intrf->TickPlus && !intrf->TickMinus)
			return;

		curCfg->Dirty		= 1;

		if (!m->pScaledVar)
			return;

		pVar				= (Scaled_Var_obj *)
		m->pScaledVar;


		//seg = pVar[indx].segm;
		//seg = 0;
		seg 				= (hmi->PleaseUpdate & 0xFC00) / 1024;

		if ((! (curCalib->GenSetup[SETUP_WHERE_FILL] == 1) && (hmi->curHeadID == 65535))) //Not only Keyboard && Segment Page
			Fill_Segments(curCfg, hmi->PleaseUpdate & 0x3FF, seg, curCalib->GenSetup[SETUP_AUTO_FILL], m->sm.Step);


		switch (hmi->PleaseUpdate & 0x3FF)
		{
			case parWF_SpeedSP:
				if (curCfg->Param_ENUM[parENUM_WF_WP_Relation].val[0] > 0)
				{

					for (i = 0; i < m->numZone; i++)
						curCfg->Param[parWP_SpeedSP].val[i] =
							 curCfg->Param[parWF_SpeedSP].val[i] *0.31552314834734205493308631414126;

				}

				break;

			case parOSC_InitAmplit:

				/*

				if(curCfg->Param[parOSC_InitAmplit].val[seg] > curCfg->Param[parOSC_Amplit].val[seg] ){

					curCfg->Param[parOSC_InitAmplit].val[seg] = curCfg->Param[parOSC_Amplit].val[seg];

					strcpy(hmi->pMessage[0], " OSC Init   ");
					strcpy(hmi->pMessage[1], " Amplitude ");
					strcpy(hmi->pMessage[2], " bigger then ");
					strcpy(hmi->pMessage[3], " Primery Amplitude");
					TimerStart(&hmi->MsgTmr, 1.5);


				}
				*/
				break;

			case parOSC_FinalAmplit:

				/*

				if(curCfg->Param[parOSC_FinalAmplit].val[seg] > curCfg->Param[parOSC_Amplit].val[seg] ){

					curCfg->Param[parOSC_FinalAmplit].val[seg] = curCfg->Param[parOSC_Amplit].val[seg];

					strcpy(hmi->pMessage[0], " OSC Final   ");
					strcpy(hmi->pMessage[1], " Amplitude ");
					strcpy(hmi->pMessage[2], " bigger then ");
					strcpy(hmi->pMessage[3], " Primery Amplitude");
					TimerStart(&hmi->MsgTmr, 1.5);


				}
				*/
				break;

			case parOSC_Amplit:
				Check_parOSC_Amplit(curCfg, hmi, seg);

				/*
				if(curCfg->Param[parOSC_Amplit].val[seg] < curCfg->Param[parOSC_FinalAmplit].val[seg] ){

					curCfg->Param[parOSC_Amplit].val[seg] = curCfg->Param[parOSC_FinalAmplit].val[seg];

					strcpy(hmi->pMessage[0], " OSC Primery	 ");
					strcpy(hmi->pMessage[1], " Amplitude ");
					strcpy(hmi->pMessage[2], " smaller then ");
					strcpy(hmi->pMessage[3], " Final Amplitude");
					TimerStart(&hmi->MsgTmr, 1.5);


				}

				if(curCfg->Param[parOSC_Amplit].val[seg] < curCfg->Param[parOSC_InitAmplit].val[seg] ){

					curCfg->Param[parOSC_Amplit].val[seg] = curCfg->Param[parOSC_InitAmplit].val[seg];

					strcpy(hmi->pMessage[0], " OSC Primery	 ");
					strcpy(hmi->pMessage[1], " Amplitude ");
					strcpy(hmi->pMessage[2], " smaller then ");
					strcpy(hmi->pMessage[3], " Init Amplitude");
					TimerStart(&hmi->MsgTmr, 1.5);


				}


				if(curCfg->Param[parOSC_Excur].val[seg] > 0 ){
					
					x = curCfg->Param[parOSC_Amplit].val[seg] / curCfg->Param[parOSC_Excur].val[seg];					

					if(x > curCfg->Param[parOSC_MaxTvlVel].val[0] ){

						curCfg->Param[parOSC_Amplit].val[seg] = curCfg->Param[parOSC_MaxTvlVel].val[0] * curCfg->Param
					[parOSC_Excur].val[seg];

						strcpy(hmi->pMessage[0], " OSC	 ");
						strcpy(hmi->pMessage[1], " Amplitude ");
						strcpy(hmi->pMessage[2], " was");
						strcpy(hmi->pMessage[3], " too high");
						TimerStart(&hmi->MsgTmr, 1.5);
						
					}	
						
				}

				*/
				break;

			case parOSC_Excur:
				Check_parOSC_Excur(curCfg, hmi, seg);

				/*

				if((curCfg->Param[parOSC_Excur].val[seg] > 0)  
					&& (curCfg->Param[parOSC_MaxTvlVel].val[0] > 0)){
					
					x = curCfg->Param[parOSC_Amplit].val[seg] / curCfg->Param[parOSC_Excur].val[seg];

					if(x >curCfg->Param[parOSC_MaxTvlVel].val[0] ){

						curCfg->Param[parOSC_Excur].val[seg] = curCfg->Param[parOSC_Amplit].val[seg] /		curCfg->Param
					[parOSC_MaxTvlVel].val[0];

						strcpy(hmi->pMessage[0], " OSC	 ");
						strcpy(hmi->pMessage[1], " Excurtion ");
						strcpy(hmi->pMessage[2], " was");
						strcpy(hmi->pMessage[3], " too small");
						TimerStart(&hmi->MsgTmr, 1.5);
						
					}	
						
				}

				*/
				break;

			case parTVL_InitVel:
				if (curCfg->Param[parTVL_InitVel].val[0] > curCfg->Param[parTVL_VelSP].val[seg])
				{

					curCfg->Param[parTVL_InitVel].val[0] = curCfg->Param[parTVL_VelSP].val[seg];

					strcpy(hmi->pMessage[0], " TVL Init   ");
					strcpy(hmi->pMessage[1], " Speed ");
					strcpy(hmi->pMessage[2], " bigger then ");
					strcpy(hmi->pMessage[3], " Primery Speed");
					TimerStart(&hmi->MsgTmr, 1.5);


				}

				break;

			case parTVL_FinalVel:
				if (curCfg->Param[parTVL_FinalVel].val[0] > curCfg->Param[parTVL_VelSP].val[seg])
				{

					curCfg->Param[parTVL_FinalVel].val[0] = curCfg->Param[parTVL_VelSP].val[seg];

					strcpy(hmi->pMessage[0], " TVL Final   ");
					strcpy(hmi->pMessage[1], " Speed ");
					strcpy(hmi->pMessage[2], " bigger then ");
					strcpy(hmi->pMessage[3], " Primery Speed");
					TimerStart(&hmi->MsgTmr, 1.5);


				}

				break;

			case parTVL_VelSP:
				if (curCfg->Param[parTVL_VelSP].val[seg] < curCfg->Param[parTVL_InitVel].val[0])
				{

					curCfg->Param[parTVL_VelSP].val[seg] = curCfg->Param[parTVL_InitVel].val[0];

					strcpy(hmi->pMessage[0], " TVL Primery	 ");
					strcpy(hmi->pMessage[1], " Speed ");
					strcpy(hmi->pMessage[2], " smaller then ");
					strcpy(hmi->pMessage[3], " Init Speed");
					TimerStart(&hmi->MsgTmr, 1.5);


				}

				if (curCfg->Param[parTVL_VelSP].val[seg] < curCfg->Param[parTVL_FinalVel].val[0])
				{

					curCfg->Param[parTVL_VelSP].val[seg] = curCfg->Param[parTVL_FinalVel].val[0];

					strcpy(hmi->pMessage[0], " TVL Primery	 ");
					strcpy(hmi->pMessage[1], " Speed ");
					strcpy(hmi->pMessage[2], " smaller then ");
					strcpy(hmi->pMessage[3], " Final Speed");
					TimerStart(&hmi->MsgTmr, 1.5);


				}

				break;

			case parAVC_FbkFilter:
				TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx]._cfg.signFilter =
					 curCfg->Param[parAVC_FbkFilter].val[0];
				VectorStateMach[VECT_AVC].xCMD = VECT_UpdateSignFilter;
				break;

			case parAVC_DB_Window:
				VectorStateMach[VECT_AVC].fParam[0] = curCfg->Param[parAVC_DB_Window].val[0];
				VectorStateMach[VECT_AVC].xCMD = VECT_Set_MaxError;
				break;

			case parAVC_KIP:
			case parAVC_KPP:
				TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx]._cfg.kpp =
					 (DINT) (curCfg->Param[parAVC_KPP].val[0] *TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx]._cfg.kppMax);
				TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx]._cfg.kip =
					 (DINT) (curCfg->Param[parAVC_KIP].val[0] *TML_MTR_INST[m->pCfg->HeadCfg.AVC.TML_A_Indx]._cfg.kipMax);
				VectorStateMach[VECT_AVC].xCMD = VECT_Set_PID_Param;
				break;

			case parTVL_RunDist:
				PleaseUpdateHeadSetup(m);
				break;

			case parTVL_TrackDia:
				break;
		}


		////////   Parameter Leaders /////////////////////

		/*
		parAVC_Upslope
		parWF_RampUp
		parWF_RampDwn
		parAVC_DownSlope
		*/
		if (hmi->curNodeID == P_PARAM_WELD)
		{


			switch (indx)
			{
				case parAVC_Upslope:
					break;

				case parWF_RampUp:
					break;

				case parWF_RampDwn:
					break;

				case parAVC_DownSlope:
					break;
			}



		}
	}

	hmi->FiredEvent 	= 0;
}



void EditParam(UINT paramIndx)
{

	if (hmi->curNodeID >= P_MENU)
	{
		strcpy(hmi->ActiveBanner, "");
		return;
	}

	GlblBtnLED_Mask 	= intrf->GlblBtnCmd[0];

	Force_ENTR_LCD		= 1;
	hmi->DynPageNodeIndx = P_POP_UP;

	nodes[P_POP_UP].var.Var1ID = paramIndx;

	if (curCfg->Param[paramIndx].segmYes)
		var[paramIndx].segm = m->curSegm[ZONE];

	return;

}


void JogProcessAndroid(HMI_INTRF_typ * intrf, UINT procIndx, float gain)
{

	Process[procIndx].xCMD = prcsDirectCntrl;
	Process[procIndx].fParam[0] = gain;

	return;
}



void TakeNextWeldProgram(HMI_typ * hmi)
{

	if (strlen(curCfg->NextProgramName) && strcmp(curCfg->NextProgramName, PRG_NO_NEXT))
	{

		strcpy(File_RW.deviceName, "WeldPrograms");

		strcpy(File_RW.fileName, curCfg->NextProgramName);

		DeleteExtension(File_RW.fileName);

		if (File_RW.Mode == F_MODE_XML)
			strcat(File_RW.fileName, PRG_FILE_EXT);

		File_RW.CMD 		= F_LOAD_CURCFG;


		if (curCfg->Dirty)
		{

			strcpy(hmi->pMessage[0], "Changes are LOST !!!");
			xsprintf(hmi->pMessage[1], " %s", File_RW.fileName);
			strcpy(hmi->pMessage[2], "	is");
			strcpy(hmi->pMessage[3], " Loaded ");
			TimerStart(&hmi->MsgTmr, 1.0);


		}
		else 
		{

			strcpy(hmi->pMessage[0], " NEXT Program ");
			xsprintf(hmi->pMessage[1], " %s", File_RW.fileName);
			strcpy(hmi->pMessage[2], "	is");
			strcpy(hmi->pMessage[3], " Loaded ");
			TimerStart(&hmi->MsgTmr, 1.0);
		}



	}


}


void AndroidHelper(MASTER_typ * m, UINT n)
{

	if (!m || n > 1)
		return;

	/*
	m->AndIntrf[n].MasterMode = m->Mode;



	switch(m->AndIntrf[n].UserLevel){


		case USER_OPERATOR: strcpy(m->AndIntrf[n].UserLevelTXT , "OPERATOR"); break;
		
		case USER_ADJUSTER: strcpy(m->AndIntrf[n].UserLevelTXT , "ADJUSTER"); break;
		
		case USER_MANAGER:	strcpy(m->AndIntrf[n].UserLevelTXT , "MANAGER"); break;
		
		case USER_JA:		strcpy(m->AndIntrf[n].UserLevelTXT , "DESIGNER"); break;


		default: strcpy(m->AndIntrf[n].UserLevelTXT , "WRONG LEVEL"); break;


	}


	switch(m->AndIntrf[n].MasterMode){


		case MASTER_MODE_STOP: strcpy(m->AndIntrf[n].MasterModTXT , "IDLE"); break;
		
		case MASTER_MODE_RUN: strcpy(m->AndIntrf[n].MasterModTXT , "RUN"); break;
		
		case MASTER_MODE_CALIB_STOP:	strcpy(m->AndIntrf[n].MasterModTXT , "CALIBR. IDLE"); break;
		
		case MASTER_MODE_CALIB_RUN:	strcpy(m->AndIntrf[n].MasterModTXT , "CALIBR. RUN"); break;
		
		case MASTER_MODE_ERROR:			strcpy(m->AndIntrf[n].MasterModTXT , "ERROR"); break;
		
		case MASTER_MODE_ESTOP: 		strcpy(m->AndIntrf[n].MasterModTXT , "ESTOP"); break;

		
		default: strcpy(m->AndIntrf[n].MasterModTXT , "INITIAL"); break;
		


	}

	*/
}


void StopModeAndroidButtons(MASTER_typ * m, HMI_typ * hmi, HMI_INTRF_typ * intrf, LCD_MGR_obj * lcd)
{
	UINT			i;
	UINT			par;


	CurCfg_typ *	curCfg;


	curCfg				= m->pCurCfg;

	if (!curCfg)
		return;


	////////////
	switch (intrf->GlblBtnCmd[0])
	{
		case ANDR_BTN_HOME:
			break;

		case ANDR_BTN_ARC_AMPS_NEG:
			break;

		case ANDR_BTN_ARC_AMPS_POS:
			break;

		case ANDR_BTN_TRAVEL_SPEED_NEG:
			strcpy(hmi->ActiveBanner, " TRAVEL JOG REV ");
			JogProcessAndroid(intrf, m->pCfg->HeadCfg.TVL.PROC_Indx,
				 m->pCfg->HeadCfg.TVL.BtnJog_Gain * getBtnProgress() * (-1.0));

			if (_TVL_Latch_Latched && TVL_Latch_Latched)
			{

				TVL_Latch_Latched	= 0;
				_TVL_Latch_Latched	= TVL_Latch_Latched;
				TVL_Latch_Cnt		= 0;

			}

			if (!TVL_Latch_Latched)
			{

				if (TVL_Latch_Cnt < TVL_Latch_Tm)
					TVL_Latch_Cnt++;
				else 
					TVL_Latch_Latched = 1;
			}

			break;

		case ANDR_BTN_TRAVEL_SPEED_POS:
			strcpy(hmi->ActiveBanner, " TRAVEL JOG FWD");
			JogProcessAndroid(intrf, m->pCfg->HeadCfg.TVL.PROC_Indx,
				 m->pCfg->HeadCfg.TVL.BtnJog_Gain * getBtnProgress());

			if (_TVL_Latch_Latched && TVL_Latch_Latched)
			{

				TVL_Latch_Latched	= 0;
				_TVL_Latch_Latched	= TVL_Latch_Latched;
				TVL_Latch_Cnt		= 0;

			}

			if (!TVL_Latch_Latched)
			{

				if (TVL_Latch_Cnt < TVL_Latch_Tm)
					TVL_Latch_Cnt++;
				else 
					TVL_Latch_Latched = 2;
			}

			break;

		case ANDR_BTN_WIRE_SPEED_NEG:
			strcpy(hmi->ActiveBanner, "WIRE JOG REV");
			JogProcessAndroid(intrf, m->pCfg->HeadCfg.WF.PROC_Indx,
				 m->pCfg->HeadCfg.WF.BtnJog_Gain * getBtnProgress() * (-1.0));
			break;

		case ANDR_BTN_WIRE_SPEED_POS:
			strcpy(hmi->ActiveBanner, "WIRE JOG FWD");
			JogProcessAndroid(intrf, m->pCfg->HeadCfg.WF.PROC_Indx,
				 m->pCfg->HeadCfg.WF.BtnJog_Gain * getBtnProgress());
			break;

		case ANDR_BTN_AVC_VOLTS_NEG:
			strcpy(hmi->ActiveBanner, " AVC JOG DOWN ");
			JogProcessAndroid(intrf, m->pCfg->HeadCfg.AVC.PROC_Indx,
				 m->pCfg->HeadCfg.AVC.BtnJog_Gain * getBtnProgress() * (-1.0));
			break;

		case ANDR_BTN_AVC_VOLTS_POS:
			strcpy(hmi->ActiveBanner, " AVC JOG UP ");
			JogProcessAndroid(intrf, m->pCfg->HeadCfg.AVC.PROC_Indx,
				 m->pCfg->HeadCfg.AVC.BtnJog_Gain * getBtnProgress());
			break;

		case ANDR_BTN_OSC_SPEED_NEG:
			if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_Run)
			{

				strcpy(hmi->ActiveBanner, "OSC	TIME Minus");

				if (m->AndIntrf[0].GlblBtnLED[1] &0x1)
					par = parOSC_Dwell_In;

				else if (m->AndIntrf[0].GlblBtnLED[1] &0x2)
					par = parOSC_Dwell_Out;

				else 
					par = parOSC_Excur;


				if (!intrf->_intr._GlblBtnCmd[0])
				{
					DecrParam(curCfg, par, m->curSegm[ZONE], 1.0);

					if (par == parOSC_Excur)
						Check_parOSC_Excur(curCfg, hmi, m->curSegm[ZONE]);

					if (! (curCalib->GenSetup[SETUP_WHERE_FILL] == 2)) //Not only Editor 
						Fill_Segments(curCfg, par, m->curSegm[ZONE], curCalib->GenSetup[SETUP_AUTO_FILL], m->sm.Step);


				}

			}

			break;

		case ANDR_BTN_OSC_SPEED_POS:
			if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_Run)
			{

				strcpy(hmi->ActiveBanner, "OSC	TIME plus");

				if (m->AndIntrf[0].GlblBtnLED[1] &0x1)
					par = parOSC_Dwell_In;

				else if (m->AndIntrf[0].GlblBtnLED[1] &0x2)
					par = parOSC_Dwell_Out;

				else 
					par = parOSC_Excur;


				if (!intrf->_intr._GlblBtnCmd[0])
				{
					IncrParam(curCfg, par, m->curSegm[ZONE], 1.0);

					if (par == parOSC_Excur)
						Check_parOSC_Excur(curCfg, hmi, m->curSegm[ZONE]);

					if (! (curCalib->GenSetup[SETUP_WHERE_FILL] == 2)) //Not only Editor 
						Fill_Segments(curCfg, par, m->curSegm[ZONE], curCalib->GenSetup[SETUP_AUTO_FILL], m->sm.Step);

				}
			}

			break;

		case ANDR_BTN_OSC_AMPL_NEG:
			if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_Run)
			{

				strcpy(hmi->ActiveBanner, "BTN_OSC_AMPL_NEG ");

				if (!intrf->_intr._GlblBtnCmd[0])
					DecrParam(curCfg, parOSC_Amplit, m->curSegm[ZONE], 1.0);

				Check_parOSC_Amplit(curCfg, hmi, m->curSegm[0]);
			}
			else if ((Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_DirectCntrl))
			{

				strcpy(hmi->ActiveBanner, "OSC JOG LEFT");



				switch (m->pCfg->HeadCfg.OSC.BtnJog_Mode)
				{
					case BTN_JOG_MODE_SINGLE:
						JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
							 m->pCfg->HeadCfg.OSC.BtnJog_Gain * getBtnProgress () * (-1.0));
						break;

					case BTN_JOG_MODE_DUAL:
						if (m->ToolHeadID)
							JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
								 m->pCfg->HeadCfg.OSC.BtnJog_Gain * getBtnProgress());
						else 
							JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
								 m->pCfg->HeadCfg.OSC.BtnJog_Gain * getBtnProgress() * (-1.0));

						break;

					case BTN_JOG_MODE_DUAL_INV:
						if (!m->ToolHeadID)
							JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
								 m->pCfg->HeadCfg.OSC.BtnJog_Gain * getBtnProgress());
						else 
							JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
								 m->pCfg->HeadCfg.OSC.BtnJog_Gain * getBtnProgress() * (-1.0));

						break;
				}

				/*
				switch(curCalib->GenSetup[SETUP_HEAD_SETUP] ){

					case F_HEAD_HP_MINI_ENC:
					case F_HEAD_HP_ENCODER:

						JogProcessAndroid(intrf , m->pCfg->HeadCfg.OSC.PROC_Indx, -24.0 * getBtnProgress());

					break;


					case BPV_F_HEAD:

						JogProcessAndroid(intrf , m->pCfg->HeadCfg.OSC.PROC_Indx, -4.0 * getBtnProgress());

					break;


					default:

						if(m->ToolHeadID)
							JogProcessAndroid(intrf , m->pCfg->HeadCfg.OSC.PROC_Indx, 24.0 * getBtnProgress());
						else
							JogProcessAndroid(intrf , m->pCfg->HeadCfg.OSC.PROC_Indx, -24.0 * getBtnProgress());

					break;	

				}		
				*/
			}

			break;

		case ANDR_BTN_OSC_AMPL_POS:
			if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_Run)
			{

				strcpy(hmi->ActiveBanner, "ANDR_BTN_OSC_AMPL_POS");

				if (!intrf->_intr._GlblBtnCmd[0])
					IncrParam(curCfg, parOSC_Amplit, m->curSegm[ZONE], 1.0);

				Check_parOSC_Amplit(curCfg, hmi, m->curSegm[0]);
			}
			else if ((Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_DirectCntrl))
			{

				strcpy(hmi->ActiveBanner, "OSC JOG RIGHT");


				switch (m->pCfg->HeadCfg.OSC.BtnJog_Mode)
				{
					case BTN_JOG_MODE_SINGLE:
						JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
							 m->pCfg->HeadCfg.OSC.BtnJog_Gain * getBtnProgress ());
						break;

					case BTN_JOG_MODE_DUAL:
						if (m->ToolHeadID)
							JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
								 m->pCfg->HeadCfg.OSC.BtnJog_Gain * getBtnProgress() * (-1.0));
						else 
							JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
								 m->pCfg->HeadCfg.OSC.BtnJog_Gain * getBtnProgress());

						break;

					case BTN_JOG_MODE_DUAL_INV:
						if (!m->ToolHeadID)
							JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
								 m->pCfg->HeadCfg.OSC.BtnJog_Gain * getBtnProgress() * (-1.0));
						else 
							JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
								 m->pCfg->HeadCfg.OSC.BtnJog_Gain * getBtnProgress());

						break;
				}

			}

			break;

		case ANDR_BTN_AVC_LOCK:

			/*
			strcpy(hmi->ActiveBanner , " Test On/OFF");					


			if( !intrf->_intr._GlblBtnCmd[0]  && (m->SeqStep == 0)){
							
			if(intrf->TestMode!= 0)
			intrf->TestMode = 0;
			else
			intrf->TestMode = 1;
			}
			*/
			break;

		case ANDR_BTN_WIRE_DISABLE:
			strcpy(hmi->ActiveBanner, "WIRE ON/OFF");

			if (!intrf->_intr._GlblBtnCmd[0])
			{

				if (m->WireDisabled != 0)
					m->WireDisabled = 0;
				else 
					m->WireDisabled = 1;
			}

			break;

		case ANDR_BTN_STOP:
			for (i = 0; i < PROCESS_NUM; i++)
				Process[i].fParam[0] = 0.0;

			TVL_Latch_Latched = 0;
			_TVL_Latch_Latched = TVL_Latch_Latched;
			TVL_Latch_Cnt = 0;
			break;

		default:
			for (i = 0; i < PROCESS_NUM; i++)
			{

				if (i != m->pCfg->HeadCfg.OSC.PROC_Indx)
					Process[i].fParam[0] = 0.0;
			}

			_TVL_Latch_Latched = TVL_Latch_Latched;
			TVL_Latch_Cnt = 0;
			break;
	}

	if (! (intrf->GlblBtnCmd[0] & (ANDR_BTN_OSC_AMPL_NEG + ANDR_BTN_OSC_AMPL_POS)))
		Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] = 0.0;


	switch (TVL_Latch_Latched)
	{
		case 1:
			JogProcessAndroid(intrf, m->pCfg->HeadCfg.TVL.PROC_Indx, -24.0);
			break;

		case 2:
			JogProcessAndroid(intrf, m->pCfg->HeadCfg.TVL.PROC_Indx, 24.0);
			break;
	}

	//	OScilation Center Jog	
	if ((intrf->WheelDelta != 0) && (hmi->curHeadID == 0xFFFE))
	{ // only jog on Run and Alternate Run screen

		if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status != prcsSTATUS_Init)
		{

			if ((Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_DirectCntrl))
			{

				if (!m->pCfg->HeadCfg.OSC.WhelJog_OnlyWhenRun)
				{

					switch (m->pCfg->HeadCfg.OSC.WhelJog_Mode1)
					{
						case WHL_JOG_MODE_SINGLE:
							JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
								 m->pCfg->HeadCfg.OSC.WheelJog_Gain1 * (float) intrf->WheelDelta);
							break;

						case WHL_JOG_MODE_STEP:
							Process[m->pCfg->HeadCfg.OSC.PROC_Indx].xCMD = prcsJOGpos;
							Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] = (float)
							intrf->WheelDelta * m->pCfg->HeadCfg.OSC.WheelJog_Gain1;
							break;

						case WHL_JOG_MODE_DUAL:
							if (m->ToolHeadID)
								JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
									 m->pCfg->HeadCfg.OSC.WheelJog_Gain1 * (float) intrf->WheelDelta);
							else 
								JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
									 m->pCfg->HeadCfg.OSC.WheelJog_Gain1 * (float) intrf->WheelDelta * (-1.0));

							break;

						case WHL_JOG_MODE_DUAL_INV:
							if (m->ToolHeadID)
								JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
									 m->pCfg->HeadCfg.OSC.WheelJog_Gain1 * (float) intrf->WheelDelta);
							else 
								JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
									 m->pCfg->HeadCfg.OSC.WheelJog_Gain1 * (float) intrf->WheelDelta * (-1.0));

							break;
					}
				}

				/*
				switch(curCalib->GenSetup[SETUP_HEAD_SETUP] ){

					case F_HEAD_HP_MINI_ENC:
					case F_HEAD_HP_ENCODER:

						JogProcess(intrf , m->pCfg->HeadCfg.OSC.PROC_Indx , 4.0 , 0);


					break;


					case BPV_F_HEAD:

						Process[m->pCfg->HeadCfg.OSC.PROC_Indx].xCMD = prcsJOGpos;
						Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] =  (float)intrf->WheelDelta  * (20.0);

					break;


					default:

						if(m->ToolHeadID)				
							JogProcess(intrf , m->pCfg->HeadCfg.OSC.PROC_Indx , -4.0 , 0);
						else
							JogProcess(intrf , m->pCfg->HeadCfg.OSC.PROC_Indx , 4.0 , 0);

					break;	

				}	

				*/
			}
			else 
			{

				Process[m->pCfg->HeadCfg.OSC.PROC_Indx].xCMD = prcsJOGpos;

				switch (m->pCfg->HeadCfg.OSC.WhelJog_Mode2)
				{
					case WHL_JOG_MODE_SINGLE:
					case WHL_JOG_MODE_STEP:
						Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] = (float)
						intrf->WheelDelta * m->pCfg->HeadCfg.OSC.WheelJog_Gain2;
						break;

					case WHL_JOG_MODE_DUAL:
						if (m->ToolHeadID)
							Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] = (float)
							intrf->WheelDelta * m->pCfg->HeadCfg.OSC.WheelJog_Gain2;
						else 
							Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] = (float)
							intrf->WheelDelta * m->pCfg->HeadCfg.OSC.WheelJog_Gain2 * (-1.0);

						break;

					case WHL_JOG_MODE_DUAL_INV:
						if (!m->ToolHeadID)
							Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] = (float)
							intrf->WheelDelta * m->pCfg->HeadCfg.OSC.WheelJog_Gain2;
						else 
							Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] = (float)
							intrf->WheelDelta * m->pCfg->HeadCfg.OSC.WheelJog_Gain2 * (-1.0);

						break;
				}

			}

		}
	}

	/*
	switch(curCalib->GenSetup[SETUP_HEAD_SETUP]){

		case F_HEAD_HP_MINI_ENC:
		case BPV_F_HEAD:
		case F_HEAD_HP_ENCODER:

			Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] =  (float)intrf->WheelDelta  * (20.0);	
			
		break;


		default:

			if(m->ToolHeadID)
				Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] =  (float)intrf->WheelDelta  * (-20.0);
			else	
				Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] =  (float)intrf->WheelDelta  * (20.0);


		break;	



	}	
	*/
}


void StopCalibrationModeAndroidButtons(MASTER_typ * m, HMI_typ * hmi, HMI_INTRF_typ * intrf, LCD_MGR_obj * lcd)
{

	StopModeAndroidButtons(m, hmi, intrf, lcd);
	return;

}


void RunModeAndroidButtons(MASTER_typ * m, HMI_typ * hmi, HMI_INTRF_typ * intrf, LCD_MGR_obj * lcd)
{
	UINT			i;
	UINT			par;

	CurCfg_typ *	curCfg;


	curCfg				= m->pCurCfg;

	if (!curCfg)
		return;



	switch (intrf->GlblBtnCmd[0])
	{
		case ANDR_BTN_ARC_AMPS_NEG:
			strcpy(hmi->ActiveBanner, " ARC AMPS minus ");

			if (!intrf->_intr._GlblBtnCmd[0])
			{
				DecrParam(curCfg, parTIG_AmpSP, m->curSegm[ZONE], 1.0);

				if (! (curCalib->GenSetup[SETUP_WHERE_FILL] == 2)) //Not only Editor 
					Fill_Segments(curCfg, parTIG_AmpSP, m->curSegm[ZONE], curCalib->GenSetup[SETUP_AUTO_FILL],
						 m->sm.Step);

			}

			break;

		case ANDR_BTN_ARC_AMPS_POS:
			strcpy(hmi->ActiveBanner, " ARC AMPS plus ");

			if (!intrf->_intr._GlblBtnCmd[0])
			{

				IncrParam(curCfg, parTIG_AmpSP, m->curSegm[ZONE], 1.0);

				if (! (curCalib->GenSetup[SETUP_WHERE_FILL] == 2)) //Not only Editor 
					Fill_Segments(curCfg, parTIG_AmpSP, m->curSegm[ZONE], curCalib->GenSetup[SETUP_AUTO_FILL],
						 m->sm.Step);
			}

			break;

		case ANDR_BTN_TRAVEL_SPEED_NEG:
			strcpy(hmi->ActiveBanner, " TRAVEL SPEED minus ");

			if (!intrf->_intr._GlblBtnCmd[0])
			{
				DecrParam(curCfg, parTVL_VelSP, m->curSegm[ZONE], 1.0);

				if (! (curCalib->GenSetup[SETUP_WHERE_FILL] == 2)) //Not only Editor 
					Fill_Segments(curCfg, parTVL_VelSP, m->curSegm[ZONE], curCalib->GenSetup[SETUP_AUTO_FILL],
						 m->sm.Step);

			}

			break;

		case ANDR_BTN_TRAVEL_SPEED_POS:
			strcpy(hmi->ActiveBanner, " TRAVEL SPEED plus");

			if (!intrf->_intr._GlblBtnCmd[0])
			{
				IncrParam(curCfg, parTVL_VelSP, m->curSegm[ZONE], 1.0);

				if (! (curCalib->GenSetup[SETUP_WHERE_FILL] == 2)) //Not only Editor 
					Fill_Segments(curCfg, parTVL_VelSP, m->curSegm[ZONE], curCalib->GenSetup[SETUP_AUTO_FILL],
						 m->sm.Step);
			}

			break;

		case ANDR_BTN_WIRE_SPEED_NEG:
			strcpy(hmi->ActiveBanner, "WIRE SPEED minus");

			if (!intrf->_intr._GlblBtnCmd[0])
			{

				DecrParam(curCfg, parWF_SpeedSP, m->curSegm[ZONE], 1.0);

				if (curCfg->Param_ENUM[parENUM_WF_WP_Relation].val[0] > 0)
					curCfg->Param[parWP_SpeedSP].val[m->curSegm[ZONE]] =
						 curCfg->Param[parWF_SpeedSP].val[m->curSegm[ZONE]] *0.31552314834734205493308631414126;

				if (! (curCalib->GenSetup[SETUP_WHERE_FILL] == 2)) //Not only Editor 
					Fill_Segments(curCfg, parWP_SpeedSP, m->curSegm[ZONE], curCalib->GenSetup[SETUP_AUTO_FILL],
						 m->sm.Step);
			}

			break;

		case ANDR_BTN_WIRE_SPEED_POS:
			strcpy(hmi->ActiveBanner, "WIRE SPEED plus");

			if (!intrf->_intr._GlblBtnCmd[0])
			{

				IncrParam(curCfg, parWF_SpeedSP, m->curSegm[ZONE], 1.0);

				if (curCfg->Param_ENUM[parENUM_WF_WP_Relation].val[0] > 0)
					curCfg->Param[parWP_SpeedSP].val[m->curSegm[ZONE]] =
						 curCfg->Param[parWF_SpeedSP].val[m->curSegm[ZONE]] *0.31552314834734205493308631414126;

				if (! (curCalib->GenSetup[SETUP_WHERE_FILL] == 2)) //Not only Editor 
					Fill_Segments(curCfg, parWP_SpeedSP, m->curSegm[ZONE], curCalib->GenSetup[SETUP_AUTO_FILL],
						 m->sm.Step);
			}

			break;

		case ANDR_BTN_AVC_VOLTS_NEG:
			if (m->TestMode)
			{

				strcpy(hmi->ActiveBanner, " AVC JOG DOWN ");
				JogProcessAndroid(intrf, m->pCfg->HeadCfg.AVC.PROC_Indx, -24.0 * getBtnProgress());



			}
			else 
			{

				strcpy(hmi->ActiveBanner, "AVC VOLT minus");

				if (!intrf->_intr._GlblBtnCmd[0])
				{
					DecrParam(curCfg, parAVC_VoltSP, m->curSegm[ZONE], 1.0);

					if (! (curCalib->GenSetup[SETUP_WHERE_FILL] == 2)) //Not only Editor 
						Fill_Segments(curCfg, parAVC_VoltSP, m->curSegm[ZONE], curCalib->GenSetup[SETUP_AUTO_FILL],
							 m->sm.Step);

				}
			}

			break;

		case ANDR_BTN_AVC_VOLTS_POS:
			if (m->TestMode)
			{

				strcpy(hmi->ActiveBanner, " AVC JOG UP ");
				JogProcessAndroid(intrf, m->pCfg->HeadCfg.AVC.PROC_Indx, 24.0 * getBtnProgress());



			}
			else 
			{

				strcpy(hmi->ActiveBanner, "AVC VOLT plus");

				if (!intrf->_intr._GlblBtnCmd[0])
				{
					IncrParam(curCfg, parAVC_VoltSP, m->curSegm[ZONE], 1.0);

					if (! (curCalib->GenSetup[SETUP_WHERE_FILL] == 2)) //Not only Editor 
						Fill_Segments(curCfg, parAVC_VoltSP, m->curSegm[ZONE], curCalib->GenSetup[SETUP_AUTO_FILL],
							 m->sm.Step);


				}

			}

			break;

		case ANDR_BTN_OSC_SPEED_NEG:
			strcpy(hmi->ActiveBanner, "OSC	TIME minus");

			if (m->AndIntrf[0].GlblBtnLED[1] &0x1)
				par = parOSC_Dwell_In;
			else if (m->AndIntrf[0].GlblBtnLED[1] &0x2)
				par = parOSC_Dwell_Out;
			else 
				par = parOSC_Excur;

			if (!intrf->_intr._GlblBtnCmd[0])
			{
				DecrParam(curCfg, par, m->curSegm[ZONE], 1.0);

				if (par == parOSC_Excur)
					Check_parOSC_Excur(curCfg, hmi, m->curSegm[ZONE]);

				if (! (curCalib->GenSetup[SETUP_WHERE_FILL] == 2)) //Not only Editor 
					Fill_Segments(curCfg, par, m->curSegm[ZONE], curCalib->GenSetup[SETUP_AUTO_FILL], m->sm.Step);


			}

			break;

		case ANDR_BTN_OSC_SPEED_POS:
			strcpy(hmi->ActiveBanner, "OSC	TIME plus");

			if (m->AndIntrf[0].GlblBtnLED[1] &0x1)
				par = parOSC_Dwell_In;
			else if (m->AndIntrf[0].GlblBtnLED[1] &0x2)
				par = parOSC_Dwell_Out;
			else 
				par = parOSC_Excur;

			if (!intrf->_intr._GlblBtnCmd[0])
			{
				IncrParam(curCfg, par, m->curSegm[ZONE], 1.0);

				if (par == parOSC_Excur)
					Check_parOSC_Excur(curCfg, hmi, m->curSegm[ZONE]);

				if (! (curCalib->GenSetup[SETUP_WHERE_FILL] == 2)) //Not only Editor 
					Fill_Segments(curCfg, par, m->curSegm[ZONE], curCalib->GenSetup[SETUP_AUTO_FILL], m->sm.Step);

			}

			break;

		case ANDR_BTN_OSC_AMPL_NEG:
			strcpy(hmi->ActiveBanner, "OSC AMPLITUDE minus");

			if (!intrf->_intr._GlblBtnCmd[0])
			{
				DecrParam(curCfg, parOSC_Amplit, m->curSegm[ZONE], 1.0);

				Check_parOSC_Amplit(curCfg, hmi, m->curSegm[ZONE]);

				if (! (curCalib->GenSetup[SETUP_WHERE_FILL] == 2)) //Not only Editor 
					Fill_Segments(curCfg, parOSC_Amplit, m->curSegm[ZONE], curCalib->GenSetup[SETUP_AUTO_FILL],
						 m->sm.Step);

			}

			break;

		case ANDR_BTN_OSC_AMPL_POS:
			strcpy(hmi->ActiveBanner, "OSC AMPLITUDE plus");

			if (!intrf->_intr._GlblBtnCmd[0])
			{
				IncrParam(curCfg, parOSC_Amplit, m->curSegm[ZONE], 1.0);

				Check_parOSC_Amplit(curCfg, hmi, m->curSegm[ZONE]);

				if (! (curCalib->GenSetup[SETUP_WHERE_FILL] == 2)) //Not only Editor 
					Fill_Segments(curCfg, parOSC_Amplit, m->curSegm[ZONE], curCalib->GenSetup[SETUP_AUTO_FILL],
						 m->sm.Step);

			}

			break;

		case ANDR_BTN_AVC_LOCK:
			strcpy(hmi->ActiveBanner, "AVC LOCK ON / OFF");

			if (curCfg->Param_ENUM[parENUM_AVC_Mode].val[0] != 2)
			{ // AVC Mode NOT Lock

				if (!intrf->_intr._GlblBtnCmd[0])
				{

					Process[m->pCfg->HeadCfg.AVC.PROC_Indx].Param[0] =
						 !Process[m->pCfg->HeadCfg.AVC.PROC_Indx].Param[0]; // AVC Hold

				}

			}

			break;

		case ANDR_BTN_WIRE_DISABLE:
			strcpy(hmi->ActiveBanner, "WIRE ON/OFF");

			if (!intrf->_intr._GlblBtnCmd[0])
			{

				if (m->WireDisabled != 0)
					m->WireDisabled = 0;
				else 
					m->WireDisabled = 1;
			}

			break;

		default:
			for (i = 0; i < PROCESS_NUM; i++)
				Process[i].fParam[0] = 0.0;

			break;
	}


	//	OScilation Center Jog	
	if ((intrf->WheelDelta != 0) && (hmi->curHeadID == 0xFFFE))
	{ // only jog on Run and Alternate Run screen

		if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status != prcsSTATUS_Init)
		{

			if ((Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_DirectCntrl))
			{


				switch (m->pCfg->HeadCfg.OSC.WhelJog_Mode1)
				{
					case WHL_JOG_MODE_SINGLE:
						JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
							 m->pCfg->HeadCfg.OSC.WheelJog_Gain1 * (float) intrf->WheelDelta);
						break;

					case WHL_JOG_MODE_STEP:
						Process[m->pCfg->HeadCfg.OSC.PROC_Indx].xCMD = prcsJOGpos;
						Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] = (float)
						intrf->WheelDelta * m->pCfg->HeadCfg.OSC.WheelJog_Gain1;
						break;

					case WHL_JOG_MODE_DUAL:
						if (m->ToolHeadID)
							JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
								 m->pCfg->HeadCfg.OSC.WheelJog_Gain1 * (float) intrf->WheelDelta);
						else 
							JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
								 m->pCfg->HeadCfg.OSC.WheelJog_Gain1 * (float) intrf->WheelDelta * (-1.0));

						break;

					case WHL_JOG_MODE_DUAL_INV:
						if (m->ToolHeadID)
							JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
								 m->pCfg->HeadCfg.OSC.WheelJog_Gain1 * (float) intrf->WheelDelta);
						else 
							JogProcessAndroid(intrf, m->pCfg->HeadCfg.OSC.PROC_Indx,
								 m->pCfg->HeadCfg.OSC.WheelJog_Gain1 * (float) intrf->WheelDelta * (-1.0));

						break;
				}

				/*
				switch(curCalib->GenSetup[SETUP_HEAD_SETUP] ){

					case F_HEAD_HP_MINI_ENC:
					case F_HEAD_HP_ENCODER:

						JogProcess(intrf , m->pCfg->HeadCfg.OSC.PROC_Indx , 4.0 , 0);


					break;


					case BPV_F_HEAD:

						Process[m->pCfg->HeadCfg.OSC.PROC_Indx].xCMD = prcsJOGpos;
						Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] =  (float)intrf->WheelDelta  * (20.0);

					break;


					default:

						if(m->ToolHeadID)				
							JogProcess(intrf , m->pCfg->HeadCfg.OSC.PROC_Indx , -4.0 , 0);
						else
							JogProcess(intrf , m->pCfg->HeadCfg.OSC.PROC_Indx , 4.0 , 0);

					break;	

				}	

				*/
			}
			else 
			{

				Process[m->pCfg->HeadCfg.OSC.PROC_Indx].xCMD = prcsJOGpos;

				switch (m->pCfg->HeadCfg.OSC.WhelJog_Mode2)
				{
					case WHL_JOG_MODE_SINGLE:
					case WHL_JOG_MODE_STEP:
						Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] = (float)
						intrf->WheelDelta * m->pCfg->HeadCfg.OSC.WheelJog_Gain2;
						break;

					case WHL_JOG_MODE_DUAL:
						if (m->ToolHeadID)
							Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] = (float)
							intrf->WheelDelta * m->pCfg->HeadCfg.OSC.WheelJog_Gain2;
						else 
							Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] = (float)
							intrf->WheelDelta * m->pCfg->HeadCfg.OSC.WheelJog_Gain2 * (-1.0);

						break;

					case WHL_JOG_MODE_DUAL_INV:
						if (!m->ToolHeadID)
							Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] = (float)
							intrf->WheelDelta * m->pCfg->HeadCfg.OSC.WheelJog_Gain2;
						else 
							Process[m->pCfg->HeadCfg.OSC.PROC_Indx].fParam[0] = (float)
							intrf->WheelDelta * m->pCfg->HeadCfg.OSC.WheelJog_Gain2 * (-1.0);

						break;
				}

			}

		}
	}

}


void RunCalibrationModeAndroidButtons(MASTER_typ * m, HMI_typ * hmi, HMI_INTRF_typ * intrf, LCD_MGR_obj * lcd)
{

	StopModeAndroidButtons(m, hmi, intrf, lcd);
	return;
}



DINT CalibrationSequence(MASTER_typ * m, HMI_typ * hmi, plcbit StartBtn, plcbit StopBtn)
{
	UINT			i, status;
	DINT			ret;

	//Cfg_typ *cfg;
	CurCfg_typ *	curCfg;
	CurCalib_typ *	curCalib, *defCalib;

	//Scaled_Var_obj *var;
	//cfg = (Cfg_typ*) m->pCfg;
	curCfg				= (CurCfg_typ *)
	m->pCurCfg;
	curCalib			= (CurCalib_typ *)
	m->pCalib;
	defCalib			= (CurCalib_typ *)
	m->pDefaultCalib;

	//var = (Scaled_Var_obj*) m->pScaledVar;
	///////////////////////////////	
	// Button Start and Stop
	ret 				= 1;						// Stop

	switch (m->CalibType)
	{
		case CALIB_TVL:
			if ((Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status == prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status == prcsSTATUS_DirectCntrl))
			{

				if (StartBtn)
					Process[m->pCfg->HeadCfg.TVL.PROC_Indx].xCMD = prcsCalib;

			}

			switch (hmi->CalibStep)
			{
				case 1:
				case 2: // Low Vel
					//if(StartBtn || KK_DoNot_Erase){
					if (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[1] &0x2)
					{

						Process[m->pCfg->HeadCfg.TVL.PROC_Indx].fParam[1] =
							 getFromCalib(curCfg->Param[parTVL_CalibVel1].val[0],
							 &curCalib->Points[CALIB_TVL_SPEED_CMD], CALIB_2POINTS);

						hmi->CalibPoint[hmi->CalibStep] = 0;
						hmi->CalibPointCmd[hmi->CalibStep] = Process[m->pCfg->HeadCfg.TVL.PROC_Indx].fParam[1];

					}
					else 
					{

						Process[m->pCfg->HeadCfg.TVL.PROC_Indx].fParam[1] =
							 getFromCalib(curCfg->Param[parTVL_CalibVel1].val[0],
							 &curCalib->Points[CALIB_TVL_SPEED_CMD], CALIB_2POINTS_4OFF);

						hmi->CalibPoint[hmi->CalibStep] = 4;
						hmi->CalibPointCmd[hmi->CalibStep] = Process[m->pCfg->HeadCfg.TVL.PROC_Indx].fParam[1];

					}

					//}
					if (KK_ManualCalib)
						Process[m->pCfg->HeadCfg.TVL.PROC_Indx].fParam[1] = KK_ManualCalib_set_value;

					break;

				case 3:
				case 4:
					// High Vel
					//if(StartBtn || KK_DoNot_Erase){
					if (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[1] &0x2)
					{

						Process[m->pCfg->HeadCfg.TVL.PROC_Indx].fParam[1] =
							 getFromCalib(curCfg->Param[parTVL_CalibVel2].val[0],
							 &curCalib->Points[CALIB_TVL_SPEED_CMD], CALIB_2POINTS);

						hmi->CalibPoint[hmi->CalibStep] = 2;
						hmi->CalibPointCmd[hmi->CalibStep] = Process[m->pCfg->HeadCfg.TVL.PROC_Indx].fParam[1];

					}
					else 
					{

						Process[m->pCfg->HeadCfg.TVL.PROC_Indx].fParam[1] =
							 getFromCalib(curCfg->Param[parTVL_CalibVel2].val[0],
							 &curCalib->Points[CALIB_TVL_SPEED_CMD], CALIB_2POINTS_4OFF);

						hmi->CalibPoint[hmi->CalibStep] = 6;
						hmi->CalibPointCmd[hmi->CalibStep] = Process[m->pCfg->HeadCfg.TVL.PROC_Indx].fParam[1];

					}

					//}
					if (KK_ManualCalib)
						Process[m->pCfg->HeadCfg.TVL.PROC_Indx].fParam[1] = KK_ManualCalib_set_value;

					break;

				default:
					Process[m->pCfg->HeadCfg.TVL.PROC_Indx].fParam[1] = 0.0;
					break;
			}

			break;

		///////////////////////////////////////////
		case CALIB_WF:
			if ((Process[m->pCfg->HeadCfg.WF.PROC_Indx].Status == prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.WF.PROC_Indx].Status == prcsSTATUS_DirectCntrl))
			{

				if (StartBtn)
					Process[m->pCfg->HeadCfg.WF.PROC_Indx].xCMD = prcsCalib;

			}

			if (TimerIsTimeOut(&CalibrTMR))
			{
				CalibrTMR.IN		= 0;
				CalibrTMR.Q 		= 0;
				Process[m->pCfg->HeadCfg.WF.PROC_Indx].xCMD = prcsHalt;
			}

			switch (hmi->CalibStep)
			{
				case 1:
				case 3: // Low Vel
					if (StartBtn)
						TimerStart(&CalibrTMR, curCfg->Param[parGEN_CalibTime1].val[0]);

					//if(StartBtn || KK_DoNot_Erase){
					if (Process[m->pCfg->HeadCfg.WF.PROC_Indx].Param[1])
					{
						hmi->CalibPoint[hmi->CalibStep] = 0;
						Process[m->pCfg->HeadCfg.WF.PROC_Indx].fParam[1] =
							 getFromCalib(curCfg->Param[parWF_CalibVel1].val[0],
							 &curCalib->Points[CALIB_WF_SPEED_CMD], CALIB_2POINTS);
						hmi->CalibPointCmd[hmi->CalibStep] = Process[m->pCfg->HeadCfg.WF.PROC_Indx].fParam[1];
					}
					else 
					{
						hmi->CalibPoint[hmi->CalibStep] = 4;
						Process[m->pCfg->HeadCfg.WF.PROC_Indx].fParam[1] =
							 getFromCalib(curCfg->Param[parWF_CalibVel1].val[0],
							 &curCalib->Points[CALIB_WF_SPEED_CMD], CALIB_2POINTS_4OFF);
						hmi->CalibPointCmd[hmi->CalibStep] = Process[m->pCfg->HeadCfg.WF.PROC_Indx].fParam[1];
					}

					//}
					if (KK_ManualCalib)
						Process[m->pCfg->HeadCfg.WF.PROC_Indx].fParam[1] = KK_ManualCalib_set_value;

					break;

				case 2:
				case 4: // High Vel
					if (StartBtn)
						TimerStart(&CalibrTMR, curCfg->Param[parGEN_CalibTime2].val[0]);

					//if(StartBtn || KK_DoNot_Erase){
					if (Process[m->pCfg->HeadCfg.WF.PROC_Indx].Param[1])
					{
						hmi->CalibPoint[hmi->CalibStep] = 2;
						Process[m->pCfg->HeadCfg.WF.PROC_Indx].fParam[1] =
							 getFromCalib(curCfg->Param[parWF_CalibVel2].val[0],
							 &curCalib->Points[CALIB_WF_SPEED_CMD], CALIB_2POINTS);
						hmi->CalibPointCmd[hmi->CalibStep] = Process[m->pCfg->HeadCfg.WF.PROC_Indx].fParam[1];
					}
					else 
					{
						hmi->CalibPoint[hmi->CalibStep] = 6;
						Process[m->pCfg->HeadCfg.WF.PROC_Indx].fParam[1] =
							 getFromCalib(curCfg->Param[parWF_CalibVel2].val[0],
							 &curCalib->Points[CALIB_WF_SPEED_CMD], CALIB_2POINTS_4OFF);
						hmi->CalibPointCmd[hmi->CalibStep] = Process[m->pCfg->HeadCfg.WF.PROC_Indx].fParam[1];
					}

					//}
					if (KK_ManualCalib)
						Process[m->pCfg->HeadCfg.WF.PROC_Indx].fParam[1] = KK_ManualCalib_set_value;

					break;

				default:
					Process[m->pCfg->HeadCfg.WF.PROC_Indx].fParam[1] = 0.0;
					break;
			}

			break;

		//////////////////////////////////////////////////////////////////
		case CALIB_TIG_PS:
			if ((Process[m->pCfg->HeadCfg.TIG.PROC_Indx].Status == prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.TIG.PROC_Indx].Status == prcsSTATUS_DirectCntrl))
			{

				if (StartBtn)
					Process[m->pCfg->HeadCfg.TIG.PROC_Indx].xCMD = prcsCalib;

			}

			switch (hmi->CalibStep)
			{
				case 1:
					//if(StartBtn || KK_DoNot_Erase){
					hmi->CalibPoint[hmi->CalibStep] = 0;
					Process[m->pCfg->HeadCfg.TIG.PROC_Indx].fParam[1] =
						 getFromCalib(curCfg->Param[parTIG_CalibAmp1].val[0], &curCalib->Points[CALIB_TIG_AMPS_CMD],
						 CALIB_2POINTS);
					hmi->CalibPointCmd[hmi->CalibStep] = Process[m->pCfg->HeadCfg.TIG.PROC_Indx].fParam[1];

					//}
					if (KK_ManualCalib)
						Process[m->pCfg->HeadCfg.TIG.PROC_Indx].fParam[1] = KK_ManualCalib_set_value;

					break;

				case 2:
					//if(StartBtn || KK_DoNot_Erase){
					hmi->CalibPoint[hmi->CalibStep] = 2;
					Process[m->pCfg->HeadCfg.TIG.PROC_Indx].fParam[1] =
						 getFromCalib(curCfg->Param[parTIG_CalibAmp2].val[0], &curCalib->Points[CALIB_TIG_AMPS_CMD],
						 CALIB_2POINTS);
					hmi->CalibPointCmd[hmi->CalibStep] = Process[m->pCfg->HeadCfg.TIG.PROC_Indx].fParam[1];

					//}
					if (KK_ManualCalib)
						Process[m->pCfg->HeadCfg.TIG.PROC_Indx].fParam[1] = KK_ManualCalib_set_value;

					break;

				default:
					Process[m->pCfg->HeadCfg.TIG.PROC_Indx].fParam[1] = 0.0;
					break;
			}

			break;

		//////////////////////////////////////////////////////////////////
		case CALIB_HW_PS:
			if ((Process[m->pCfg->HeadCfg.HW.PROC_Indx].Status == prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.HW.PROC_Indx].Status == prcsSTATUS_DirectCntrl))
			{

				if (StartBtn)
					Process[m->pCfg->HeadCfg.HW.PROC_Indx].xCMD = prcsCalib;

			}

			switch (hmi->CalibStep)
			{
				case 1:
					//if(StartBtn || KK_DoNot_Erase){
					hmi->CalibPoint[hmi->CalibStep] = 0;
					Process[m->pCfg->HeadCfg.HW.PROC_Indx].fParam[1] =
						 getFromCalib(curCfg->Param[parHW_CalibAmp1].val[0], &curCalib->Points[CALIB_HW_AMPS_CMD],
						 CALIB_2POINTS);
					hmi->CalibPointCmd[hmi->CalibStep] = Process[m->pCfg->HeadCfg.HW.PROC_Indx].fParam[1];

					//}
					if (KK_ManualCalib)
						Process[m->pCfg->HeadCfg.HW.PROC_Indx].fParam[1] = KK_ManualCalib_set_value;

					break;

				case 2:
					//if(StartBtn || KK_DoNot_Erase){
					hmi->CalibPoint[hmi->CalibStep] = 2;
					Process[m->pCfg->HeadCfg.HW.PROC_Indx].fParam[1] =
						 getFromCalib(curCfg->Param[parHW_CalibAmp2].val[0], &curCalib->Points[CALIB_HW_AMPS_CMD],
						 CALIB_2POINTS);
					hmi->CalibPointCmd[hmi->CalibStep] = Process[m->pCfg->HeadCfg.HW.PROC_Indx].fParam[1];

					//}
					if (KK_ManualCalib)
						Process[m->pCfg->HeadCfg.HW.PROC_Indx].fParam[1] = KK_ManualCalib_set_value;

					break;

				default:
					Process[m->pCfg->HeadCfg.HW.PROC_Indx].fParam[1] = 0.0;
					break;
			}

			break;

		///////////////////////////////////////////		
	}

	status				= 1;

	if (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status != prcsSTATUS_Stopped)
		status = 0;

	if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status != prcsSTATUS_Stopped)
		status = 0;

	if (Process[m->pCfg->HeadCfg.AVC.PROC_Indx].Status != prcsSTATUS_Stopped)
		status = 0;

	if (Process[m->pCfg->HeadCfg.WF.PROC_Indx].Status != prcsSTATUS_Stopped)
		status = 0;

	if (Process[m->pCfg->HeadCfg.WP.PROC_Indx].Status != prcsSTATUS_Stopped)
		status = 0;

	if (Process[m->pCfg->HeadCfg.TIG.PROC_Indx].Status != prcsSTATUS_Stopped)
		status = 0;

	if (Process[m->pCfg->HeadCfg.HW.PROC_Indx].Status != prcsSTATUS_Stopped)
		status = 0;

	if (!status)
	{


		//intrf->GlblBtnLED[0] += BTN_B0; //SEQ_STOP_LED 
		if (StopBtn)
		{ // Stop Button

			Process[m->pCfg->HeadCfg.TVL.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.OSC.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.AVC.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.WF.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.GAS.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.WP.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.TIG.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.TVL.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.HW.PROC_Indx].xCMD = prcsHalt;

		}


		ret 				= 2;

	}

	TimerExecute(&CalibrTMR);

	if (m->CalibType == CALIB_NONE)
		ret = 0;

	return ret;
}


void IncrParam(CurCfg_typ * curCfg, UINT param, DINT segm, float gain)
{
	int 			i;

	if (curCfg->Param[param].segmYes)
	{
		i					= segm;

		if (i > SEGM_NUM_MAX)
			i = SEGM_NUM_MAX;
	}
	else 
		i = 0;

	curCfg->Param[param].val[i] += curCfg->Param[param].incr * gain;

	if (curCfg->Param[param].val[i] > curCfg->Param[param].max)
		curCfg->Param[param].val[i] = curCfg->Param[param].max;

	return;

}


void DecrParam(CurCfg_typ * curCfg, UINT param, DINT segm, float gain)
{
	int 			i;


	if (curCfg->Param[param].segmYes)
	{
		i					= segm;

		if (i > SEGM_NUM_MAX)
			i = SEGM_NUM_MAX;
	}
	else 
		i = 0;

	curCfg->Param[param].val[i] -= curCfg->Param[param].incr * gain;

	if (curCfg->Param[param].val[i] < curCfg->Param[param].min)
		curCfg->Param[param].val[i] = curCfg->Param[param].min;

	return;
}


void Check_parOSC_Amplit(CurCfg_typ * curCfg, HMI_typ * hmi, UINT seg)
{
	float			x;

	/*		
	if(curCfg->Param[parOSC_Amplit].val[seg] < curCfg->Param[parOSC_FinalAmplit].val[seg] ){

		curCfg->Param[parOSC_Amplit].val[seg] = curCfg->Param[parOSC_FinalAmplit].val[seg];

		strcpy(hmi->pMessage[0], " OSC Primery	 ");
		strcpy(hmi->pMessage[1], " Amplitude ");
		strcpy(hmi->pMessage[2], " smaller then ");
		strcpy(hmi->pMessage[3], " Final Amplitude");
		TimerStart(&hmi->MsgTmr, 1.5);


	}

	if(curCfg->Param[parOSC_Amplit].val[seg] < curCfg->Param[parOSC_InitAmplit].val[seg] ){

		curCfg->Param[parOSC_Amplit].val[seg] = curCfg->Param[parOSC_InitAmplit].val[seg];

		strcpy(hmi->pMessage[0], " OSC Primery	 ");
		strcpy(hmi->pMessage[1], " Amplitude ");
		strcpy(hmi->pMessage[2], " smaller then ");
		strcpy(hmi->pMessage[3], " Init Amplitude");
		TimerStart(&hmi->MsgTmr, 1.5);


	}
	*/
	if (curCfg->Param[parOSC_Excur].val[seg] > 0)
	{

		x					= curCfg->Param[parOSC_Amplit].val[seg] / curCfg->Param[parOSC_Excur].val[seg];

		if (x > curCfg->Param[parOSC_MaxTvlVel].val[0])
		{

			curCfg->Param[parOSC_Amplit].val[seg] =
				 curCfg->Param[parOSC_MaxTvlVel].val[0] *curCfg->Param[parOSC_Excur].val[seg];

			strcpy(hmi->pMessage[0], " OSC	 ");
			strcpy(hmi->pMessage[1], " Amplitude ");
			strcpy(hmi->pMessage[2], " was");
			strcpy(hmi->pMessage[3], " too high");
			TimerStart(&hmi->MsgTmr, 1.5);

		}

	}
}


void Check_parOSC_Excur(CurCfg_typ * curCfg, HMI_typ * hmi, UINT seg)
{

	float			x;

	if ((curCfg->Param[parOSC_Excur].val[seg] > 0) && (curCfg->Param[parOSC_MaxTvlVel].val[0] > 0))
	{

		x					= curCfg->Param[parOSC_Amplit].val[seg] / curCfg->Param[parOSC_Excur].val[seg];

		if (x > curCfg->Param[parOSC_MaxTvlVel].val[0])
		{

			curCfg->Param[parOSC_Excur].val[seg] =
				 curCfg->Param[parOSC_Amplit].val[seg] / curCfg->Param[parOSC_MaxTvlVel].val[0];

			strcpy(hmi->pMessage[0], " OSC	 ");
			strcpy(hmi->pMessage[1], " Excurtion ");
			strcpy(hmi->pMessage[2], " was");
			strcpy(hmi->pMessage[3], " too small");
			TimerStart(&hmi->MsgTmr, 1.5);

		}

	}
}


void Fill_Segments(CurCfg_typ * curCfg, UINT par, UINT seg, UINT Mode, UINT Step)
{
	float			x;
	int 			i;

	if (!curCfg->Param[par].segmYes)
		return;

	switch (Mode)
	{
		case 1:
			for (i = seg; i < SEGM_NUM_MAX; i++)
				curCfg->Param[par].val[i] = curCfg->Param[par].val[seg];

			break;

		case 2:
			if (Step == 51)
			{ // RUN

				for (i = seg; i < SEGM_NUM_MAX; i++)
					curCfg->Param[par].val[i] = curCfg->Param[par].val[seg];

			}

			break;

		default:
			// OFF
			break;
	}

}


void SetBannerTxt(MASTER_typ * m, HMI_typ * hmi, HMI_INTRF_typ * intrf)
{

	if (!m || !hmi || !intrf)
		return;

	if (!hmi->pBanner)
		return;

	/*
	if(KK_AUTO_Test)
		strcpy(hmi->pBanner ,"AUTO/");
	else
		strcpy(hmi->pBanner ,"");
	*/
	strcpy(hmi->pBanner, "");


	if (!Hardware[1].CouplerOK[0])
	{

#ifndef TEST_ONLY_PLC_ANDROID
		strcat(hmi->pBanner, "Ext. Suitcase Err ");
		return;

#endif

	}

	else if (m->sm.Step >= 230 && m->sm.Step <= 236)
	{


		switch (m->sm.Step)
		{
			case 230:
				xsprintf(hmi->pBanner + strlen(hmi->pBanner), "Clear ESTOP to Refresh TML Setup ");
				break;

			case 232:
				xsprintf(hmi->pBanner + strlen(hmi->pBanner), "Wait!! Check TML  %3.1f",
					 ((float) (m->sm.Tmr1.PT - m->sm.Tmr1.ET)) / 1000.0);
				break;

			case 234:
			case 235:
			case 236:
				xsprintf(hmi->pBanner + strlen(hmi->pBanner), "Wait!! TML Setup %s %d %3.1f",
					 TML_MTR_INST[curTML_indx].Name, TML_MTR_INST[curTML_indx].xCMD, (float) m->sm.Tmr1.ET / 1000.0);
				break;

			default:
				xsprintf(hmi->pBanner + strlen(hmi->pBanner), "Wait!! Checking TML");
				break;
		}

		return;

	}
	else if (m->ESTOP)
	{
		strcat(hmi->pBanner, " ESTOP !!! ");
		return;

	}
	else if ((VectorStateMach[VECT_TVL].FbkVect.Mode == vectSt_Mode_Vel) && VectorStateMach[VECT_TVL].FbkWarning)
	{

		strcat(hmi->pBanner, "Max Cmd TVL - slow down !!!");
		return;

	}


	else if ((ErrorMgr.Error != 0) && (!m->LOCKED))
	{

		switch (ErrorMgr.Error)
		{
			case ERROR_FATAL:
				strcat(hmi->pBanner, "FATAL ERR MUST RBT !!!");
				break;

			default:
				strcat(hmi->pBanner, "	ERROR  !!!");
				break;
		}

		return;
	}
	else if (intrf->GlblBtnCmd[0])
	{

		strcat(hmi->pBanner, hmi->ActiveBanner);

		return;

	}


	switch (m->sm.Step)
	{

		
		case 49:

			strcat(hmi->pBanner, "Wait for ArcLink");
			
		break;

		
		case 50:
			if ((Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_Stopped) ||
				 (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_DirectCntrl))
			{

				strcat(hmi->pBanner, "	STOP ");

			}
			else if (Process[m->pCfg->HeadCfg.OSC.PROC_Indx].Status == prcsSTATUS_Run)
				strcat(hmi->pBanner, " OSC Test ");

		break;

		case 51:
			switch (m->SeqStep)
			{
				case 1:
					xsprintf(hmi->pBanner + strlen(hmi->pBanner), "START !!! %3.1f ",
						 ((float) (m->sm.Tmr1.PT - m->sm.Tmr1.ET)) / 1000.0);
					break;

				case 2:
					strcat(hmi->pBanner, " Wait ARC ");
					break;

				case 3:
					strcat(hmi->pBanner, " RUN ");
					break;

				case 150:
					xsprintf(hmi->pBanner + strlen(hmi->pBanner), "REWRAP !!! %3.1f ",
						 ((float) (m->sm.Tmr1.PT - m->sm.Tmr1.ET)) / 1000.0);
					break;

				case 202:
					switch (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status)
					{
						case prcsSTATUS_StopDly:
							strcat(hmi->pBanner, "TVL Stop Dly");
							break;

						case prcsSTATUS_RampDwn:
							strcat(hmi->pBanner, "TVL Ramp Dwn");
							break;

						case prcsSTATUS_ReturnDly:
							strcat(hmi->pBanner, "TVL Ret Dly");
							break;

						case prcsSTATUS_Return:
							strcat(hmi->pBanner, "TVL Return");
							break;
					}

					break;

				case 203:
					strcat(hmi->pBanner, "Wait Head Return");
					break;

				case 205:
					strcat(hmi->pBanner, "Wait New File Load");
					break;

				case 220:
					xsprintf(hmi->pBanner + strlen(hmi->pBanner), "AUTO START !!! %3.1f ",
						 ((float) (m->sm.Tmr1.PT - m->sm.Tmr1.ET)) / 1000.0);
					break;

				case 255:
					strcat(hmi->pBanner, "Wait OSC Stop");
					break;

				default:
					strcat(hmi->pBanner, " Stopping ");
					break;
			}

			break;

		case 100:

			/*
			if(hmi->curHeadID < 0xFFFE)			
				strcat (hmi->pBanner , hmi->ActiveBanner);
			else */
			strcat(hmi->pBanner, " Calib.STOP ");
			break;

		case 101:

			/*if(hmi->curHeadID < 0xFFFE)			
				strcat (hmi->pBanner , hmi->ActiveBanner);
			else */
			strcat(hmi->pBanner, " Calib.RUN ");
			break;

		case 220:
			strcat(hmi->pBanner, " TML Firm. ");
			break;

		case 230:
			strcpy(hmi->pBanner, " NEW HEAD CONFIGURATION was Selected");
			break;

		default:
			//strcat(hmi->pBanner, " INIT ");
			strcat(hmi->pBanner, m->sm.Text);
			break;
	}

	switch (m->SubSeqStep)
	{
		default:
			break;

		case 1:
			strcat(hmi->pBanner, " >>T");
			break;

		case 2:
			strcat(hmi->pBanner, " >>R");
			break;
	}

	/*
	if(intrf->TestMode) 	
		strcat(hmi->pBanner , " TEST");

	if(m->WireDisabled) 	
		strcat(hmi->pBanner , "/WIRE OFF");

	if(Process[m->pCfg->HeadCfg.AVC.PROC_Indx].Param[0])
		strcat(hmi->pBanner , "/LOCKED");
	*/
	return;

}


float getBtnProgress()
{

	return (float) (btnProgress + btnProgressBias) / (float) (btnProgressMax + btnProgressBias);

}


void SetZeroPosition(MASTER_typ * m)
{


	if (TVL_ROT_Param_Set[0].pEncoder)
		OLD_MTR_POS[TVL_ENC_HOME] = *TVL_ROT_Param_Set[0].pEncoder;

	if (TVL_ROT_Param_Set[0].pEncoder)
		OLD_MTR_POS[TVL_ZONE_HOME] = *TVL_ROT_Param_Set[0].pEncoder;


	return;

}


void CreateParamList()
{
	UINT			i;

	i					= 0;
	ParamList.Index[i++] = parGEN_WeldProgramRepeat;

	// All parameters from segment editor	
	ParamList.Index[i++] = parTIG_AmpSP;

	//ParamList.Index[i++] = parTIG_BackAmp;
	//ParamList.Index[i++] = parTIG_PulseFreq;
	//ParamList.Index[i++] = parTIG_PulseWidth;	
	ParamList.Index[i++] = parAVC_VoltSP;

	//ParamList.Index[i++] = parAVC_VoltBackSP;
	ParamList.Index[i++] = parTVL_VelSP;
	ParamList.Index[i++] = parWF_SpeedSP;
	ParamList.Index[i++] = parWP_SpeedSP;
	ParamList.Index[i++] = parHW_AmpSP;
	ParamList.Index[i++] = parOSC_Amplit;
	ParamList.Index[i++] = parOSC_Excur;
	ParamList.Index[i++] = parOSC_Dwell_In;
	ParamList.Index[i++] = parOSC_Dwell_Out;



	// All parameters  from Timing Calculation
	ParamList.Index[i++] = parAVC_Upslope;
	ParamList.Index[i++] = parAVC_StopDly;
	ParamList.Index[i++] = parAVC_DownSlope;

	ParamList.Index[i++] = parTVL_StartDly;
	ParamList.Index[i++] = parTVL_RampUp;
	ParamList.Index[i++] = parTVL_StopDly;
	ParamList.Index[i++] = parTVL_RampDwn;
	ParamList.Index[i++] = parTVL_RewrapDly;
	ParamList.Index[i++] = parTVL_RunDist;
	ParamList.Index[i++] = parTVL_RewrapDist;


	ParamList.Index[i++] = parWF_StartDly;
	ParamList.Index[i++] = parWF_RampUp;
	ParamList.Index[i++] = parWF_StopDly;
	ParamList.Index[i++] = parWF_RampDwn;
	ParamList.Index[i++] = parWF_RetractDly;

	ParamList.Index[i++] = parTIG_StartDly;
	ParamList.Index[i++] = parTIG_RampUp;
	ParamList.Index[i++] = parTIG_StopDly;
	ParamList.Index[i++] = parTIG_RampDwn;

	ParamList.Index[i++] = parOSC_StartDly;
	ParamList.Index[i++] = parOSC_RampUp;
	ParamList.Index[i++] = parOSC_StopDly;
	ParamList.Index[i++] = parOSC_RampDwn;

	ParamList.Index[i++] = parWP_StartDly;
	ParamList.Index[i++] = parWP_RampUp;
	ParamList.Index[i++] = parWP_StopDly;
	ParamList.Index[i++] = parWP_RampDwn;

	ParamList.Index[i++] = parHW_RampDwnDly;
	ParamList.Index[i++] = parHW_RampUp;
	ParamList.Index[i++] = parHW_RampDwnDly;
	ParamList.Index[i++] = parHW_RampDwn;
	ParamList.Index[i++] = parGAS_PostPurgeTm;


	ParamList.IndexNum	= i;



	i					= 0;
	ParamList.Index_Enum[i++] = parENUM_WeldProgramLinkMode;
	ParamList.Index_Enum[i++] = parENUM_PathMode;
	ParamList.Index_Enum[i++] = parENUM_WeldProgramCase;

	ParamList.IndexNum_Enum = i;

	i					= 0;
	ParamList.Index_Int[i++] = parINT_NumZone;

	ParamList.IndexNum_Int = i;



}


void DeleteExtension(char * p)
{

	UINT			len, i;

	len 				= strlen(p);

	for (i = 0; i < len; i++)
	{

		if (p[i] == '.')
		{

			p[i]				= 0;
			break;

		}

	}

	return;

}




void WireDisableInable(plcbit Tmr_Q)
{


	if (!m->WireDisabled)
	{


		if (Tmr_Q)
		{

			if (Process[m->pCfg->HeadCfg.WP.PROC_Indx].Status == prcsSTATUS_Stopped)
				Process[m->pCfg->HeadCfg.WP.PROC_Indx].xCMD = prcsJump2Run;

			if (Process[m->pCfg->HeadCfg.WF.PROC_Indx].Status == prcsSTATUS_Stopped)
				Process[m->pCfg->HeadCfg.WF.PROC_Indx].xCMD = prcsJump2Run;

			if (Process[m->pCfg->HeadCfg.HW.PROC_Indx].Status == prcsSTATUS_Stopped)
				Process[m->pCfg->HeadCfg.HW.PROC_Indx].xCMD = prcsJump2Run;


		}
		else 
		{

			if (Process[m->pCfg->HeadCfg.WP.PROC_Indx].Status == prcsSTATUS_Stopped)
				Process[m->pCfg->HeadCfg.WP.PROC_Indx].xCMD = prcsSTART;

			if (Process[m->pCfg->HeadCfg.WF.PROC_Indx].Status == prcsSTATUS_Stopped)
				Process[m->pCfg->HeadCfg.WF.PROC_Indx].xCMD = prcsSTART;

			if (Process[m->pCfg->HeadCfg.HW.PROC_Indx].Status == prcsSTATUS_Stopped)
				Process[m->pCfg->HeadCfg.HW.PROC_Indx].xCMD = prcsSTART;



		}

	}
	else 
	{

		// Nowe
		if (Process[m->pCfg->HeadCfg.WP.PROC_Indx].Status == prcsSTATUS_Run)
			Process[m->pCfg->HeadCfg.WP.PROC_Indx].xCMD = prcsQuickSTOP;

		//Process[m->pCfg->HeadCfg.WP.PROC_Indx].xCMD = prcsHalt;
		if (Process[m->pCfg->HeadCfg.WF.PROC_Indx].Status != prcsSTATUS_Stopped) //Process[m->pCfg->HeadCfg.WF.PROC_Indx].xCMD = prcsHalt;
			Process[m->pCfg->HeadCfg.WF.PROC_Indx].xCMD = prcsQuickSTOP;


		if (Process[m->pCfg->HeadCfg.HW.PROC_Indx].Status != prcsSTATUS_Stopped)
			Process[m->pCfg->HeadCfg.HW.PROC_Indx].xCMD = prcsSTOP;



	}

	return;
}



void DumpParamToFile()
{

	char			tmpTxt[32];
	int 			len;

	switch (parametersDump_Step)
	{
		case 0:
			break;

		case 1:
			if (File_RW.CMD == 0)
			{

				strcpy(File_RW.deviceName, "WeldPrograms");
				File_RW._int.wStatus = 0;

				DTGetTime_1.enable	= 1;
				DTGetTime(&DTGetTime_1);
				DT_TO_DTStructure(DTGetTime_1.DT1, (UDINT) (&DTStruct));

				xsprintf(File_RW.fileNewName, "%s_%d_%d_%d.txt", curCfg->CurProgramName, 
					DTStruct.hour, DTStruct.minute, DTStruct.second);

				File_RW._int.wStatus = 0;
				File_RW.CMD 		= F_OPEN_ONLY;
				parametersDump_Step++;

			}

			break;

		case 2:
			if (File_RW.CMD == 0)
			{

				File_RW.pMem		= (UDINT)
				LineTxt;
				File_RW.Offset		= 0;
				File_RW.Len 		= 0;
				paramIndx			= parOSC_StartDly;


				/* status (20708 -> File doesn't exist) */
				if (File_RW._int.wStatus == 20708)
				{
					File_RW.CMD 		= F_CREATE_ONLY;
					parametersDump_Step++;
				}
				else if (!File_RW.Error)
				{
					File_RW.CMD 		= F_DELETE;
				}
				else 
					parametersDump_Step = 0;

			}

			break;

		case 3:
			if (File_RW.CMD == 0)
			{


				ascDTStructure((UDINT) &DTStruct, tmpTxt, 25);

				xsprintf(LineTxt, " Program: %s -  Stored at: %s \n\n\r////// Parameters ///// \n\r  ",
					 curCfg->CurProgramName, tmpTxt);

				//ascDTStructure((UDINT) &DTStruct, LineTxt + strlen(LineTxt), 25);
				len 				= strlen(LineTxt);

				//LineTxt[len++]= 0x0D; //CR
				//LineTxt[len++]= 0x0D; // CR
				File_RW.Len 		= strlen(LineTxt);
				File_RW.CMD 		= F_WRITE_ONLY;
				parametersDump_Step++;

			}

			break;

		case 4:
			if (File_RW.CMD == 0)
			{

				if (paramIndx < parLAST_PARAM)
				{

					File_RW.Offset		+= File_RW.Len;

					if (strlen(cfg->ScaledVar[paramIndx].name) > 0)
					{

						xsprintf(LineTxt, "Par. %d (%s):[ %s ] = %s \n\r ", paramIndx,
							 cfg->ScaledVar[paramIndx].enumTXT, cfg->ScaledVar[paramIndx].name,
							 GetScaledVal(lcd, &cfg->ScaledVar[paramIndx], 0));
					}
					else 
						xsprintf(LineTxt, "Par. %d:///	available\n\r ", paramIndx);



					File_RW.Len 		= strlen(LineTxt);
					File_RW.CMD 		= F_WRITE_ONLY;
					paramIndx++;


				}
				else 
				{

					File_RW.Offset		+= File_RW.Len;

					xsprintf(LineTxt, "//////  Text Resources	///////// \n\r");
					File_RW.Len 		= strlen(LineTxt);
					File_RW.CMD 		= F_WRITE_ONLY;

					paramIndx			= 0;
					parametersDump_Step++;

				}

			}

			break;

		case 5:
			if (File_RW.CMD == 0)
			{

				if (paramIndx < TXT_RESOURCES_MAX)
				{

					if (strlen(cfg->TXT_Resources[paramIndx]) > 0)
					{

						File_RW.Offset		+= File_RW.Len;

						xsprintf(LineTxt, "Txt Res. %d: [ %s ] \n\r", paramIndx, cfg->TXT_Resources[paramIndx]);

						File_RW.Len 		= strlen(LineTxt);
						File_RW.CMD 		= F_WRITE_ONLY;

					}

					paramIndx++;


				}
				else 
				{


					File_RW.Offset		+= File_RW.Len;

					xsprintf(LineTxt, "//////	Error Text	 ///////// \n\r");
					File_RW.Len 		= strlen(LineTxt);
					File_RW.CMD 		= F_WRITE_ONLY;

					paramIndx			= 0;
					parametersDump_Step++;

				}

			}

			break;

		case 6:
			if (File_RW.CMD == 0)
			{


				if (paramIndx < 128)
				{


					if (strlen(ErrorMgr.logs[paramIndx].txt) > 0)
					{

						File_RW.Offset		+= File_RW.Len;

						xsprintf(LineTxt, "Err %d: [ %s ] \n\r", paramIndx, ErrorMgr.logs[paramIndx].txt);


						File_RW.Len 		= strlen(LineTxt);
						File_RW.CMD 		= F_WRITE_ONLY;
					}

					paramIndx++;


				}
				else 
				{

					paramIndx			= 0;
					parametersDump_Step = 10;

				}

			}

			break;

		case 10:
			File_RW.CMD = F_CLOSE_ONLY;
			parametersDump_Step = 0;
			break;
	}

}


void EvaluatePosition()
{


	if (m->pCfg->HeadCfg.TVL.EncPerTick == 0)
	{ ///	 VERSION with pins

		/*	TO DO ZMIANY	

		////  Real Switch - Pins

		// Input filter
		DebounceTickSw++;

		if(DebounceTickSw > DebounceTickSwMax)
			TickSw = Hardware[1].Inp[23];

		if(_segmSw != Hardware[1].Inp[23])
			DebounceTickSw = 0;


		_segmSw = Hardware[1].Inp[23]; 
		////////////

		if(TickSw !=_TickSw){

			if((VectorStateMach[VECT_TVL].InVal * m->directTVL) > 0){

				Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[2] = 1; // Tick from Pin to Travel	
				actTicks++;			


			}
			else{

				Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[2] = -1; // Tick from Pin to Travel	
				actTicks--;

			}

			if(m->ToolHeadID) // Dippendnce which head is going forward
				Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[2] = Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[2] * 
			(-1); // Tick from Pin to Travel
						
			
			if(ClearRun)
				m->curSegm[ACT_TVL_DIST] += Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[2];

			KK_actPosProcss += Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Param[2];

				


		}

		_TickSw = TickSw;

		*/
	}
	else 
	{ //VERSION with encoder

		//tickEncoder = (AxisCh[m->pCfg->HeadCfg.TVL.TML_Indx].curPos  - encHome);			
		tickEncoder 		=
			 (VectorStateMach[m->pCfg->HeadCfg.TVL.VECT_Indx].actPosDINT - OLD_MTR_POS[TVL_ZONE_HOME]);
		actTicks			= tickEncoder / m->pCfg->HeadCfg.TVL.EncPerTick;
		actTicks			= actTicks * m->pCfg->HeadCfg.TVL.Enc_Dir;
	}

	if (m->ticksPerSegm < 1)
		m->ticksPerSegm = 1;

	if (m->ticksPerZone < 1)
		m->ticksPerZone = 1;


	m->curSegm[ACT_TVL_DIST] = TVL_ROT_Param_Set[0].EncPos_FBK;
	actRot				= actTicks / curCalib->GenSetup[SETUP_PIN_PER_ROT];


	if (m->ticksPerSegm > 0 && m->ticksPerZone > 0)
	{

		m->curSegm[FR_SEGM] = (actTicks / m->ticksPerSegm);
		m->curSegm[ZONE]	= (actTicks / m->ticksPerZone);
		m->curSegm[HEAD_SEGM] = m->curSegm[ACT_TVL_DIST] / m->ticksPerSegm;



		// Zone Position
		if (!m->ToolHeadID)
			actTicksForZone = actTicks;

		else 
		{

			switch (m->pCfg->HeadCfg.GEN.Torch_Mode)
			{
				case MODE_SINGLE_TORCH:
					actTicksForZone = actTicks * (-1); // The same head but different direction
					break;

				case MODE_DOUBLE_TORCH:
					actTicksForZone = (m->numSegm / 2) -actTicks; // shift by 180 deg
					break;
			}

		}

		m->curSegm[ZONE]	= actTicksForZone / m->ticksPerZone;

		m->curSegm[ZONE_RAW] = m->curSegm[ZONE];

		if (m->curSegm[ZONE] < 0)
			m->curSegm[ZONE] = 0;

		m->curSegm[ZONE] ++;

		//////////////		
		if (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status == prcsSTATUS_Stopped)
			stillRun = 0;

		else if (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status == prcsSTATUS_Run)
		{

			if (m->curSegm[ZONE] < m->numZone)
				stillRun = 1;

		}



		if (m->curSegm[ZONE] > m->numZone)
		{

			if (Process[m->pCfg->HeadCfg.TVL.PROC_Indx].Status == prcsSTATUS_Stopped)
				m->curSegm[ZONE] = 1;

			else 
			{

				if (stillRun)
					m->curSegm[ZONE] = m->numZone;
				else 
					m->curSegm[ZONE] = 1;

			}

		}

		////////////////////////
		if (m->curSegm[ZONE] > m->numZone)
			m->curSegm[ZONE] = m->numZone;


	}

	actTicksPerm		= actTicks;

}


int WatchArcLinkError(MASTER_typ * m, Robot_typ * robot)
{
	int ret 			= 0;

	if(robot)
	{ // Arclink connection

		if(robot->Cntrl.Fbk.Error)
		{
			if(robot->Cntrl.Fbk.Error & ArcLink_Com_Failed){
				
				Errors(&ErrorMgr, ERROR_TIG_PROC, ERROR_ARCLINK_COM_LOST, (UDINT) robot->Cntrl.Fbk.Error);
				LogTxt(&LogMgr, "Arclink Com Err %d", (UDINT) robot->Cntrl.Fbk.Error);
			
			}else{
				
				Errors(&ErrorMgr, ERROR_TIG_PROC, ERROR_ARCLINK_PS_ERR, (UDINT) robot->Cntrl.Fbk.Error);
				LogTxt(&LogMgr, "Arclink Err %d", (UDINT) robot->Cntrl.Fbk.Error);

			}			
			ret 				= 1;

		}

	}

	return ret;
}



